// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.2.5
//   protoc               v6.32.1
// source: im_msg_body.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";

export const protobufPackage = "im_msg_body";

export interface MsgBody {
  /** 可读消息 */
  richText?:
    | RichText
    | undefined;
  /** 透传的消息体 */
  msgContent?:
    | Uint8Array
    | undefined;
  /** 加密的消息体 */
  msgEncryptContent?: Uint8Array | undefined;
}

export interface RichText {
  /** 消息的字体，颜色，大小等相关属性 */
  attr?:
    | Attr
    | undefined;
  /** 消息的种类，包括文本消息，系统表情消息 */
  elems: Elem[];
  /** 离线文件 */
  notOnlineFile?:
    | NotOnlineFile
    | undefined;
  /** ptt */
  ptt?:
    | Ptt
    | undefined;
  /** 临时会话 PTT */
  tmpPtt?:
    | TmpPtt
    | undefined;
  /** 临时会话211透传协议，tmp_ptt 序列化后也可以使用该字段 */
  trans211TmpMsg?: Trans211TmpMsg | undefined;
}

export interface Trans211TmpMsg {
  /** 211 的body */
  bytesMsgBody?:
    | Uint8Array
    | undefined;
  /** 用于区分透传的消息类型，比如ptt 为6，传文件为 4 */
  uint32C2cCmd?: number | undefined;
}

export interface Attr {
  codePage?: number | undefined;
  time?:
    | number
    | undefined;
  /** 随机数，用来消息的去重判断 */
  random?: number | undefined;
  color?: number | undefined;
  size?: number | undefined;
  effect?: number | undefined;
  charSet?: number | undefined;
  pitchAndFamily?: number | undefined;
  fontName?: string | undefined;
  reserveData?: Uint8Array | undefined;
}

/**
 * 消息元素，不一定完全对应hummer ELEM
 * 注意：一个Elem里面只有一个结构体数据
 */
export interface Elem {
  /** 文本消息(ELEMTYPE=1) */
  text?:
    | Text
    | undefined;
  /** 系统表情消息(ELEMTYPE=2) */
  face?:
    | Face
    | undefined;
  /** 在线图片(ELEMTYPE=5) */
  onlineImage?:
    | OnlineImage
    | undefined;
  /** 离线图片(ELEMTYPE=6) */
  notOnlineImage?:
    | NotOnlineImage
    | undefined;
  /** 透传 elem */
  transElemInfo?:
    | TransElem
    | undefined;
  /** QQ商城表情(ELEMTYPE=12) */
  marketFace?:
    | MarketFace
    | undefined;
  /** FLAGS，控制用(ELEMTYPE=8), 2015-7-21: 后续新增flag放到 general_flags */
  elemFlags?:
    | ElemFlags
    | undefined;
  /** 图片，采用自定义表情传输逻辑(ELEMTYPE=3) */
  customFace?:
    | CustomFace
    | undefined;
  /** 业务数据(ELEMTYPE=14), 2015-7-21: 后续新增flag放到 general_flags */
  elemFlags2?:
    | ElemFlags2
    | undefined;
  /** 趣味表情(ELEMTYPE=19) */
  funFace?:
    | FunFace
    | undefined;
  /** 私密照片（ELEMTYPE=23 */
  secretFile?:
    | SecretFileMsg
    | undefined;
  /** 结构化消息(ELEMTYPE=20) */
  richMsg?:
    | RichMsg
    | undefined;
  /** 讨论组传文件(ELEMTYPE=21) */
  groupFile?:
    | GroupFile
    | undefined;
  /** 群公开(ELEMTYPE=15) */
  pubGroup?:
    | PubGroup
    | undefined;
  /** 营销QQ透传(ELEMTYPE=22) */
  marketTrans?:
    | MarketTrans
    | undefined;
  /** 消息附属信息(ELEMTYPE=18) */
  extraInfo?:
    | ExtraInfo
    | undefined;
  /** 抖一抖 */
  shakeWindow?:
    | ShakeWindow
    | undefined;
  /** 公共帐号(ELEMTYPE=16) */
  pubAccount?:
    | PubAccount
    | undefined;
  /** 视频文件信息 */
  videoFile?:
    | VideoFile
    | undefined;
  /** tips提示信息 */
  tipsInfo?:
    | TipsInfo
    | undefined;
  /** 匿名群消息 */
  anonGroupMsg?:
    | AnonymousGroupMsg
    | undefined;
  /** 老的QQLive消息 */
  qqLiveOld?:
    | QQLiveOld
    | undefined;
  /** 生活服务 */
  lifeOnline?:
    | LifeOnlineAccount
    | undefined;
  /** QQ钱包消息 */
  qqwalletMsg?:
    | QQWalletMsg
    | undefined;
  /** CRM自定义elem */
  crmElem?:
    | CrmElem
    | undefined;
  /** 会议提示消息 */
  conferenceTipsInfo?:
    | ConferenceTipsInfo
    | undefined;
  /** 红包消息相关信息 */
  redbagInfo?:
    | RedBagInfo
    | undefined;
  /** PCQQ通用升级提醒 */
  lowVersionTips?:
    | LowVersionTips
    | undefined;
  /** 银行卡消息控制信息 */
  bankcodeCtrlInfo?:
    | Uint8Array
    | undefined;
  /** 附近的人表白消息 */
  nearByMsg?:
    | NearByMessageType
    | undefined;
  /** 用户自定义数据, sdk */
  customElem?:
    | CustomElem
    | undefined;
  /** 地理信息, sdk */
  locationInfo?:
    | LocationInfo
    | undefined;
  /** 公众账号自定义信息 */
  pubAccInfo?:
    | PubAccInfo
    | undefined;
  /** 面板小表情(区别于系统表情与小黄脸) */
  smallEmoji?:
    | SmallEmoji
    | undefined;
  /** 泛社交消息相关Elem */
  fsjMsgElem?:
    | FSJMessageElem
    | undefined;
  /** 轻App应用，即aio里面嵌入轻量型app */
  arkApp?:
    | ArkAppElem
    | undefined;
  /** 2015-7-21, 新增flag放到这里。对hummer来说，通过"万能ELEM(25)"包含该数据 */
  generalFlags?:
    | GeneralFlags
    | undefined;
  /** 热聊闪照，为低版本兼容，独立开来 */
  hcFlashPic?:
    | CustomFace
    | undefined;
  /** justinytang, 群内送礼物消息，目前只有送花，为低版本兼容，新版本展示可定制化小灰条内容,使用该message请先联系justinytang */
  deliverGiftMsg?:
    | DeliverGiftMsg
    | undefined;
  /** 轻app应用，即aio里面嵌入轻量型app，基于react */
  bitappMsg?: BitAppMsg | undefined;
  openQqData?: OpenQQData | undefined;
  apolloMsg?: ApolloActMsg | undefined;
  groupPubAccInfo?: GroupPubAccountInfo | undefined;
  blessMsg?: BlessingMessage | undefined;
  srcMsg?:
    | SourceMsg
    | undefined;
  /** 劳拉消息系统 */
  lolaMsg?:
    | LolaMsg
    | undefined;
  /** //群运营号消息(明星入群) */
  groupBusinessMsg?:
    | GroupBusinessMsg
    | undefined;
  /** 审批等业务通用C2C临时会话通知消息内容 */
  msgWorkflowNotify?:
    | WorkflowNotifyMsg
    | undefined;
  /** 拍一拍 */
  patElem?:
    | PatsElem
    | undefined;
  /** 群话题透传消息 */
  groupPostElem?:
    | GroupPostElem
    | undefined;
  /** 轻App应用 */
  lightApp?:
    | LightAppElem
    | undefined;
  /** EIM相关信息 */
  eimInfo?:
    | EIMInfo
    | undefined;
  /** 扩展的通用的Elem, 彻底解决im_msg_body.proto文件频繁修改的问题 */
  commonElem?: CommonElem | undefined;
}

export interface CommonElem {
  /** 业务类型，统一管理, 参见hummer_commelem.proto的定义 */
  uint32ServiceType: number;
  /** 不同业务类型对应的pb结构序列化的字符串, 参见hummer_commelem.proto的定义 */
  bytesPbElem?:
    | Uint8Array
    | undefined;
  /** 业务子类型【目前取值限定在1到127，不能超出这个范围】，方便在同一个service_type下区分子类业务 ,业务可以把内部的分类填进去。这样消息后台可以基于 service_type 和 business_type 做处理。 */
  uint32BusinessType?: number | undefined;
}

export interface GroupBusinessMsg {
  /** 群运营号消息 flag = 1,1:群运营号消息 2:他人发出的消息 3：自己发出的消息 */
  uint32Flags?:
    | number
    | undefined;
  /** 头像url */
  bytesHeadUrl?:
    | Uint8Array
    | undefined;
  /** 头像点击后的跳转url */
  bytesHeadClkUrl?:
    | Uint8Array
    | undefined;
  /** 昵称 */
  bytesNick?:
    | Uint8Array
    | undefined;
  /** 昵称颜色#FFFFFF */
  bytesNickColor?:
    | Uint8Array
    | undefined;
  /** 头衔名称 */
  bytesRank?:
    | Uint8Array
    | undefined;
  /** 头衔文字颜色 */
  bytesRankColor?:
    | Uint8Array
    | undefined;
  /** 头衔背景颜色 */
  bytesRankBgcolor?: Uint8Array | undefined;
}

export interface LolaMsg {
  /** 长消息resid */
  bytesMsgResid?:
    | Uint8Array
    | undefined;
  /** 用于后台 */
  bytesEncodeContent?: Uint8Array | undefined;
  bytesLongMsgUrl?: Uint8Array | undefined;
  bytesDownloadKey?: Uint8Array | undefined;
}

export interface GroupPubAccountInfo {
  uint64PubAccount?: number | undefined;
}

export interface ApolloActMsg {
  /** 动作id */
  uint32ActionId?:
    | number
    | undefined;
  /** 动作名称也用来转义动画 */
  bytesActionName?:
    | Uint8Array
    | undefined;
  /** 动作头顶的文字（C2C会话是文本，群中是好友昵称） */
  bytesActionText?:
    | Uint8Array
    | undefined;
  /** 时间戳是否拉取标识符[0 bit:发送方是否拉取时间戳; 1 bit:接收方是否拉取时间戳] */
  uint32Flag?:
    | number
    | undefined;
  /** 接收方UIN（好友或者群成员） */
  uint32PeerUin?:
    | number
    | undefined;
  /** 发送者个性形象数据更新时间戳 */
  uint32SenderTs?:
    | number
    | undefined;
  /** 接受者个性形象数据更新时间戳 */
  uint32PeerTs?:
    | number
    | undefined;
  /** 发送者阿波罗开通状态 */
  int32SenderStatus?:
    | number
    | undefined;
  /** 接收者阿波罗开通状态 */
  int32PeerStatus?:
    | number
    | undefined;
  /** diy文本id */
  diytextId?:
    | number
    | undefined;
  /** diy文本内容 */
  diytextContent?:
    | Uint8Array
    | undefined;
  /** 输入aio文本 */
  inputText?:
    | Uint8Array
    | undefined;
  /** 厘米秀动作消息扩展的pb结构，参见apollo_msg_auth.proto */
  bytesPbReserve?: Uint8Array | undefined;
}

export interface Text {
  /** 文本内容 */
  str?:
    | Uint8Array
    | undefined;
  /** 超链接, 这个客户端出于安全考虑已经废弃了，请以文本方式传链接 */
  link?:
    | string
    | undefined;
  /** Flag，用于fixbug(ATTR=6) */
  attr6Buf?:
    | Uint8Array
    | undefined;
  /** 表情商城兼容文本不分片标记(ATTR=7) */
  attr7Buf?:
    | Uint8Array
    | undefined;
  /** 文本其他信息Buffer */
  buf?:
    | Uint8Array
    | undefined;
  /** 文本消息扩展的pb结构，参见hummer_resv_1.proto */
  bytesPbReserve?: Uint8Array | undefined;
}

export interface Face {
  /** 系统表情索引号 */
  index?:
    | number
    | undefined;
  /** 老格式的系统表情数据 */
  old?:
    | Uint8Array
    | undefined;
  /** 表情其他信息Buffer */
  buf?: Uint8Array | undefined;
}

export interface CustomFace {
  /** 图片 Guid */
  bytesGuid?:
    | Uint8Array
    | undefined;
  /** 文件系统路径 */
  strFilePath?:
    | string
    | undefined;
  /** 快捷键 */
  strShortcut?:
    | string
    | undefined;
  /** 运营表情信息Buffer */
  bytesBuffer?:
    | Uint8Array
    | undefined;
  /** 图片 Flag */
  bytesFlag?:
    | Uint8Array
    | undefined;
  /** 旧版本数据 */
  bytesOldData?:
    | Uint8Array
    | undefined;
  /** 图片文件ID（群消息使用） */
  uint32FileId?:
    | number
    | undefined;
  /** 取图片的serverIP（群消息使用） */
  uint32ServerIp?:
    | number
    | undefined;
  /** 取图片的serverPort（群消息使用） */
  uint32ServerPort?:
    | number
    | undefined;
  /** 图片类型（群消息使用） */
  uint32FileType?:
    | number
    | undefined;
  /** 文件验证码（群消息使用） */
  bytesSignature?:
    | Uint8Array
    | undefined;
  /** 图片文件可用标记（群消息使用） */
  uint32Useful?:
    | number
    | undefined;
  /** 图片MD5（群消息使用） */
  bytesMd5?:
    | Uint8Array
    | undefined;
  /** 缩略图下载地址 */
  strThumbUrl?:
    | string
    | undefined;
  /** 大图下载地址 */
  strBigUrl?:
    | string
    | undefined;
  /** 原图下载地址 */
  strOrigUrl?:
    | string
    | undefined;
  /** 业务类型，1表示涂鸦 2->拍照 3->相册 4->转发 5->自定义表情 */
  bizType?:
    | number
    | undefined;
  /** 重复的自定义表情索引（兼容GBK） */
  repeatIndex?:
    | number
    | undefined;
  /** 重复的群图片索引（群消息使用，兼容GBK） */
  repeatImage?:
    | number
    | undefined;
  /** 图片格式：0-jpg，2-gif，3-bmp，静态图定义从0x1000开始，动态图定义从0x2000开始 */
  imageType?:
    | number
    | undefined;
  /** 图片索引 */
  index?:
    | number
    | undefined;
  /** 图片宽度 */
  uint32Width?:
    | number
    | undefined;
  /** 图片高度 */
  uint32Height?:
    | number
    | undefined;
  /** 图片来源id（截图，表情，上传等） */
  uint32Source?:
    | number
    | undefined;
  /** 图片大小，单位byte */
  uint32Size?:
    | number
    | undefined;
  /** 是否原图 */
  uint32Origin?:
    | number
    | undefined;
  /** 图片对应缩略图宽度 */
  uint32ThumbWidth?:
    | number
    | undefined;
  /** 图片对应缩略图高度 */
  uint32ThumbHeight?:
    | number
    | undefined;
  /** 文件最小显示长度 */
  uint32ShowLen?:
    | number
    | undefined;
  /** 文件最小下载长度 */
  uint32DownloadLen?:
    | number
    | undefined;
  /** 400缩略图下载地址 */
  str400Url?:
    | string
    | undefined;
  /** 400缩略图的宽度 */
  uint32400Width?:
    | number
    | undefined;
  /** 400缩略图的高度 */
  uint32400Height?:
    | number
    | undefined;
  /** 图片的扩展结构,参见hummer_resv_3.proto */
  bytesPbReserve?: Uint8Array | undefined;
}

export interface MarketFace {
  /** 表情名称，UTF-8 */
  bytesFaceName?:
    | Uint8Array
    | undefined;
  /** 后台二进制编码是主机字节序，不是网络，默认值 6 */
  uint32ItemType?:
    | number
    | undefined;
  /** 默认为1 */
  uint32FaceInfo?:
    | number
    | undefined;
  /** 16字节，表情ID */
  bytesFaceId?:
    | Uint8Array
    | undefined;
  /** 表情的分组ID */
  uint32TabId?:
    | number
    | undefined;
  /** 表情类型: 0->None，1->魔法表情，2->gif，3->png */
  uint32SubType?:
    | number
    | undefined;
  /** 16字节，表情的加密KEY */
  bytesKey?:
    | Uint8Array
    | undefined;
  /** 魔法表情的播放参数 */
  bytesParam?:
    | Uint8Array
    | undefined;
  /** 媒体类型：1->有声表情，2->动态表情秀 */
  uint32MediaType?:
    | number
    | undefined;
  /** 表情图片的宽度 */
  uint32ImageWidth?:
    | number
    | undefined;
  /** 表情图片的高度 */
  uint32ImageHeight?:
    | number
    | undefined;
  /** 手Q的播放参数，避免与PC冲突 */
  bytesMobileparam?:
    | Uint8Array
    | undefined;
  /** 商城表情业务控制的扩展结构,参见hummer_resv_12.proto */
  bytesPbReserve?: Uint8Array | undefined;
}

export interface OnlineImage {
  /** 图片Guid */
  guid?:
    | Uint8Array
    | undefined;
  /** 图片的 文件系统路径 */
  filePath?:
    | Uint8Array
    | undefined;
  /** 旧版本数据,server 收到后直接使用 */
  oldVerSendFile?: Uint8Array | undefined;
}

export interface NotOnlineImage {
  /** 图片的 文件系统路径, 实际为: "/文件名" */
  filePath?:
    | Uint8Array
    | undefined;
  /** 表示文件长度 */
  fileLen?:
    | number
    | undefined;
  /** 表示文件下载路径, uuid */
  downloadPath?:
    | Uint8Array
    | undefined;
  /** 旧版本数据,server 收到后直接使用 */
  oldVerSendFile?:
    | Uint8Array
    | undefined;
  /** 图片格式：BMP=1,JPG=2,GIF=3,其他=0，静态图定义从0x1000开始，动态图定义从0x2000开始 */
  imgType?:
    | number
    | undefined;
  /** 缩略图 */
  previewsImage?:
    | Uint8Array
    | undefined;
  /** 原图MD5 */
  picMd5?:
    | Uint8Array
    | undefined;
  /** 图片高度 */
  picHeight?:
    | number
    | undefined;
  /** 图片宽度 */
  picWidth?:
    | number
    | undefined;
  /** Res ID */
  resId?:
    | Uint8Array
    | undefined;
  /** 图片Flag */
  flag?:
    | Uint8Array
    | undefined;
  /** 缩略图下载地址 */
  strThumbUrl?:
    | string
    | undefined;
  /** 是否为原图 */
  original?:
    | number
    | undefined;
  /** 大图下载地址 */
  strBigUrl?:
    | string
    | undefined;
  /** 原图下载地址 */
  strOrigUrl?:
    | string
    | undefined;
  /** 业务类型，1表示涂鸦 2->拍照 3->相册 4->转发 5->自定义表情 6->PAP涂鸦图片 */
  bizType?:
    | number
    | undefined;
  /** 0-fail; 1-succ */
  result?:
    | number
    | undefined;
  /** 索引 */
  index?:
    | number
    | undefined;
  /** 运营表情信息Buffer */
  opFaceBuf?:
    | Uint8Array
    | undefined;
  /** （内部使用）pic_md5来自old_ver_send_file(true)，还是Hummer ATTR 27(false) */
  oldPicMd5?:
    | boolean
    | undefined;
  /** 图片对应缩略图宽度 */
  uint32ThumbWidth?:
    | number
    | undefined;
  /** 图片对应缩略图高度 */
  uint32ThumbHeight?:
    | number
    | undefined;
  /** 仅客户端使用，后台进行管理(svenyang) */
  uint32FileId?:
    | number
    | undefined;
  /** 文件最小显示长度 */
  uint32ShowLen?:
    | number
    | undefined;
  /** 文件最小下载长度 */
  uint32DownloadLen?:
    | number
    | undefined;
  /** 400缩略图下载地址 */
  str400Url?:
    | string
    | undefined;
  /** 400缩略图的宽度 */
  uint32400Width?:
    | number
    | undefined;
  /** 400缩略图的高度 */
  uint32400Height?:
    | number
    | undefined;
  /** 离线图片的扩展结构,参见hummer_resv_6.proto */
  bytesPbReserve?: Uint8Array | undefined;
}

export interface TransElem {
  /** 要透传的 elem 类型（取值范围1-255） */
  elemType?:
    | number
    | undefined;
  /** 要透传的 elem 值 */
  elemValue?: Uint8Array | undefined;
}

/** C2C离线文件信息，对应老协议0xa9 */
export interface NotOnlineFile {
  /** 文件类型，取值参照C2C_FILE_TYPE定义, 接收方回复时复用作为action 2--拒绝 1--成功 */
  uint32FileType?: number | undefined;
  bytesSig?:
    | Uint8Array
    | undefined;
  /** 文件uuid */
  bytesFileUuid?:
    | Uint8Array
    | undefined;
  /** 文件前10M MD5 */
  bytesFileMd5?:
    | Uint8Array
    | undefined;
  /** 文件名 */
  bytesFileName?:
    | Uint8Array
    | undefined;
  /** 文件长度 */
  uint64FileSize?:
    | number
    | undefined;
  /** 文件NOTE,  接收方回复时复用作为buff */
  bytesNote?:
    | Uint8Array
    | undefined;
  /** 预留字段，兼容老协议 */
  uint32Reserved?:
    | number
    | undefined;
  /** 1是发送notify 2是接收方回复 3是管家 4是微云 */
  uint32Subcmd?: number | undefined;
  uint32MicroCloud?:
    | number
    | undefined;
  /** 文件下载地址 */
  rptBytesFileUrls: Uint8Array[];
  /** 是否需要申请下载地址  0:到架平申请  1:到cos申请  2:不需要申请，直接拿url下载 */
  uint32DownloadFlag?:
    | number
    | undefined;
  /** 再次扩展协议字段 */
  uint32DangerEvel?:
    | number
    | undefined;
  /** >>剩余保存时间 */
  uint32LifeTime?:
    | number
    | undefined;
  /** >>上传时间 */
  uint32UploadTime?:
    | number
    | undefined;
  /** >>支持预览的文件后缀类型,0表示不支持预览,支持的类型从1开始递增,目前依次为doc,docx,xls,xlsx,ppt,pptx,rtf,pdf,bmp,jpg,png,gif */
  uint32AbsFileType?:
    | number
    | undefined;
  /** >>客户端类型，申请上传时ReqBody中所填uint32_client_type */
  uint32ClientType?:
    | number
    | undefined;
  /** >>到期时间 */
  uint32ExpireTime?:
    | number
    | undefined;
  /** 消息扩展的pb结构，参见hummer_resv_notonlinefile.proto */
  bytesPbReserve?: Uint8Array | undefined;
  strFileidcrcMedia?: string | undefined;
}

/** 语音对讲，视频信息，对应老协议0xD0 */
export interface Ptt {
  /** 文件类型，0x4：语音，0x8视频留言 */
  uint32FileType?:
    | number
    | undefined;
  /** 发送方UIN */
  uint64SrcUin?:
    | number
    | undefined;
  /** 服务器文件索引【UUID】 */
  bytesFileUuid?:
    | Uint8Array
    | undefined;
  /** 文件MD5 / 文件验证码 */
  bytesFileMd5?:
    | Uint8Array
    | undefined;
  /** 文件名 */
  bytesFileName?:
    | Uint8Array
    | undefined;
  /** 文件长度 */
  uint32FileSize?:
    | number
    | undefined;
  /** 特别说明： */
  bytesReserve?:
    | Uint8Array
    | undefined;
  /**
   * 1. 对于C2C消息，用于存放扩展信息（对应0xd0的resv）
   * 2. 对于群和讨论组来说，用于存放低版本的兼容信息，由server填写，客户端不能填写！
   */
  uint32FileId?:
    | number
    | undefined;
  /** 取图片的server ip */
  uint32ServerIp?:
    | number
    | undefined;
  /** 取图片的server port */
  uint32ServerPort?:
    | number
    | undefined;
  /** 图片文件可用标记（群PTT） */
  boolValid?:
    | boolean
    | undefined;
  /** 文件验证码（群PTT） */
  bytesSignature?:
    | Uint8Array
    | undefined;
  /** 快捷键（群PTT） */
  bytesShortcut?:
    | Uint8Array
    | undefined;
  /** c2c ptt fileKey */
  bytesFileKey?:
    | Uint8Array
    | undefined;
  /** 变声语音的索引号 */
  uint32MagicPttIndex?:
    | number
    | undefined;
  /** 语音自动播放开关 */
  uint32VoiceSwitch?:
    | number
    | undefined;
  /** ptt的完整url下载地址 */
  bytesPttUrl?:
    | Uint8Array
    | undefined;
  /** 群ptt file key */
  bytesGroupFileKey?:
    | Uint8Array
    | undefined;
  /** 当前语音时长 */
  uint32Time?:
    | number
    | undefined;
  /** 语音下载url参数 */
  bytesDownPara?:
    | Uint8Array
    | undefined;
  /** 当前语音格式，0-amr，1-silk */
  uint32Format?:
    | number
    | undefined;
  /** 仅用于群和讨论组消息，存放和C2C-ptt一样的扩展信息，参见上面 bytes_reserve */
  bytesPbReserve?:
    | Uint8Array
    | undefined;
  /** ptt下载地址列表 */
  rptBytesPttUrls: Uint8Array[];
  /** 是否需要申请下载地址  0:到架平申请  1:到cos申请  2:不需要申请，直接拿url下载 */
  uint32DownloadFlag?: number | undefined;
}

/** 视频文件 */
export interface VideoFile {
  /** 服务器文件索引【UUID】 */
  bytesFileUuid?:
    | Uint8Array
    | undefined;
  /** 文件MD5 / 文件验证码 */
  bytesFileMd5?:
    | Uint8Array
    | undefined;
  /** 文件名 */
  bytesFileName?:
    | Uint8Array
    | undefined;
  /** 文件格式,1-avi,2-mp4,3-wmv,4-mkv,5-rmvb,6-rm,7-afs,8-mov,9-mod,10-ts,11-mts */
  uint32FileFormat?:
    | number
    | undefined;
  /** 文件时长(秒) */
  uint32FileTime?:
    | number
    | undefined;
  /** 文件长度 */
  uint32FileSize?:
    | number
    | undefined;
  /** 视频对应缩略图宽度 */
  uint32ThumbWidth?:
    | number
    | undefined;
  /** 视频对应缩略图高度 */
  uint32ThumbHeight?:
    | number
    | undefined;
  /** 缩略图文件MD5 / 文件验证码 */
  bytesThumbFileMd5?:
    | Uint8Array
    | undefined;
  /** camera:拍摄来源，album:相册来源 */
  bytesSource?:
    | Uint8Array
    | undefined;
  /** 缩略图大小 */
  uint32ThumbFileSize?:
    | number
    | undefined;
  /** 业务类型,0=手Q短视频, 1=手Q小视频 */
  uint32BusiType?:
    | number
    | undefined;
  /** 转发用：C2C-0，群-1，讨论组-2，临时会话-3，非转发填（-1） */
  uint32FromChatType?:
    | number
    | undefined;
  /** 转发用：C2C-0，群-1，讨论组-2，临时会话-3，非转发填（-1） */
  uint32ToChatType?:
    | number
    | undefined;
  /** 标识mp4视频格式是否支持边下边播 */
  boolSupportProgressive?:
    | boolean
    | undefined;
  /** 视频对应文件分辨率宽度 */
  uint32FileWidth?:
    | number
    | undefined;
  /** 视频对应文件分辨率高度 */
  uint32FileHeight?:
    | number
    | undefined;
  /** 子业务类型,用于区分同个uint32_busi_type的不同子业务 0：普通视频，1：祝福视屏，2：animoji视屏 */
  uint32SubBusiType?:
    | number
    | undefined;
  /** 视频属性值：0-普通视频，1-热门视频（一拖三视频） */
  uint32VideoAttr?:
    | number
    | undefined;
  /** 视频对应缩略图下载地址列表 */
  rptBytesThumbFileUrls: Uint8Array[];
  /** 视频对应文件下载地址列表 */
  rptBytesVideoFileUrls: Uint8Array[];
  /** 视频对应缩略图是否需要申请下载地址  0:到架平申请  1:到cos申请  2:不需要申请，直接拿url下载 */
  uint32ThumbDownloadFlag?:
    | number
    | undefined;
  /** 视频对应文件是否需要申请下载地址  0:到架平申请  1:到cos申请  2:不需要申请，直接拿url下载 */
  uint32VideoDownloadFlag?:
    | number
    | undefined;
  /** VideoFile的扩展结构,参见hummer_resv_video_file.proto */
  bytesPbReserve?: Uint8Array | undefined;
}

export interface ElemFlags {
  /** 业务控制flags1 */
  bytesFlags1?:
    | Uint8Array
    | undefined;
  /** 业务控制flags2 */
  bytesBusinessData?: Uint8Array | undefined;
}

export interface ElemFlags2 {
  /** 超级会员的气泡ID */
  uint32ColorTextId?:
    | number
    | undefined;
  /** 公共帐号qwMsgId */
  uint64MsgId?:
    | number
    | undefined;
  /** 私聊消息的连接 ID */
  uint32WhisperSessionId?:
    | number
    | undefined;
  /** ptt转换为标记 */
  uint32PttChangeBit?:
    | number
    | undefined;
  /** 长语音发送方的VIP/SVIP状态 */
  uint32VipStatus?:
    | number
    | undefined;
  /** 兼容处理ID */
  uint32CompatibleId?:
    | number
    | undefined;
  /** 对指定终端下发群消息漫游 */
  rptInsts: ElemFlags2_Inst[];
  /** 相同的文本消息重复了多少次 */
  uint32MsgRptCnt?:
    | number
    | undefined;
  /** 消息来源的wAppId + dwInstId */
  srcInst?:
    | ElemFlags2_Inst
    | undefined;
  /** 用户经度 */
  uint32Longtitude?:
    | number
    | undefined;
  /** 用户纬度 */
  uint32Latitude?:
    | number
    | undefined;
  /** 用户个性字体ID */
  uint32CustomFont?: number | undefined;
  pcSupportDef?:
    | PcSupportDef
    | undefined;
  /** crm特殊消息标志 */
  uint32CrmFlags?: number | undefined;
}

export interface ElemFlags2_Inst {
  uint32AppId?: number | undefined;
  uint32InstId?: number | undefined;
}

export interface PcSupportDef {
  uint32PcPtlBegin?: number | undefined;
  uint32PcPtlEnd?: number | undefined;
  uint32MacPtlBegin?: number | undefined;
  uint32MacPtlEnd?: number | undefined;
  rptPtlsSupport: number[];
  rptPtlsNotSupport: number[];
}

export interface ExtraInfo {
  /** 发送者的昵称 */
  bytesNick?:
    | Uint8Array
    | undefined;
  /** 发送者的群名片 */
  bytesGroupCard?:
    | Uint8Array
    | undefined;
  /** 群成员等级数值 */
  uint32Level?:
    | number
    | undefined;
  /** 群flag，具体含义请参考hummer协议文档 */
  uint32Flags?:
    | number
    | undefined;
  /** 接收者的群消息屏蔽位 */
  uint32GroupMask?:
    | number
    | undefined;
  /** 群或讨论组消息尾巴ID */
  uint32MsgTailId?:
    | number
    | undefined;
  /** 发送者的群成员专属头衔，UTF8编码 */
  bytesSenderTitle?:
    | Uint8Array
    | undefined;
  /** APNs tips content --- utf8 */
  bytesApnsTips?:
    | Uint8Array
    | undefined;
  /** 红包口令消息标识红包发送者 */
  uint64Uin?:
    | number
    | undefined;
  /** 红包口令消息状态标记位，0. 或者没有这个字段，表示普通消息 */
  uint32MsgStateFlag?:
    | number
    | undefined;
  /**
   * 1. 红包未抢完，用户发口令消息；
   * 2. 红包已经抢完，用户发口令消息；
   * 3. 红包已经过期，用户发口令消息；
   * 4. 其他异常的红包口令消息
   */
  uint32ApnsSoundType?:
    | number
    | undefined;
  /** 新群flag */
  uint32NewGroupFlag?: number | undefined;
}

export interface FunFace {
  /** 以下字段互斥，只能一个有效 */
  msgTurntable?: FunFace_Turntable | undefined;
  msgBomb?: FunFace_Bomb | undefined;
}

export interface FunFace_Turntable {
  rptUint64UinList: number[];
  uint64HitUin?:
    | number
    | undefined;
  /** 发送时后台填写，客户端无需填写 */
  strHitUinNick?: string | undefined;
}

export interface FunFace_Bomb {
  boolBurst?: boolean | undefined;
}

export interface SecretFileMsg {
  /** scretfile标识。上报scretfile状态时用这个标识。 */
  bytesFileKey?:
    | Uint8Array
    | undefined;
  /** 发送方号码 */
  uint64FromUin?:
    | number
    | undefined;
  /** 接收方号码 */
  uint64ToUin?:
    | number
    | undefined;
  /** 发送方发送图片时，填0； */
  uint32Status?:
    | number
    | undefined;
  /** 图片生存时间, 单位为秒 */
  uint32Ttl?:
    | number
    | undefined;
  /** snapchat类型，1：图片,2：ptt, 3：video */
  uint32Type?:
    | number
    | undefined;
  /** 加密的头部长度 */
  uint32EncryptPreheadLength?:
    | number
    | undefined;
  /** 加密类型 */
  uint32EncryptType?:
    | number
    | undefined;
  /** 加密的key */
  bytesEncryptKey?:
    | Uint8Array
    | undefined;
  /** 可以查看的次数 */
  uint32ReadTimes?:
    | number
    | undefined;
  /** 剩余时长，单位秒 */
  uint32LeftTime?:
    | number
    | undefined;
  /** 离线图片 */
  notOnlineImage?:
    | NotOnlineImage
    | undefined;
  /** 业务数据(存放气泡id) */
  elemFlags2?:
    | ElemFlags2
    | undefined;
  /** 闪照类型，参考[OperType] */
  uint32Opertype?:
    | number
    | undefined;
  /** 发送方手机号码 */
  strFromphonenum?: string | undefined;
}

export enum SecretFileMsg_OperType {
  /** TYPE_C2C - 好友琳?        TYPE_CONTACTS = 1;//通讯录临时会话 */
  TYPE_C2C = 0,
  /** TYPE_GROUP - 群临时会话 */
  TYPE_GROUP = 2,
  /** TYPE_NEARBA - 附近人临时会话 */
  TYPE_NEARBA = 3,
  /** TYPE_DISCU - 讨论组临时会话 */
  TYPE_DISCU = 4,
  /** TYPE_WPA - wpa临时会话 */
  TYPE_WPA = 5,
  UNRECOGNIZED = -1,
}

export function secretFileMsg_OperTypeFromJSON(object: any): SecretFileMsg_OperType {
  switch (object) {
    case 0:
    case "TYPE_C2C":
      return SecretFileMsg_OperType.TYPE_C2C;
    case 2:
    case "TYPE_GROUP":
      return SecretFileMsg_OperType.TYPE_GROUP;
    case 3:
    case "TYPE_NEARBA":
      return SecretFileMsg_OperType.TYPE_NEARBA;
    case 4:
    case "TYPE_DISCU":
      return SecretFileMsg_OperType.TYPE_DISCU;
    case 5:
    case "TYPE_WPA":
      return SecretFileMsg_OperType.TYPE_WPA;
    case -1:
    case "UNRECOGNIZED":
    default:
      return SecretFileMsg_OperType.UNRECOGNIZED;
  }
}

export function secretFileMsg_OperTypeToJSON(object: SecretFileMsg_OperType): string {
  switch (object) {
    case SecretFileMsg_OperType.TYPE_C2C:
      return "TYPE_C2C";
    case SecretFileMsg_OperType.TYPE_GROUP:
      return "TYPE_GROUP";
    case SecretFileMsg_OperType.TYPE_NEARBA:
      return "TYPE_NEARBA";
    case SecretFileMsg_OperType.TYPE_DISCU:
      return "TYPE_DISCU";
    case SecretFileMsg_OperType.TYPE_WPA:
      return "TYPE_WPA";
    case SecretFileMsg_OperType.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export interface RichMsg {
  /** Xml模板一 */
  bytesTemplate1?:
    | Uint8Array
    | undefined;
  /** 对应的业务标识 */
  uint32ServiceId?:
    | number
    | undefined;
  /** 长消息resid */
  bytesMsgResid?:
    | Uint8Array
    | undefined;
  /** 需要删除的消息 rand 值 */
  uint32Rand?:
    | number
    | undefined;
  /** 需要删除的消息 seq */
  uint32Seq?:
    | number
    | undefined;
  /** bit 0:消息是否来自UrlCache; bit 1:是否包含video标签; bit 2:来自公众帐号的video结构化消息; bit 3:消息在urlencode模块从url转成richmsg */
  uint32Flags?: number | undefined;
}

export interface GroupFile {
  /** 文件名 */
  bytesFilename?:
    | Uint8Array
    | undefined;
  /** FileSize */
  uint64FileSize?:
    | number
    | undefined;
  /** 文件ID，包含父目录key */
  bytesFileId?:
    | Uint8Array
    | undefined;
  /** 文件批ID */
  bytesBatchId?:
    | Uint8Array
    | undefined;
  /** FileKey */
  bytesFileKey?:
    | Uint8Array
    | undefined;
  /** 文件附加标志 */
  bytesMark?:
    | Uint8Array
    | undefined;
  /** 发送序列号 */
  uint64Sequence?:
    | number
    | undefined;
  /** 文件批每项ID，GUID */
  bytesBatchItemId?:
    | Uint8Array
    | undefined;
  /** feed消息时间 */
  uint32FeedMsgTime?:
    | number
    | undefined;
  /** 参见 hum_21_reserv.proto */
  bytesPbReserve?: Uint8Array | undefined;
}

export interface MarketTrans {
  /** cFlag */
  int32Flag?:
    | number
    | undefined;
  /** xml buffer */
  bytesXml?:
    | Uint8Array
    | undefined;
  /** 长消息resid */
  bytesMsgResid?:
    | Uint8Array
    | undefined;
  /** 手q客户端对应能力，对于支持的客户端下发，不支持的不下发 */
  uint32Ability?:
    | number
    | undefined;
  /** 下发此消息的最低版本能力 */
  uint32MinAbility?: number | undefined;
}

export interface PubGroup {
  /** 游客昵称 */
  bytesNickname?:
    | Uint8Array
    | undefined;
  /** 性别 */
  uint32Gender?:
    | number
    | undefined;
  /** 年龄 */
  uint32Age?:
    | number
    | undefined;
  /** 和群位置之间的距离 */
  uint32Distance?: number | undefined;
}

export interface MsgBodySubtype4 {
  msgNotOnlineFile?: NotOnlineFile | undefined;
  uint32MsgTime?: number | undefined;
}

/** 临时会话ptt协议 */
export interface TmpPtt {
  /** 文件类型，0x4：语音，0x8视频留言 */
  uint32FileType?:
    | number
    | undefined;
  /** 服务器文件索引【UUID】 */
  bytesFileUuid?:
    | Uint8Array
    | undefined;
  /** 文件MD5 / 文件验证码 */
  bytesFileMd5?:
    | Uint8Array
    | undefined;
  /** 文件名 */
  bytesFileName?:
    | Uint8Array
    | undefined;
  /** 文件长度 */
  uint32FileSize?:
    | number
    | undefined;
  /** 语音时长，单位秒 */
  uint64PttTimes?:
    | number
    | undefined;
  /** 发送方身份级别，0-普通用户，1-vip;2-svip */
  uint32UserType?:
    | number
    | undefined;
  /** 语音转文字标志，1：支持语音转文字 */
  uint32PtttransFlag?:
    | number
    | undefined;
  /** 公众号-临时ptt-3, 公众号-永久ptt-4 */
  uint32BusiType?:
    | number
    | undefined;
  /** 公众号消息msgid */
  uint64MsgId?:
    | number
    | undefined;
  /** 自定义pb内容 */
  bytesPbReserve?:
    | Uint8Array
    | undefined;
  /** add by dellwang, 后台使用，客户端不能用 */
  pttEncodeData?: Uint8Array | undefined;
}

export interface ShakeWindow {
  /** 填缺省值0 */
  uint32Type?:
    | number
    | undefined;
  /** 预留字段，不填 */
  uint32Reserve?: number | undefined;
  uint64Uin?: number | undefined;
}

/** 公共帐号 */
export interface PubAccount {
  /** cFlag + sXml */
  bytesBuf?:
    | Uint8Array
    | undefined;
  /** 群与公众号联动，如果该消息是订阅号消息，需要传订阅号uin来和其他结构化消息区分 */
  uint64PubAccountUin?: number | undefined;
}

/** tips提示信息 */
export interface TipsInfo {
  /** tips提示信息 */
  text?: string | undefined;
}

export interface AnonymousGroupMsg {
  /** 群匿名消息 flag > 0为匿名消息 flag : 1 他人的消息 falg : 2 自己发送的消息 */
  uint32Flags?:
    | number
    | undefined;
  /** 发送者的匿名ID */
  strAnonId?:
    | Uint8Array
    | undefined;
  /** 发送者的群匿名昵称 */
  strAnonNick?:
    | Uint8Array
    | undefined;
  /** 群匿名群头像索引 */
  uint32HeadPortrait?:
    | number
    | undefined;
  /** 群匿名昵称过期时间 */
  uint32ExpireTime?:
    | number
    | undefined;
  /** 发送者的匿名气泡ID */
  uint32BubbleId?:
    | number
    | undefined;
  /** 群匿名消息头衔背景颜色，格式#72CCE6 */
  strRankColor?: Uint8Array | undefined;
}

export interface QQLiveOld {
  /** 子命令号 */
  uint32SubCmd?:
    | number
    | undefined;
  /** 显示的文字，UTF8编码 */
  strShowText?:
    | Uint8Array
    | undefined;
  /** 参数文字，UTF8编码 */
  strParam?:
    | Uint8Array
    | undefined;
  /** 介绍文字，UTF8编码，仅部分sub cmd下才有 */
  strIntroduce?: Uint8Array | undefined;
}

/** QQ钱包消息 */
export interface QQWalletMsg {
  /** AIO消息 */
  aioBody?: QQWalletAioBody | undefined;
}

/** QQ钱包AIO报文体 */
export interface QQWalletAioBody {
  /** 发送者UIN */
  uint64Senduin?:
    | number
    | undefined;
  /** 发送方AIO渲染内容.转账的发送方Elem */
  sender?:
    | QQWalletAioElem
    | undefined;
  /** 接收方AIO渲染内容,转账的接收方ELem，红包和AA收款的发送方和接收方都是这个Elem */
  receiver?:
    | QQWalletAioElem
    | undefined;
  /** Channal渠道号 */
  sint32Channelid?:
    | number
    | undefined;
  /** 消息模板id号 */
  sint32Templateid?:
    | number
    | undefined;
  /** 消息补发标志(0:首发， 1:补发) */
  uint32Resend?:
    | number
    | undefined;
  /** 消息优先级，取值为>=3或2或1；>=3时，优先级顺序 钱包消息>结构化消息>纯文本消息；为2时，优先级顺序 结构化消息>钱包消息>纯文本消息；为1时，优先级顺序 结构化消息>纯文本消息>钱包消息； */
  uint32MsgPriority?:
    | number
    | undefined;
  /** 5.9.5红包改版 */
  sint32Redtype?:
    | number
    | undefined;
  /** 红包ID号, --PC8.7版本支持QQ红包，不下发给PC */
  bytesBillno?:
    | Uint8Array
    | undefined;
  /** 签名， 财付通后台通过增值后台透传个字段，然后终端传给财付通sdk --PC8.7版本支持QQ红包，不下发给PC */
  bytesAuthkey?:
    | Uint8Array
    | undefined;
  /** 0：单对单 1：群发 2：讨论组 3：群临时会话 4：讨论组临时会话 5：热聊群 6：附近的人临时会话 10: 部落临时会话 */
  sint32Sessiontype?:
    | number
    | undefined;
  /** 取值含义 */
  sint32Msgtype?:
    | number
    | undefined;
  /**
   * 1~1000：客户端定义的消息类型（如果该类型消息客户端不能识别，则只保留与该消息一起下发的文本消息），
   *    其中：
   *       1 表示转账和自动代付消息
   *       2 表示普通红包消息
   *       3 表示拼手气红包消息
   *       4 表示普通主题红包消息
   *       5 表示拼手气主题红包消息
   *       6 表示口令红包消息
   *       7 表示普通定向红包消息
   *       8 表示拼手气定向红包消息
   *       9 表示代付
   *       10 表示代付结果
   *       11 表示>3人的普通定向红包消息
   *       12 表示>3人的拼手气定向红包消息
   *       13 表示群讨论组语音口令红包消息
   *       14 表示表情红包消息
   *       15 表示C2C语音口令红包消息
   *       16 AA收款,7.5.0
   * 1001~2000：老版本红包体，用于其它业务扩展；
   * 2001~3000：新版本红包，用于其它业务扩展；
   *       2001 表示会员个性化红包消息
   *       2002 表示企点红包消息
   * 其它：抛弃该消息。
   */
  sint32Envelopeid?:
    | number
    | undefined;
  /** 当msgtype==2001,7,8,11,12时有效，用户自定义姓氏 */
  bytesName?:
    | Uint8Array
    | undefined;
  /** 当msgtype==2001,7,8,11,12时有效，1-文字红包 2-非文字红包 */
  sint32Conftype?:
    | number
    | undefined;
  /** 当msgtype==4或5时(0: 来自聊天窗口主题红包, 1: 来自群发小助手主题红包) */
  sint32MsgFrom?:
    | number
    | undefined;
  /** PC8.7版本支持QQ红包，下发给PC侧，手Q侧不下发，存储的是PC侧authkey,打击提示文本等字段pb序列化后的串,具体结构由PC侧终端和财付通侧约定 */
  bytesPcBody?:
    | Uint8Array
    | undefined;
  /** 唯一标识PC和手Q上收到的红包，用于口令红包消息折叠 */
  stringIndex?:
    | Uint8Array
    | undefined;
  /** 透传给新版财付通SDK , 1024 表示定向红包 */
  uint32Redchannel?:
    | number
    | undefined;
  /** sint32_redchannel==1024时拆定向红包用户uin，最多三人，群和讨论组有效 */
  uint64GrapUin: number[];
  /** 业务控制的扩展结构, 参见qqwalletaio_resv.proto */
  bytesPbReserve?: Uint8Array | undefined;
}

/** QQ钱包AIO消息内容 */
export interface QQWalletAioElem {
  /** 背景色null|R|G|B, 8bit */
  uint32Background?:
    | number
    | undefined;
  /** 图标ID */
  uint32Icon?:
    | number
    | undefined;
  /** 主标题 == 祝福语，当为口令红包时,也作为口令 */
  bytesTitle?:
    | Uint8Array
    | undefined;
  /** 副标题 */
  bytesSubtitle?:
    | Uint8Array
    | undefined;
  /** 内容 */
  bytesContent?:
    | Uint8Array
    | undefined;
  /** 链接地址 */
  bytesLinkurl?:
    | Uint8Array
    | undefined;
  /** 小黑条（为空，表示不显示） */
  bytesBlackstripe?:
    | Uint8Array
    | undefined;
  /** 对话框窗口提示语 */
  bytesNotice?:
    | Uint8Array
    | undefined;
  /** 主标题颜色null|R|G|B, 8bit */
  uint32TitleColor?:
    | number
    | undefined;
  /** 副标题颜色null|R|G|B, 8bit */
  uint32SubtitleColor?:
    | number
    | undefined;
  /** 跳转优先级列表，目前跳转类型有："1" - url跳转; "2" - mqqapi外部跳转; "3" - 钱包自定义跳转； */
  bytesActionsPriority?:
    | Uint8Array
    | undefined;
  /** 该参数格式为： 跳转类型1|跳转类型2|跳转类型3  的字符串，使用"|"进行分隔。示例："3|2|1",优先级顺序 自定义跳转 > 外部跳转>url跳转，排列在前面的类型优先级最高，依次优先级降低 */
  bytesJumpUrl?:
    | Uint8Array
    | undefined;
  /** 钱包ios自定义跳转地址，格式“类名[?参数1=值1][&参数2=值2][&参数3=值3]”；如“com.mobileqq.app.MyActivity?p1=1&p2=conten”，“com.mobileqq.app.MyActivity” */
  bytesNativeIos?:
    | Uint8Array
    | undefined;
  /** 钱包android自定义跳转地址，格式“类名[?参数1=值1][&参数2=值2][&参数3=值3]”；如“com.mobileqq.app.MyActivity?p1=1&p2=conten”，“com.mobileqq.app.MyActivity” */
  bytesNativeAndroid?:
    | Uint8Array
    | undefined;
  /** icon链接地址; 图标的显示逻辑优先级 非空时 bytes_iconurl > uint32_icon */
  bytesIconurl?:
    | Uint8Array
    | undefined;
  /** 底部留言文字颜色null|R|G|B, 8bit */
  uint32ContentColor?:
    | number
    | undefined;
  /** 底部背景颜色null|R|G|B, 8bit */
  uint32ContentBgcolor?:
    | number
    | undefined;
  /** 新版红包aio主题背景图片url; 在非空情况下，背景图片url>默认背景 */
  bytesAioImageLeft?:
    | Uint8Array
    | undefined;
  /** 新版红包aio主题背景图片url; 在非空情况下，背景图片url>默认背景 */
  bytesAioImageRight?:
    | Uint8Array
    | undefined;
  /** 新版红包cft主题红包背景图片url; 在非空情况下，背景图片url>默认背景 */
  bytesCftImage?:
    | Uint8Array
    | undefined;
  /** 业务控制的扩展结构, 参见qqwalletaio_resv.proto */
  bytesPbReserve?: Uint8Array | undefined;
}

/** 生活服务帐号 */
export interface LifeOnlineAccount {
  /** 消息唯一ID，用于更新或者取消预送达消息 */
  uint64UniqueId?:
    | number
    | undefined;
  /** 消息操作，0：插入定时消息   1：修改定时消息时间   9：删除定时消息 */
  uint32Op?:
    | number
    | undefined;
  /** 预送达触发时间 */
  uint32ShowTime?:
    | number
    | undefined;
  /** 生活服务号消息是否需要终端日志上报 */
  uint32Report?:
    | number
    | undefined;
  /** 生活服务号消息是否需要终端确认 */
  uint32Ack?:
    | number
    | undefined;
  /** 生活服务号能力位图 */
  uint64Bitmap?:
    | number
    | undefined;
  /** 曝光上报广点通的json数据，终端透传到后台 */
  gdtImpData?:
    | Uint8Array
    | undefined;
  /** 点击上报广点通的json数据，终端透传到后台 */
  gdtCliData?:
    | Uint8Array
    | undefined;
  /** 终端透传字段 */
  viewId?: Uint8Array | undefined;
}

export interface CrmElem {
  /** crm自定义buf */
  crmBuf?:
    | Uint8Array
    | undefined;
  /** 长消息resid */
  bytesMsgResid?:
    | Uint8Array
    | undefined;
  /** 标识来自企点的消息 */
  uint32QidianFlag?:
    | number
    | undefined;
  /** 是否推送，1 - 推送，0 - 不推送，不填默认推送 */
  uint32PushFlag?:
    | number
    | undefined;
  /** 是否计数，1 - 计数，0 - 不计数，不填默认计数 */
  uint32CountFlag?: number | undefined;
}

export interface ConferenceTipsInfo {
  /** 参考ECONF_SESSION_TYPE */
  uint32SessionType?:
    | number
    | undefined;
  /** 所属uin */
  uint64SessionUin?:
    | number
    | undefined;
  /** 提示信息 */
  strText?: string | undefined;
}

export enum ConferenceTipsInfo_econfSessionType {
  /** ECONFST_NONE - 默认值，无意义 */
  ECONFST_NONE = 0,
  /** ECONFST_DISCUSS_AV - 基于讨论组的会议 */
  ECONFST_DISCUSS_AV = 1,
  /** ECONFST_BUDDY_AV - 基于双人的会议 */
  ECONFST_BUDDY_AV = 2,
  UNRECOGNIZED = -1,
}

export function conferenceTipsInfo_econfSessionTypeFromJSON(object: any): ConferenceTipsInfo_econfSessionType {
  switch (object) {
    case 0:
    case "ECONFST_NONE":
      return ConferenceTipsInfo_econfSessionType.ECONFST_NONE;
    case 1:
    case "ECONFST_DISCUSS_AV":
      return ConferenceTipsInfo_econfSessionType.ECONFST_DISCUSS_AV;
    case 2:
    case "ECONFST_BUDDY_AV":
      return ConferenceTipsInfo_econfSessionType.ECONFST_BUDDY_AV;
    case -1:
    case "UNRECOGNIZED":
    default:
      return ConferenceTipsInfo_econfSessionType.UNRECOGNIZED;
  }
}

export function conferenceTipsInfo_econfSessionTypeToJSON(object: ConferenceTipsInfo_econfSessionType): string {
  switch (object) {
    case ConferenceTipsInfo_econfSessionType.ECONFST_NONE:
      return "ECONFST_NONE";
    case ConferenceTipsInfo_econfSessionType.ECONFST_DISCUSS_AV:
      return "ECONFST_DISCUSS_AV";
    case ConferenceTipsInfo_econfSessionType.ECONFST_BUDDY_AV:
      return "ECONFST_BUDDY_AV";
    case ConferenceTipsInfo_econfSessionType.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export interface RedBagInfo {
  /** 1为企业红包结构化消息 */
  redbagType?: number | undefined;
}

export interface LowVersionTips {
  /** 所属业务类型 */
  uint32BusinessId?:
    | number
    | undefined;
  /** 所属聊天窗口，参考EChatType */
  uint32SessionType?:
    | number
    | undefined;
  /** 所属uin */
  uint64SessionUin?:
    | number
    | undefined;
  /** 所属发送者uin */
  uint64SenderUin?:
    | number
    | undefined;
  /** 提示信息 */
  strText?: string | undefined;
}

export enum LowVersionTips_EBusinessID {
  /** EBusinessID_ConfScheduleMsg - 会议预约后发出消息 */
  EBusinessID_ConfScheduleMsg = 1,
  /** EBusinessID_DingDongMsg - 使用叮咚后发出消息 */
  EBusinessID_DingDongMsg = 2,
  UNRECOGNIZED = -1,
}

export function lowVersionTips_EBusinessIDFromJSON(object: any): LowVersionTips_EBusinessID {
  switch (object) {
    case 1:
    case "EBusinessID_ConfScheduleMsg":
      return LowVersionTips_EBusinessID.EBusinessID_ConfScheduleMsg;
    case 2:
    case "EBusinessID_DingDongMsg":
      return LowVersionTips_EBusinessID.EBusinessID_DingDongMsg;
    case -1:
    case "UNRECOGNIZED":
    default:
      return LowVersionTips_EBusinessID.UNRECOGNIZED;
  }
}

export function lowVersionTips_EBusinessIDToJSON(object: LowVersionTips_EBusinessID): string {
  switch (object) {
    case LowVersionTips_EBusinessID.EBusinessID_ConfScheduleMsg:
      return "EBusinessID_ConfScheduleMsg";
    case LowVersionTips_EBusinessID.EBusinessID_DingDongMsg:
      return "EBusinessID_DingDongMsg";
    case LowVersionTips_EBusinessID.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export enum LowVersionTips_EChatType {
  /** CF_UnknownChatType - 未知聊天类型 */
  CF_UnknownChatType = -1,
  /** CF_BuddyChatType - 好友联系人的聊天类型 */
  CF_BuddyChatType = 0,
  /** CF_GroupChatType - 群组的聊天类型 */
  CF_GroupChatType = 1,
  /** CF_TempChatType - 临时会话的聊天类型 */
  CF_TempChatType = 2,
  /** CF_DiscussChatType - 讨论组的聊天类型 */
  CF_DiscussChatType = 3,
}

export function lowVersionTips_EChatTypeFromJSON(object: any): LowVersionTips_EChatType {
  switch (object) {
    case -1:
    case "CF_UnknownChatType":
      return LowVersionTips_EChatType.CF_UnknownChatType;
    case 0:
    case "CF_BuddyChatType":
      return LowVersionTips_EChatType.CF_BuddyChatType;
    case 1:
    case "CF_GroupChatType":
      return LowVersionTips_EChatType.CF_GroupChatType;
    case 2:
    case "CF_TempChatType":
      return LowVersionTips_EChatType.CF_TempChatType;
    case 3:
    case "CF_DiscussChatType":
      return LowVersionTips_EChatType.CF_DiscussChatType;
    default:
      return LowVersionTips_EChatType.CF_UnknownChatType;
  }
}

export function lowVersionTips_EChatTypeToJSON(object: LowVersionTips_EChatType): string {
  switch (object) {
    case LowVersionTips_EChatType.CF_UnknownChatType:
      return "CF_UnknownChatType";
    case LowVersionTips_EChatType.CF_BuddyChatType:
      return "CF_BuddyChatType";
    case LowVersionTips_EChatType.CF_GroupChatType:
      return "CF_GroupChatType";
    case LowVersionTips_EChatType.CF_TempChatType:
      return "CF_TempChatType";
    case LowVersionTips_EChatType.CF_DiscussChatType:
      return "CF_DiscussChatType";
    default:
      return "CF_UnknownChatType";
  }
}

export interface NearByMessageType {
  uint32Type?: number | undefined;
  uint32IdentifyType?: number | undefined;
}

export enum NearByMessageType_ENearByMsgType {
  /** ETypeNormal - 普通消息 */
  ETypeNormal = 0,
  /** ETypeClearingText - 表白文本消息 */
  ETypeClearingText = 1,
  /** ETypeClearingImg - 表白图片消息 */
  ETypeClearingImg = 2,
  UNRECOGNIZED = -1,
}

export function nearByMessageType_ENearByMsgTypeFromJSON(object: any): NearByMessageType_ENearByMsgType {
  switch (object) {
    case 0:
    case "ETypeNormal":
      return NearByMessageType_ENearByMsgType.ETypeNormal;
    case 1:
    case "ETypeClearingText":
      return NearByMessageType_ENearByMsgType.ETypeClearingText;
    case 2:
    case "ETypeClearingImg":
      return NearByMessageType_ENearByMsgType.ETypeClearingImg;
    case -1:
    case "UNRECOGNIZED":
    default:
      return NearByMessageType_ENearByMsgType.UNRECOGNIZED;
  }
}

export function nearByMessageType_ENearByMsgTypeToJSON(object: NearByMessageType_ENearByMsgType): string {
  switch (object) {
    case NearByMessageType_ENearByMsgType.ETypeNormal:
      return "ETypeNormal";
    case NearByMessageType_ENearByMsgType.ETypeClearingText:
      return "ETypeClearingText";
    case NearByMessageType_ENearByMsgType.ETypeClearingImg:
      return "ETypeClearingImg";
    case NearByMessageType_ENearByMsgType.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** add for jazzyfu */
export enum NearByMessageType_EIdentifyType {
  /** ETypeDefault - 无认证标识 */
  ETypeDefault = 0,
  /** ETypeIdentify - 有认证标识 */
  ETypeIdentify = 1,
  UNRECOGNIZED = -1,
}

export function nearByMessageType_EIdentifyTypeFromJSON(object: any): NearByMessageType_EIdentifyType {
  switch (object) {
    case 0:
    case "ETypeDefault":
      return NearByMessageType_EIdentifyType.ETypeDefault;
    case 1:
    case "ETypeIdentify":
      return NearByMessageType_EIdentifyType.ETypeIdentify;
    case -1:
    case "UNRECOGNIZED":
    default:
      return NearByMessageType_EIdentifyType.UNRECOGNIZED;
  }
}

export function nearByMessageType_EIdentifyTypeToJSON(object: NearByMessageType_EIdentifyType): string {
  switch (object) {
    case NearByMessageType_EIdentifyType.ETypeDefault:
      return "ETypeDefault";
    case NearByMessageType_EIdentifyType.ETypeIdentify:
      return "ETypeIdentify";
    case NearByMessageType_EIdentifyType.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export interface CustomElem {
  bytesDesc?: Uint8Array | undefined;
  bytesData?: Uint8Array | undefined;
  enumType?: CustomElem_DataType | undefined;
  bytesExt?: Uint8Array | undefined;
  bytesSound?: Uint8Array | undefined;
}

export enum CustomElem_DataType {
  DataType_Text = 1,
  DataType_Bin = 2,
  UNRECOGNIZED = -1,
}

export function customElem_DataTypeFromJSON(object: any): CustomElem_DataType {
  switch (object) {
    case 1:
    case "DataType_Text":
      return CustomElem_DataType.DataType_Text;
    case 2:
    case "DataType_Bin":
      return CustomElem_DataType.DataType_Bin;
    case -1:
    case "UNRECOGNIZED":
    default:
      return CustomElem_DataType.UNRECOGNIZED;
  }
}

export function customElem_DataTypeToJSON(object: CustomElem_DataType): string {
  switch (object) {
    case CustomElem_DataType.DataType_Text:
      return "DataType_Text";
    case CustomElem_DataType.DataType_Bin:
      return "DataType_Bin";
    case CustomElem_DataType.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export interface LocationInfo {
  /** 经度 */
  doubleLongitude?:
    | number
    | undefined;
  /** 纬度 */
  doubleLatitude?: number | undefined;
  bytesDesc?: Uint8Array | undefined;
}

export interface PubAccInfo {
  /** 是否是兴趣号，用于兴趣号折叠 */
  uint32IsInterNum?:
    | number
    | undefined;
  /** 消息的模板ID */
  stringMsgTemplateId?:
    | string
    | undefined;
  /** 长消息url */
  stringLongMsgUrl?:
    | string
    | undefined;
  /** 长消息使用，二进制的文件下载key，转成16进制后作为rkey的值拼在url后面 */
  bytesDownloadKey?: Uint8Array | undefined;
}

export interface SmallEmoji {
  /** 用一个int来存储表情包id和子表情id */
  packIdSum?:
    | number
    | undefined;
  /** 来后8位来标示图片类型，没有或者0为gif，1为apng */
  imageType?: number | undefined;
}

export interface FSJMessageElem {
  uint32MsgType?: number | undefined;
}

export enum FSJMessageElem_EFSJMessageType {
  /** ETypeNormal - 普通消息 */
  ETypeNormal = 0,
  /** ETypeHotChatFlashPic - 热聊闪照消息 */
  ETypeHotChatFlashPic = 1,
  UNRECOGNIZED = -1,
}

export function fSJMessageElem_EFSJMessageTypeFromJSON(object: any): FSJMessageElem_EFSJMessageType {
  switch (object) {
    case 0:
    case "ETypeNormal":
      return FSJMessageElem_EFSJMessageType.ETypeNormal;
    case 1:
    case "ETypeHotChatFlashPic":
      return FSJMessageElem_EFSJMessageType.ETypeHotChatFlashPic;
    case -1:
    case "UNRECOGNIZED":
    default:
      return FSJMessageElem_EFSJMessageType.UNRECOGNIZED;
  }
}

export function fSJMessageElem_EFSJMessageTypeToJSON(object: FSJMessageElem_EFSJMessageType): string {
  switch (object) {
    case FSJMessageElem_EFSJMessageType.ETypeNormal:
      return "ETypeNormal";
    case FSJMessageElem_EFSJMessageType.ETypeHotChatFlashPic:
      return "ETypeHotChatFlashPic";
    case FSJMessageElem_EFSJMessageType.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export interface ArkAppElem {
  appName?: string | undefined;
  minVersion?: string | undefined;
  xmlTemplate?: string | undefined;
  bytesData?: Uint8Array | undefined;
}

export interface LightAppElem {
  bytesData?:
    | Uint8Array
    | undefined;
  /** 长消息resid */
  bytesMsgResid?: Uint8Array | undefined;
}

export interface GeneralFlags {
  /** DIY气泡ID */
  uint32BubbleDiyTextId?:
    | number
    | undefined;
  /** 群flag */
  uint32GroupFlagNew?:
    | number
    | undefined;
  /** 红包口令消息标识红包发送者, add by jimhou */
  uint64Uin?:
    | number
    | undefined;
  /** 红包口令ID, add by jimhou */
  bytesRpId?:
    | Uint8Array
    | undefined;
  /** 红包口令消息收叠标志, add by jimhou */
  uint32PrpFold?:
    | number
    | undefined;
  /** 新长文本标志, 1:表示长文本消息    added by ruifanyuan */
  longTextFlag?:
    | number
    | undefined;
  /** 新长文本消息体对应的resid added by ruifanyuan */
  longTextResid?:
    | Uint8Array
    | undefined;
  /** 位值， 每个位代表的含义如下：   add by wesleyhe */
  uint32GroupType?:
    | number
    | undefined;
  /**
   * 0x1:PC公开群
   * 0x2:热聊
   */
  uint32ToUinFlag?:
    | number
    | undefined;
  /** 群送花魅力值等级		add by raftzhang */
  uint32GlamourLevel?:
    | number
    | undefined;
  /** 群成员等级  add by raftzhang */
  uint32MemberLevel?:
    | number
    | undefined;
  /** 群成员等级seq add by raftzhang */
  uint64GroupRankSeq?:
    | number
    | undefined;
  /** 火炬手标识, 0:非火炬手; 1:火炬手	add by raftzhang */
  uint32OlympicTorch?:
    | number
    | undefined;
  /** BabyQ新用户引导消息cookie */
  babyqGuideMsgCookie?:
    | Uint8Array
    | undefined;
  /** 标记消息是用户发给行家还是行家发给用户的,1:行家到用户;2:用户到行家	add by tobinchen */
  uin32ExpertFlag?:
    | number
    | undefined;
  /** 气泡的子id，用于区分气泡套装中的子气泡  add by marlonlu */
  uint32BubbleSubId?:
    | number
    | undefined;
  /** 用户挂件ID add by jwkuang */
  uint64PendantId?:
    | number
    | undefined;
  /** 红包口令index add by xiaoronglin */
  bytesRpIndex?:
    | Uint8Array
    | undefined;
  /** GeneralFlags的扩展结构,参见hummer_resv_generalflags.proto */
  bytesPbReserve?: Uint8Array | undefined;
}

export interface DeliverGiftMsg {
  /** 群内送礼物成功的小灰条消息内容 */
  bytesGrayTipContent?:
    | Uint8Array
    | undefined;
  /** 群内送礼物成功的动画包id */
  uint32AnimationPackageId?:
    | number
    | undefined;
  /** 群内送礼物成功的动画包下载地址-android */
  bytesAnimationPackageUrlA?:
    | Uint8Array
    | undefined;
  /** 群内送礼物成功的动画包下载地址-ios */
  bytesAnimationPackageUrlI?:
    | Uint8Array
    | undefined;
  /** 群内送礼物成功的小灰条消息在消息列表页的橙色提醒 */
  bytesRemindBrief?:
    | Uint8Array
    | undefined;
  /** 群内送礼物的礼物ID */
  uint32GiftId?:
    | number
    | undefined;
  /** 群内送礼物的数量 */
  uint32GiftCount?:
    | number
    | undefined;
  /** 群内送礼物的动画下方提示语 */
  bytesAnimationBrief?:
    | Uint8Array
    | undefined;
  /** 群内送礼物的发送方号码 */
  uint64SenderUin?:
    | number
    | undefined;
  /** 群内送礼物的接受方号码 */
  uint64ReceiverUin?:
    | number
    | undefined;
  /** 群内送礼物title */
  bytesStmessageTitle?:
    | Uint8Array
    | undefined;
  /** 群内送礼物subtitle */
  bytesStmessageSubtitle?:
    | Uint8Array
    | undefined;
  /** 群内送礼物留言（花语） */
  bytesStmessageMessage?:
    | Uint8Array
    | undefined;
  /** 群内送礼物的图片id（用来拼接图片URL） */
  uint32StmessageGiftpicid?:
    | number
    | undefined;
  /** 群内送礼物来源 */
  bytesStmessageComefrom?:
    | Uint8Array
    | undefined;
  /** 群内送礼物可扩展标志位（某些开关状态） */
  uint32StmessageExflag?:
    | number
    | undefined;
  /** 全员送礼专属id */
  bytesToAllGiftId?:
    | Uint8Array
    | undefined;
  /** 送礼物来源链接,为空时跳转半屏商城 */
  bytesComefromLink?:
    | Uint8Array
    | undefined;
  /** DeliverGiftMsg的扩展结构,参见hummer_resv_deliver_gift_msg.proto */
  bytesPbReserve?:
    | Uint8Array
    | undefined;
  /** 明星排行榜需求添加 */
  bytesReceiverName?:
    | Uint8Array
    | undefined;
  /** 接收方头像 */
  bytesReceiverPic?:
    | Uint8Array
    | undefined;
  /** 群内送礼物的图片 URL */
  bytesStmessageGifturl?: Uint8Array | undefined;
}

export interface BitAppMsg {
  /** Xml */
  bytesBuf?: Uint8Array | undefined;
}

export interface OpenQQData {
  bytesCarQqData?: Uint8Array | undefined;
}

export interface BlessingMessage {
  uint32MsgType?: number | undefined;
  uint32ExFlag?: number | undefined;
}

export enum BlessingMessage_BlessingMessageType {
  /** ETypeNormal - 普通消息 */
  ETypeNormal = 0,
  /** ETypeBlessing - 群发祝福消息 */
  ETypeBlessing = 1,
  UNRECOGNIZED = -1,
}

export function blessingMessage_BlessingMessageTypeFromJSON(object: any): BlessingMessage_BlessingMessageType {
  switch (object) {
    case 0:
    case "ETypeNormal":
      return BlessingMessage_BlessingMessageType.ETypeNormal;
    case 1:
    case "ETypeBlessing":
      return BlessingMessage_BlessingMessageType.ETypeBlessing;
    case -1:
    case "UNRECOGNIZED":
    default:
      return BlessingMessage_BlessingMessageType.UNRECOGNIZED;
  }
}

export function blessingMessage_BlessingMessageTypeToJSON(object: BlessingMessage_BlessingMessageType): string {
  switch (object) {
    case BlessingMessage_BlessingMessageType.ETypeNormal:
      return "ETypeNormal";
    case BlessingMessage_BlessingMessageType.ETypeBlessing:
      return "ETypeBlessing";
    case BlessingMessage_BlessingMessageType.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export interface SourceMsg {
  /** 原消息seq */
  uint32OrigSeqs: number[];
  /** 所属发送者uin */
  uint64SenderUin?: number | undefined;
  uint32Time?:
    | number
    | undefined;
  /** 摘要里是否包括原消息的完整内容0 非完整内容，需要客户端拉取  1 完整内容，不用拉取 */
  uint32Flag?:
    | number
    | undefined;
  /** 消息的种类，包括文本消息，系统表情消息 */
  elems: Elem[];
  /** 引用消息展示样式，0表示普通文本，对应解析elems字段；1表示部落类型类似结构化消息的样式，对应解析bytes_richMsg字段 */
  uint32Type?:
    | number
    | undefined;
  /** 对应json字段，里面会带上title，summary，coverUrl，jumpUrl等字段 */
  bytesRichMsg?:
    | Uint8Array
    | undefined;
  /** SourceMsg的扩展结构,参见hummer_resv_source_msg.proto */
  bytesPbReserve?:
    | Uint8Array
    | undefined;
  /** 原消息消息体msg_com.Msg */
  bytesSrcMsg?:
    | Uint8Array
    | undefined;
  /** 所属接收者uin */
  uint64ToUin?:
    | number
    | undefined;
  /** 单独回复原消息群名 */
  bytesTroopName?: Uint8Array | undefined;
}

export interface WorkflowNotifyMsg {
  /** 下发的附加消息，通用buffer，所有相关信息都放到些buffer中 */
  bytesExtMsg?: Uint8Array | undefined;
  uint64CreateUin?: number | undefined;
}

export interface PatsElem {
  /** 客户端动画类型 [拍一下 = 0] or [击掌 = 1] */
  uint32PatType?:
    | number
    | undefined;
  /** 客户端动画次数 */
  uint32PatCount?: number | undefined;
}

export interface GroupPostElem {
  /** 群话题透传消息类型 */
  uint32TransType?:
    | number
    | undefined;
  /** 群话题透传消息内容 */
  bytesTransMsg?: Uint8Array | undefined;
}

export interface EIMInfo {
  /** 组织架构根节点ID */
  uint64RootId?:
    | number
    | undefined;
  /** 用于区分群的类型，0表示组织群聊，1表示多人会话 */
  uint32Flag?: number | undefined;
}

function createBaseMsgBody(): MsgBody {
  return { richText: undefined, msgContent: new Uint8Array(0), msgEncryptContent: new Uint8Array(0) };
}

export const MsgBody: MessageFns<MsgBody> = {
  encode(message: MsgBody, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.richText !== undefined) {
      RichText.encode(message.richText, writer.uint32(10).fork()).join();
    }
    if (message.msgContent !== undefined && message.msgContent.length !== 0) {
      writer.uint32(18).bytes(message.msgContent);
    }
    if (message.msgEncryptContent !== undefined && message.msgEncryptContent.length !== 0) {
      writer.uint32(26).bytes(message.msgEncryptContent);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgBody {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgBody();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.richText = RichText.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.msgContent = reader.bytes();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.msgEncryptContent = reader.bytes();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MsgBody {
    return {
      richText: isSet(object.richText) ? RichText.fromJSON(object.richText) : undefined,
      msgContent: isSet(object.msgContent) ? bytesFromBase64(object.msgContent) : new Uint8Array(0),
      msgEncryptContent: isSet(object.msgEncryptContent)
        ? bytesFromBase64(object.msgEncryptContent)
        : new Uint8Array(0),
    };
  },

  toJSON(message: MsgBody): unknown {
    const obj: any = {};
    if (message.richText !== undefined) {
      obj.richText = RichText.toJSON(message.richText);
    }
    if (message.msgContent !== undefined && message.msgContent.length !== 0) {
      obj.msgContent = base64FromBytes(message.msgContent);
    }
    if (message.msgEncryptContent !== undefined && message.msgEncryptContent.length !== 0) {
      obj.msgEncryptContent = base64FromBytes(message.msgEncryptContent);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MsgBody>, I>>(base?: I): MsgBody {
    return MsgBody.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MsgBody>, I>>(object: I): MsgBody {
    const message = createBaseMsgBody();
    message.richText = (object.richText !== undefined && object.richText !== null)
      ? RichText.fromPartial(object.richText)
      : undefined;
    message.msgContent = object.msgContent ?? new Uint8Array(0);
    message.msgEncryptContent = object.msgEncryptContent ?? new Uint8Array(0);
    return message;
  },
};

function createBaseRichText(): RichText {
  return {
    attr: undefined,
    elems: [],
    notOnlineFile: undefined,
    ptt: undefined,
    tmpPtt: undefined,
    trans211TmpMsg: undefined,
  };
}

export const RichText: MessageFns<RichText> = {
  encode(message: RichText, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.attr !== undefined) {
      Attr.encode(message.attr, writer.uint32(10).fork()).join();
    }
    for (const v of message.elems) {
      Elem.encode(v!, writer.uint32(18).fork()).join();
    }
    if (message.notOnlineFile !== undefined) {
      NotOnlineFile.encode(message.notOnlineFile, writer.uint32(26).fork()).join();
    }
    if (message.ptt !== undefined) {
      Ptt.encode(message.ptt, writer.uint32(34).fork()).join();
    }
    if (message.tmpPtt !== undefined) {
      TmpPtt.encode(message.tmpPtt, writer.uint32(42).fork()).join();
    }
    if (message.trans211TmpMsg !== undefined) {
      Trans211TmpMsg.encode(message.trans211TmpMsg, writer.uint32(50).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RichText {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRichText();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.attr = Attr.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.elems.push(Elem.decode(reader, reader.uint32()));
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.notOnlineFile = NotOnlineFile.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.ptt = Ptt.decode(reader, reader.uint32());
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.tmpPtt = TmpPtt.decode(reader, reader.uint32());
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.trans211TmpMsg = Trans211TmpMsg.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RichText {
    return {
      attr: isSet(object.attr) ? Attr.fromJSON(object.attr) : undefined,
      elems: globalThis.Array.isArray(object?.elems) ? object.elems.map((e: any) => Elem.fromJSON(e)) : [],
      notOnlineFile: isSet(object.notOnlineFile) ? NotOnlineFile.fromJSON(object.notOnlineFile) : undefined,
      ptt: isSet(object.ptt) ? Ptt.fromJSON(object.ptt) : undefined,
      tmpPtt: isSet(object.tmpPtt) ? TmpPtt.fromJSON(object.tmpPtt) : undefined,
      trans211TmpMsg: isSet(object.trans211TmpMsg) ? Trans211TmpMsg.fromJSON(object.trans211TmpMsg) : undefined,
    };
  },

  toJSON(message: RichText): unknown {
    const obj: any = {};
    if (message.attr !== undefined) {
      obj.attr = Attr.toJSON(message.attr);
    }
    if (message.elems?.length) {
      obj.elems = message.elems.map((e) => Elem.toJSON(e));
    }
    if (message.notOnlineFile !== undefined) {
      obj.notOnlineFile = NotOnlineFile.toJSON(message.notOnlineFile);
    }
    if (message.ptt !== undefined) {
      obj.ptt = Ptt.toJSON(message.ptt);
    }
    if (message.tmpPtt !== undefined) {
      obj.tmpPtt = TmpPtt.toJSON(message.tmpPtt);
    }
    if (message.trans211TmpMsg !== undefined) {
      obj.trans211TmpMsg = Trans211TmpMsg.toJSON(message.trans211TmpMsg);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<RichText>, I>>(base?: I): RichText {
    return RichText.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<RichText>, I>>(object: I): RichText {
    const message = createBaseRichText();
    message.attr = (object.attr !== undefined && object.attr !== null) ? Attr.fromPartial(object.attr) : undefined;
    message.elems = object.elems?.map((e) => Elem.fromPartial(e)) || [];
    message.notOnlineFile = (object.notOnlineFile !== undefined && object.notOnlineFile !== null)
      ? NotOnlineFile.fromPartial(object.notOnlineFile)
      : undefined;
    message.ptt = (object.ptt !== undefined && object.ptt !== null) ? Ptt.fromPartial(object.ptt) : undefined;
    message.tmpPtt = (object.tmpPtt !== undefined && object.tmpPtt !== null)
      ? TmpPtt.fromPartial(object.tmpPtt)
      : undefined;
    message.trans211TmpMsg = (object.trans211TmpMsg !== undefined && object.trans211TmpMsg !== null)
      ? Trans211TmpMsg.fromPartial(object.trans211TmpMsg)
      : undefined;
    return message;
  },
};

function createBaseTrans211TmpMsg(): Trans211TmpMsg {
  return { bytesMsgBody: new Uint8Array(0), uint32C2cCmd: 0 };
}

export const Trans211TmpMsg: MessageFns<Trans211TmpMsg> = {
  encode(message: Trans211TmpMsg, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.bytesMsgBody !== undefined && message.bytesMsgBody.length !== 0) {
      writer.uint32(10).bytes(message.bytesMsgBody);
    }
    if (message.uint32C2cCmd !== undefined && message.uint32C2cCmd !== 0) {
      writer.uint32(16).uint32(message.uint32C2cCmd);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Trans211TmpMsg {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTrans211TmpMsg();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.bytesMsgBody = reader.bytes();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.uint32C2cCmd = reader.uint32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Trans211TmpMsg {
    return {
      bytesMsgBody: isSet(object.bytesMsgBody) ? bytesFromBase64(object.bytesMsgBody) : new Uint8Array(0),
      uint32C2cCmd: isSet(object.uint32C2cCmd) ? globalThis.Number(object.uint32C2cCmd) : 0,
    };
  },

  toJSON(message: Trans211TmpMsg): unknown {
    const obj: any = {};
    if (message.bytesMsgBody !== undefined && message.bytesMsgBody.length !== 0) {
      obj.bytesMsgBody = base64FromBytes(message.bytesMsgBody);
    }
    if (message.uint32C2cCmd !== undefined && message.uint32C2cCmd !== 0) {
      obj.uint32C2cCmd = Math.round(message.uint32C2cCmd);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Trans211TmpMsg>, I>>(base?: I): Trans211TmpMsg {
    return Trans211TmpMsg.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Trans211TmpMsg>, I>>(object: I): Trans211TmpMsg {
    const message = createBaseTrans211TmpMsg();
    message.bytesMsgBody = object.bytesMsgBody ?? new Uint8Array(0);
    message.uint32C2cCmd = object.uint32C2cCmd ?? 0;
    return message;
  },
};

function createBaseAttr(): Attr {
  return {
    codePage: -1,
    time: 1,
    random: 0,
    color: 0,
    size: 10,
    effect: 7,
    charSet: 78,
    pitchAndFamily: 90,
    fontName: "Times New Roman",
    reserveData: new Uint8Array(0),
  };
}

export const Attr: MessageFns<Attr> = {
  encode(message: Attr, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.codePage !== undefined && message.codePage !== -1) {
      writer.uint32(8).sint32(message.codePage);
    }
    if (message.time !== undefined && message.time !== 1) {
      writer.uint32(16).uint32(message.time);
    }
    if (message.random !== undefined && message.random !== 0) {
      writer.uint32(24).uint32(message.random);
    }
    if (message.color !== undefined && message.color !== 0) {
      writer.uint32(32).uint32(message.color);
    }
    if (message.size !== undefined && message.size !== 10) {
      writer.uint32(40).uint32(message.size);
    }
    if (message.effect !== undefined && message.effect !== 7) {
      writer.uint32(48).uint32(message.effect);
    }
    if (message.charSet !== undefined && message.charSet !== 78) {
      writer.uint32(56).uint32(message.charSet);
    }
    if (message.pitchAndFamily !== undefined && message.pitchAndFamily !== 90) {
      writer.uint32(64).uint32(message.pitchAndFamily);
    }
    if (message.fontName !== undefined && message.fontName !== "Times New Roman") {
      writer.uint32(74).string(message.fontName);
    }
    if (message.reserveData !== undefined && message.reserveData.length !== 0) {
      writer.uint32(82).bytes(message.reserveData);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Attr {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAttr();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.codePage = reader.sint32();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.time = reader.uint32();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.random = reader.uint32();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.color = reader.uint32();
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.size = reader.uint32();
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.effect = reader.uint32();
          continue;
        }
        case 7: {
          if (tag !== 56) {
            break;
          }

          message.charSet = reader.uint32();
          continue;
        }
        case 8: {
          if (tag !== 64) {
            break;
          }

          message.pitchAndFamily = reader.uint32();
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.fontName = reader.string();
          continue;
        }
        case 10: {
          if (tag !== 82) {
            break;
          }

          message.reserveData = reader.bytes();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Attr {
    return {
      codePage: isSet(object.codePage) ? globalThis.Number(object.codePage) : -1,
      time: isSet(object.time) ? globalThis.Number(object.time) : 1,
      random: isSet(object.random) ? globalThis.Number(object.random) : 0,
      color: isSet(object.color) ? globalThis.Number(object.color) : 0,
      size: isSet(object.size) ? globalThis.Number(object.size) : 10,
      effect: isSet(object.effect) ? globalThis.Number(object.effect) : 7,
      charSet: isSet(object.charSet) ? globalThis.Number(object.charSet) : 78,
      pitchAndFamily: isSet(object.pitchAndFamily) ? globalThis.Number(object.pitchAndFamily) : 90,
      fontName: isSet(object.fontName) ? globalThis.String(object.fontName) : "Times New Roman",
      reserveData: isSet(object.reserveData) ? bytesFromBase64(object.reserveData) : new Uint8Array(0),
    };
  },

  toJSON(message: Attr): unknown {
    const obj: any = {};
    if (message.codePage !== undefined && message.codePage !== -1) {
      obj.codePage = Math.round(message.codePage);
    }
    if (message.time !== undefined && message.time !== 1) {
      obj.time = Math.round(message.time);
    }
    if (message.random !== undefined && message.random !== 0) {
      obj.random = Math.round(message.random);
    }
    if (message.color !== undefined && message.color !== 0) {
      obj.color = Math.round(message.color);
    }
    if (message.size !== undefined && message.size !== 10) {
      obj.size = Math.round(message.size);
    }
    if (message.effect !== undefined && message.effect !== 7) {
      obj.effect = Math.round(message.effect);
    }
    if (message.charSet !== undefined && message.charSet !== 78) {
      obj.charSet = Math.round(message.charSet);
    }
    if (message.pitchAndFamily !== undefined && message.pitchAndFamily !== 90) {
      obj.pitchAndFamily = Math.round(message.pitchAndFamily);
    }
    if (message.fontName !== undefined && message.fontName !== "Times New Roman") {
      obj.fontName = message.fontName;
    }
    if (message.reserveData !== undefined && message.reserveData.length !== 0) {
      obj.reserveData = base64FromBytes(message.reserveData);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Attr>, I>>(base?: I): Attr {
    return Attr.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Attr>, I>>(object: I): Attr {
    const message = createBaseAttr();
    message.codePage = object.codePage ?? -1;
    message.time = object.time ?? 1;
    message.random = object.random ?? 0;
    message.color = object.color ?? 0;
    message.size = object.size ?? 10;
    message.effect = object.effect ?? 7;
    message.charSet = object.charSet ?? 78;
    message.pitchAndFamily = object.pitchAndFamily ?? 90;
    message.fontName = object.fontName ?? "Times New Roman";
    message.reserveData = object.reserveData ?? new Uint8Array(0);
    return message;
  },
};

function createBaseElem(): Elem {
  return {
    text: undefined,
    face: undefined,
    onlineImage: undefined,
    notOnlineImage: undefined,
    transElemInfo: undefined,
    marketFace: undefined,
    elemFlags: undefined,
    customFace: undefined,
    elemFlags2: undefined,
    funFace: undefined,
    secretFile: undefined,
    richMsg: undefined,
    groupFile: undefined,
    pubGroup: undefined,
    marketTrans: undefined,
    extraInfo: undefined,
    shakeWindow: undefined,
    pubAccount: undefined,
    videoFile: undefined,
    tipsInfo: undefined,
    anonGroupMsg: undefined,
    qqLiveOld: undefined,
    lifeOnline: undefined,
    qqwalletMsg: undefined,
    crmElem: undefined,
    conferenceTipsInfo: undefined,
    redbagInfo: undefined,
    lowVersionTips: undefined,
    bankcodeCtrlInfo: new Uint8Array(0),
    nearByMsg: undefined,
    customElem: undefined,
    locationInfo: undefined,
    pubAccInfo: undefined,
    smallEmoji: undefined,
    fsjMsgElem: undefined,
    arkApp: undefined,
    generalFlags: undefined,
    hcFlashPic: undefined,
    deliverGiftMsg: undefined,
    bitappMsg: undefined,
    openQqData: undefined,
    apolloMsg: undefined,
    groupPubAccInfo: undefined,
    blessMsg: undefined,
    srcMsg: undefined,
    lolaMsg: undefined,
    groupBusinessMsg: undefined,
    msgWorkflowNotify: undefined,
    patElem: undefined,
    groupPostElem: undefined,
    lightApp: undefined,
    eimInfo: undefined,
    commonElem: undefined,
  };
}

export const Elem: MessageFns<Elem> = {
  encode(message: Elem, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.text !== undefined) {
      Text.encode(message.text, writer.uint32(10).fork()).join();
    }
    if (message.face !== undefined) {
      Face.encode(message.face, writer.uint32(18).fork()).join();
    }
    if (message.onlineImage !== undefined) {
      OnlineImage.encode(message.onlineImage, writer.uint32(26).fork()).join();
    }
    if (message.notOnlineImage !== undefined) {
      NotOnlineImage.encode(message.notOnlineImage, writer.uint32(34).fork()).join();
    }
    if (message.transElemInfo !== undefined) {
      TransElem.encode(message.transElemInfo, writer.uint32(42).fork()).join();
    }
    if (message.marketFace !== undefined) {
      MarketFace.encode(message.marketFace, writer.uint32(50).fork()).join();
    }
    if (message.elemFlags !== undefined) {
      ElemFlags.encode(message.elemFlags, writer.uint32(58).fork()).join();
    }
    if (message.customFace !== undefined) {
      CustomFace.encode(message.customFace, writer.uint32(66).fork()).join();
    }
    if (message.elemFlags2 !== undefined) {
      ElemFlags2.encode(message.elemFlags2, writer.uint32(74).fork()).join();
    }
    if (message.funFace !== undefined) {
      FunFace.encode(message.funFace, writer.uint32(82).fork()).join();
    }
    if (message.secretFile !== undefined) {
      SecretFileMsg.encode(message.secretFile, writer.uint32(90).fork()).join();
    }
    if (message.richMsg !== undefined) {
      RichMsg.encode(message.richMsg, writer.uint32(98).fork()).join();
    }
    if (message.groupFile !== undefined) {
      GroupFile.encode(message.groupFile, writer.uint32(106).fork()).join();
    }
    if (message.pubGroup !== undefined) {
      PubGroup.encode(message.pubGroup, writer.uint32(114).fork()).join();
    }
    if (message.marketTrans !== undefined) {
      MarketTrans.encode(message.marketTrans, writer.uint32(122).fork()).join();
    }
    if (message.extraInfo !== undefined) {
      ExtraInfo.encode(message.extraInfo, writer.uint32(130).fork()).join();
    }
    if (message.shakeWindow !== undefined) {
      ShakeWindow.encode(message.shakeWindow, writer.uint32(138).fork()).join();
    }
    if (message.pubAccount !== undefined) {
      PubAccount.encode(message.pubAccount, writer.uint32(146).fork()).join();
    }
    if (message.videoFile !== undefined) {
      VideoFile.encode(message.videoFile, writer.uint32(154).fork()).join();
    }
    if (message.tipsInfo !== undefined) {
      TipsInfo.encode(message.tipsInfo, writer.uint32(162).fork()).join();
    }
    if (message.anonGroupMsg !== undefined) {
      AnonymousGroupMsg.encode(message.anonGroupMsg, writer.uint32(170).fork()).join();
    }
    if (message.qqLiveOld !== undefined) {
      QQLiveOld.encode(message.qqLiveOld, writer.uint32(178).fork()).join();
    }
    if (message.lifeOnline !== undefined) {
      LifeOnlineAccount.encode(message.lifeOnline, writer.uint32(186).fork()).join();
    }
    if (message.qqwalletMsg !== undefined) {
      QQWalletMsg.encode(message.qqwalletMsg, writer.uint32(194).fork()).join();
    }
    if (message.crmElem !== undefined) {
      CrmElem.encode(message.crmElem, writer.uint32(202).fork()).join();
    }
    if (message.conferenceTipsInfo !== undefined) {
      ConferenceTipsInfo.encode(message.conferenceTipsInfo, writer.uint32(210).fork()).join();
    }
    if (message.redbagInfo !== undefined) {
      RedBagInfo.encode(message.redbagInfo, writer.uint32(218).fork()).join();
    }
    if (message.lowVersionTips !== undefined) {
      LowVersionTips.encode(message.lowVersionTips, writer.uint32(226).fork()).join();
    }
    if (message.bankcodeCtrlInfo !== undefined && message.bankcodeCtrlInfo.length !== 0) {
      writer.uint32(234).bytes(message.bankcodeCtrlInfo);
    }
    if (message.nearByMsg !== undefined) {
      NearByMessageType.encode(message.nearByMsg, writer.uint32(242).fork()).join();
    }
    if (message.customElem !== undefined) {
      CustomElem.encode(message.customElem, writer.uint32(250).fork()).join();
    }
    if (message.locationInfo !== undefined) {
      LocationInfo.encode(message.locationInfo, writer.uint32(258).fork()).join();
    }
    if (message.pubAccInfo !== undefined) {
      PubAccInfo.encode(message.pubAccInfo, writer.uint32(266).fork()).join();
    }
    if (message.smallEmoji !== undefined) {
      SmallEmoji.encode(message.smallEmoji, writer.uint32(274).fork()).join();
    }
    if (message.fsjMsgElem !== undefined) {
      FSJMessageElem.encode(message.fsjMsgElem, writer.uint32(282).fork()).join();
    }
    if (message.arkApp !== undefined) {
      ArkAppElem.encode(message.arkApp, writer.uint32(290).fork()).join();
    }
    if (message.generalFlags !== undefined) {
      GeneralFlags.encode(message.generalFlags, writer.uint32(298).fork()).join();
    }
    if (message.hcFlashPic !== undefined) {
      CustomFace.encode(message.hcFlashPic, writer.uint32(306).fork()).join();
    }
    if (message.deliverGiftMsg !== undefined) {
      DeliverGiftMsg.encode(message.deliverGiftMsg, writer.uint32(314).fork()).join();
    }
    if (message.bitappMsg !== undefined) {
      BitAppMsg.encode(message.bitappMsg, writer.uint32(322).fork()).join();
    }
    if (message.openQqData !== undefined) {
      OpenQQData.encode(message.openQqData, writer.uint32(330).fork()).join();
    }
    if (message.apolloMsg !== undefined) {
      ApolloActMsg.encode(message.apolloMsg, writer.uint32(338).fork()).join();
    }
    if (message.groupPubAccInfo !== undefined) {
      GroupPubAccountInfo.encode(message.groupPubAccInfo, writer.uint32(346).fork()).join();
    }
    if (message.blessMsg !== undefined) {
      BlessingMessage.encode(message.blessMsg, writer.uint32(354).fork()).join();
    }
    if (message.srcMsg !== undefined) {
      SourceMsg.encode(message.srcMsg, writer.uint32(362).fork()).join();
    }
    if (message.lolaMsg !== undefined) {
      LolaMsg.encode(message.lolaMsg, writer.uint32(370).fork()).join();
    }
    if (message.groupBusinessMsg !== undefined) {
      GroupBusinessMsg.encode(message.groupBusinessMsg, writer.uint32(378).fork()).join();
    }
    if (message.msgWorkflowNotify !== undefined) {
      WorkflowNotifyMsg.encode(message.msgWorkflowNotify, writer.uint32(386).fork()).join();
    }
    if (message.patElem !== undefined) {
      PatsElem.encode(message.patElem, writer.uint32(394).fork()).join();
    }
    if (message.groupPostElem !== undefined) {
      GroupPostElem.encode(message.groupPostElem, writer.uint32(402).fork()).join();
    }
    if (message.lightApp !== undefined) {
      LightAppElem.encode(message.lightApp, writer.uint32(410).fork()).join();
    }
    if (message.eimInfo !== undefined) {
      EIMInfo.encode(message.eimInfo, writer.uint32(418).fork()).join();
    }
    if (message.commonElem !== undefined) {
      CommonElem.encode(message.commonElem, writer.uint32(426).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Elem {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseElem();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.text = Text.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.face = Face.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.onlineImage = OnlineImage.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.notOnlineImage = NotOnlineImage.decode(reader, reader.uint32());
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.transElemInfo = TransElem.decode(reader, reader.uint32());
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.marketFace = MarketFace.decode(reader, reader.uint32());
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.elemFlags = ElemFlags.decode(reader, reader.uint32());
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.customFace = CustomFace.decode(reader, reader.uint32());
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.elemFlags2 = ElemFlags2.decode(reader, reader.uint32());
          continue;
        }
        case 10: {
          if (tag !== 82) {
            break;
          }

          message.funFace = FunFace.decode(reader, reader.uint32());
          continue;
        }
        case 11: {
          if (tag !== 90) {
            break;
          }

          message.secretFile = SecretFileMsg.decode(reader, reader.uint32());
          continue;
        }
        case 12: {
          if (tag !== 98) {
            break;
          }

          message.richMsg = RichMsg.decode(reader, reader.uint32());
          continue;
        }
        case 13: {
          if (tag !== 106) {
            break;
          }

          message.groupFile = GroupFile.decode(reader, reader.uint32());
          continue;
        }
        case 14: {
          if (tag !== 114) {
            break;
          }

          message.pubGroup = PubGroup.decode(reader, reader.uint32());
          continue;
        }
        case 15: {
          if (tag !== 122) {
            break;
          }

          message.marketTrans = MarketTrans.decode(reader, reader.uint32());
          continue;
        }
        case 16: {
          if (tag !== 130) {
            break;
          }

          message.extraInfo = ExtraInfo.decode(reader, reader.uint32());
          continue;
        }
        case 17: {
          if (tag !== 138) {
            break;
          }

          message.shakeWindow = ShakeWindow.decode(reader, reader.uint32());
          continue;
        }
        case 18: {
          if (tag !== 146) {
            break;
          }

          message.pubAccount = PubAccount.decode(reader, reader.uint32());
          continue;
        }
        case 19: {
          if (tag !== 154) {
            break;
          }

          message.videoFile = VideoFile.decode(reader, reader.uint32());
          continue;
        }
        case 20: {
          if (tag !== 162) {
            break;
          }

          message.tipsInfo = TipsInfo.decode(reader, reader.uint32());
          continue;
        }
        case 21: {
          if (tag !== 170) {
            break;
          }

          message.anonGroupMsg = AnonymousGroupMsg.decode(reader, reader.uint32());
          continue;
        }
        case 22: {
          if (tag !== 178) {
            break;
          }

          message.qqLiveOld = QQLiveOld.decode(reader, reader.uint32());
          continue;
        }
        case 23: {
          if (tag !== 186) {
            break;
          }

          message.lifeOnline = LifeOnlineAccount.decode(reader, reader.uint32());
          continue;
        }
        case 24: {
          if (tag !== 194) {
            break;
          }

          message.qqwalletMsg = QQWalletMsg.decode(reader, reader.uint32());
          continue;
        }
        case 25: {
          if (tag !== 202) {
            break;
          }

          message.crmElem = CrmElem.decode(reader, reader.uint32());
          continue;
        }
        case 26: {
          if (tag !== 210) {
            break;
          }

          message.conferenceTipsInfo = ConferenceTipsInfo.decode(reader, reader.uint32());
          continue;
        }
        case 27: {
          if (tag !== 218) {
            break;
          }

          message.redbagInfo = RedBagInfo.decode(reader, reader.uint32());
          continue;
        }
        case 28: {
          if (tag !== 226) {
            break;
          }

          message.lowVersionTips = LowVersionTips.decode(reader, reader.uint32());
          continue;
        }
        case 29: {
          if (tag !== 234) {
            break;
          }

          message.bankcodeCtrlInfo = reader.bytes();
          continue;
        }
        case 30: {
          if (tag !== 242) {
            break;
          }

          message.nearByMsg = NearByMessageType.decode(reader, reader.uint32());
          continue;
        }
        case 31: {
          if (tag !== 250) {
            break;
          }

          message.customElem = CustomElem.decode(reader, reader.uint32());
          continue;
        }
        case 32: {
          if (tag !== 258) {
            break;
          }

          message.locationInfo = LocationInfo.decode(reader, reader.uint32());
          continue;
        }
        case 33: {
          if (tag !== 266) {
            break;
          }

          message.pubAccInfo = PubAccInfo.decode(reader, reader.uint32());
          continue;
        }
        case 34: {
          if (tag !== 274) {
            break;
          }

          message.smallEmoji = SmallEmoji.decode(reader, reader.uint32());
          continue;
        }
        case 35: {
          if (tag !== 282) {
            break;
          }

          message.fsjMsgElem = FSJMessageElem.decode(reader, reader.uint32());
          continue;
        }
        case 36: {
          if (tag !== 290) {
            break;
          }

          message.arkApp = ArkAppElem.decode(reader, reader.uint32());
          continue;
        }
        case 37: {
          if (tag !== 298) {
            break;
          }

          message.generalFlags = GeneralFlags.decode(reader, reader.uint32());
          continue;
        }
        case 38: {
          if (tag !== 306) {
            break;
          }

          message.hcFlashPic = CustomFace.decode(reader, reader.uint32());
          continue;
        }
        case 39: {
          if (tag !== 314) {
            break;
          }

          message.deliverGiftMsg = DeliverGiftMsg.decode(reader, reader.uint32());
          continue;
        }
        case 40: {
          if (tag !== 322) {
            break;
          }

          message.bitappMsg = BitAppMsg.decode(reader, reader.uint32());
          continue;
        }
        case 41: {
          if (tag !== 330) {
            break;
          }

          message.openQqData = OpenQQData.decode(reader, reader.uint32());
          continue;
        }
        case 42: {
          if (tag !== 338) {
            break;
          }

          message.apolloMsg = ApolloActMsg.decode(reader, reader.uint32());
          continue;
        }
        case 43: {
          if (tag !== 346) {
            break;
          }

          message.groupPubAccInfo = GroupPubAccountInfo.decode(reader, reader.uint32());
          continue;
        }
        case 44: {
          if (tag !== 354) {
            break;
          }

          message.blessMsg = BlessingMessage.decode(reader, reader.uint32());
          continue;
        }
        case 45: {
          if (tag !== 362) {
            break;
          }

          message.srcMsg = SourceMsg.decode(reader, reader.uint32());
          continue;
        }
        case 46: {
          if (tag !== 370) {
            break;
          }

          message.lolaMsg = LolaMsg.decode(reader, reader.uint32());
          continue;
        }
        case 47: {
          if (tag !== 378) {
            break;
          }

          message.groupBusinessMsg = GroupBusinessMsg.decode(reader, reader.uint32());
          continue;
        }
        case 48: {
          if (tag !== 386) {
            break;
          }

          message.msgWorkflowNotify = WorkflowNotifyMsg.decode(reader, reader.uint32());
          continue;
        }
        case 49: {
          if (tag !== 394) {
            break;
          }

          message.patElem = PatsElem.decode(reader, reader.uint32());
          continue;
        }
        case 50: {
          if (tag !== 402) {
            break;
          }

          message.groupPostElem = GroupPostElem.decode(reader, reader.uint32());
          continue;
        }
        case 51: {
          if (tag !== 410) {
            break;
          }

          message.lightApp = LightAppElem.decode(reader, reader.uint32());
          continue;
        }
        case 52: {
          if (tag !== 418) {
            break;
          }

          message.eimInfo = EIMInfo.decode(reader, reader.uint32());
          continue;
        }
        case 53: {
          if (tag !== 426) {
            break;
          }

          message.commonElem = CommonElem.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Elem {
    return {
      text: isSet(object.text) ? Text.fromJSON(object.text) : undefined,
      face: isSet(object.face) ? Face.fromJSON(object.face) : undefined,
      onlineImage: isSet(object.onlineImage) ? OnlineImage.fromJSON(object.onlineImage) : undefined,
      notOnlineImage: isSet(object.notOnlineImage) ? NotOnlineImage.fromJSON(object.notOnlineImage) : undefined,
      transElemInfo: isSet(object.transElemInfo) ? TransElem.fromJSON(object.transElemInfo) : undefined,
      marketFace: isSet(object.marketFace) ? MarketFace.fromJSON(object.marketFace) : undefined,
      elemFlags: isSet(object.elemFlags) ? ElemFlags.fromJSON(object.elemFlags) : undefined,
      customFace: isSet(object.customFace) ? CustomFace.fromJSON(object.customFace) : undefined,
      elemFlags2: isSet(object.elemFlags2) ? ElemFlags2.fromJSON(object.elemFlags2) : undefined,
      funFace: isSet(object.funFace) ? FunFace.fromJSON(object.funFace) : undefined,
      secretFile: isSet(object.secretFile) ? SecretFileMsg.fromJSON(object.secretFile) : undefined,
      richMsg: isSet(object.richMsg) ? RichMsg.fromJSON(object.richMsg) : undefined,
      groupFile: isSet(object.groupFile) ? GroupFile.fromJSON(object.groupFile) : undefined,
      pubGroup: isSet(object.pubGroup) ? PubGroup.fromJSON(object.pubGroup) : undefined,
      marketTrans: isSet(object.marketTrans) ? MarketTrans.fromJSON(object.marketTrans) : undefined,
      extraInfo: isSet(object.extraInfo) ? ExtraInfo.fromJSON(object.extraInfo) : undefined,
      shakeWindow: isSet(object.shakeWindow) ? ShakeWindow.fromJSON(object.shakeWindow) : undefined,
      pubAccount: isSet(object.pubAccount) ? PubAccount.fromJSON(object.pubAccount) : undefined,
      videoFile: isSet(object.videoFile) ? VideoFile.fromJSON(object.videoFile) : undefined,
      tipsInfo: isSet(object.tipsInfo) ? TipsInfo.fromJSON(object.tipsInfo) : undefined,
      anonGroupMsg: isSet(object.anonGroupMsg) ? AnonymousGroupMsg.fromJSON(object.anonGroupMsg) : undefined,
      qqLiveOld: isSet(object.qqLiveOld) ? QQLiveOld.fromJSON(object.qqLiveOld) : undefined,
      lifeOnline: isSet(object.lifeOnline) ? LifeOnlineAccount.fromJSON(object.lifeOnline) : undefined,
      qqwalletMsg: isSet(object.qqwalletMsg) ? QQWalletMsg.fromJSON(object.qqwalletMsg) : undefined,
      crmElem: isSet(object.crmElem) ? CrmElem.fromJSON(object.crmElem) : undefined,
      conferenceTipsInfo: isSet(object.conferenceTipsInfo)
        ? ConferenceTipsInfo.fromJSON(object.conferenceTipsInfo)
        : undefined,
      redbagInfo: isSet(object.redbagInfo) ? RedBagInfo.fromJSON(object.redbagInfo) : undefined,
      lowVersionTips: isSet(object.lowVersionTips) ? LowVersionTips.fromJSON(object.lowVersionTips) : undefined,
      bankcodeCtrlInfo: isSet(object.bankcodeCtrlInfo) ? bytesFromBase64(object.bankcodeCtrlInfo) : new Uint8Array(0),
      nearByMsg: isSet(object.nearByMsg) ? NearByMessageType.fromJSON(object.nearByMsg) : undefined,
      customElem: isSet(object.customElem) ? CustomElem.fromJSON(object.customElem) : undefined,
      locationInfo: isSet(object.locationInfo) ? LocationInfo.fromJSON(object.locationInfo) : undefined,
      pubAccInfo: isSet(object.pubAccInfo) ? PubAccInfo.fromJSON(object.pubAccInfo) : undefined,
      smallEmoji: isSet(object.smallEmoji) ? SmallEmoji.fromJSON(object.smallEmoji) : undefined,
      fsjMsgElem: isSet(object.fsjMsgElem) ? FSJMessageElem.fromJSON(object.fsjMsgElem) : undefined,
      arkApp: isSet(object.arkApp) ? ArkAppElem.fromJSON(object.arkApp) : undefined,
      generalFlags: isSet(object.generalFlags) ? GeneralFlags.fromJSON(object.generalFlags) : undefined,
      hcFlashPic: isSet(object.hcFlashPic) ? CustomFace.fromJSON(object.hcFlashPic) : undefined,
      deliverGiftMsg: isSet(object.deliverGiftMsg) ? DeliverGiftMsg.fromJSON(object.deliverGiftMsg) : undefined,
      bitappMsg: isSet(object.bitappMsg) ? BitAppMsg.fromJSON(object.bitappMsg) : undefined,
      openQqData: isSet(object.openQqData) ? OpenQQData.fromJSON(object.openQqData) : undefined,
      apolloMsg: isSet(object.apolloMsg) ? ApolloActMsg.fromJSON(object.apolloMsg) : undefined,
      groupPubAccInfo: isSet(object.groupPubAccInfo) ? GroupPubAccountInfo.fromJSON(object.groupPubAccInfo) : undefined,
      blessMsg: isSet(object.blessMsg) ? BlessingMessage.fromJSON(object.blessMsg) : undefined,
      srcMsg: isSet(object.srcMsg) ? SourceMsg.fromJSON(object.srcMsg) : undefined,
      lolaMsg: isSet(object.lolaMsg) ? LolaMsg.fromJSON(object.lolaMsg) : undefined,
      groupBusinessMsg: isSet(object.groupBusinessMsg) ? GroupBusinessMsg.fromJSON(object.groupBusinessMsg) : undefined,
      msgWorkflowNotify: isSet(object.msgWorkflowNotify)
        ? WorkflowNotifyMsg.fromJSON(object.msgWorkflowNotify)
        : undefined,
      patElem: isSet(object.patElem) ? PatsElem.fromJSON(object.patElem) : undefined,
      groupPostElem: isSet(object.groupPostElem) ? GroupPostElem.fromJSON(object.groupPostElem) : undefined,
      lightApp: isSet(object.lightApp) ? LightAppElem.fromJSON(object.lightApp) : undefined,
      eimInfo: isSet(object.eimInfo) ? EIMInfo.fromJSON(object.eimInfo) : undefined,
      commonElem: isSet(object.commonElem) ? CommonElem.fromJSON(object.commonElem) : undefined,
    };
  },

  toJSON(message: Elem): unknown {
    const obj: any = {};
    if (message.text !== undefined) {
      obj.text = Text.toJSON(message.text);
    }
    if (message.face !== undefined) {
      obj.face = Face.toJSON(message.face);
    }
    if (message.onlineImage !== undefined) {
      obj.onlineImage = OnlineImage.toJSON(message.onlineImage);
    }
    if (message.notOnlineImage !== undefined) {
      obj.notOnlineImage = NotOnlineImage.toJSON(message.notOnlineImage);
    }
    if (message.transElemInfo !== undefined) {
      obj.transElemInfo = TransElem.toJSON(message.transElemInfo);
    }
    if (message.marketFace !== undefined) {
      obj.marketFace = MarketFace.toJSON(message.marketFace);
    }
    if (message.elemFlags !== undefined) {
      obj.elemFlags = ElemFlags.toJSON(message.elemFlags);
    }
    if (message.customFace !== undefined) {
      obj.customFace = CustomFace.toJSON(message.customFace);
    }
    if (message.elemFlags2 !== undefined) {
      obj.elemFlags2 = ElemFlags2.toJSON(message.elemFlags2);
    }
    if (message.funFace !== undefined) {
      obj.funFace = FunFace.toJSON(message.funFace);
    }
    if (message.secretFile !== undefined) {
      obj.secretFile = SecretFileMsg.toJSON(message.secretFile);
    }
    if (message.richMsg !== undefined) {
      obj.richMsg = RichMsg.toJSON(message.richMsg);
    }
    if (message.groupFile !== undefined) {
      obj.groupFile = GroupFile.toJSON(message.groupFile);
    }
    if (message.pubGroup !== undefined) {
      obj.pubGroup = PubGroup.toJSON(message.pubGroup);
    }
    if (message.marketTrans !== undefined) {
      obj.marketTrans = MarketTrans.toJSON(message.marketTrans);
    }
    if (message.extraInfo !== undefined) {
      obj.extraInfo = ExtraInfo.toJSON(message.extraInfo);
    }
    if (message.shakeWindow !== undefined) {
      obj.shakeWindow = ShakeWindow.toJSON(message.shakeWindow);
    }
    if (message.pubAccount !== undefined) {
      obj.pubAccount = PubAccount.toJSON(message.pubAccount);
    }
    if (message.videoFile !== undefined) {
      obj.videoFile = VideoFile.toJSON(message.videoFile);
    }
    if (message.tipsInfo !== undefined) {
      obj.tipsInfo = TipsInfo.toJSON(message.tipsInfo);
    }
    if (message.anonGroupMsg !== undefined) {
      obj.anonGroupMsg = AnonymousGroupMsg.toJSON(message.anonGroupMsg);
    }
    if (message.qqLiveOld !== undefined) {
      obj.qqLiveOld = QQLiveOld.toJSON(message.qqLiveOld);
    }
    if (message.lifeOnline !== undefined) {
      obj.lifeOnline = LifeOnlineAccount.toJSON(message.lifeOnline);
    }
    if (message.qqwalletMsg !== undefined) {
      obj.qqwalletMsg = QQWalletMsg.toJSON(message.qqwalletMsg);
    }
    if (message.crmElem !== undefined) {
      obj.crmElem = CrmElem.toJSON(message.crmElem);
    }
    if (message.conferenceTipsInfo !== undefined) {
      obj.conferenceTipsInfo = ConferenceTipsInfo.toJSON(message.conferenceTipsInfo);
    }
    if (message.redbagInfo !== undefined) {
      obj.redbagInfo = RedBagInfo.toJSON(message.redbagInfo);
    }
    if (message.lowVersionTips !== undefined) {
      obj.lowVersionTips = LowVersionTips.toJSON(message.lowVersionTips);
    }
    if (message.bankcodeCtrlInfo !== undefined && message.bankcodeCtrlInfo.length !== 0) {
      obj.bankcodeCtrlInfo = base64FromBytes(message.bankcodeCtrlInfo);
    }
    if (message.nearByMsg !== undefined) {
      obj.nearByMsg = NearByMessageType.toJSON(message.nearByMsg);
    }
    if (message.customElem !== undefined) {
      obj.customElem = CustomElem.toJSON(message.customElem);
    }
    if (message.locationInfo !== undefined) {
      obj.locationInfo = LocationInfo.toJSON(message.locationInfo);
    }
    if (message.pubAccInfo !== undefined) {
      obj.pubAccInfo = PubAccInfo.toJSON(message.pubAccInfo);
    }
    if (message.smallEmoji !== undefined) {
      obj.smallEmoji = SmallEmoji.toJSON(message.smallEmoji);
    }
    if (message.fsjMsgElem !== undefined) {
      obj.fsjMsgElem = FSJMessageElem.toJSON(message.fsjMsgElem);
    }
    if (message.arkApp !== undefined) {
      obj.arkApp = ArkAppElem.toJSON(message.arkApp);
    }
    if (message.generalFlags !== undefined) {
      obj.generalFlags = GeneralFlags.toJSON(message.generalFlags);
    }
    if (message.hcFlashPic !== undefined) {
      obj.hcFlashPic = CustomFace.toJSON(message.hcFlashPic);
    }
    if (message.deliverGiftMsg !== undefined) {
      obj.deliverGiftMsg = DeliverGiftMsg.toJSON(message.deliverGiftMsg);
    }
    if (message.bitappMsg !== undefined) {
      obj.bitappMsg = BitAppMsg.toJSON(message.bitappMsg);
    }
    if (message.openQqData !== undefined) {
      obj.openQqData = OpenQQData.toJSON(message.openQqData);
    }
    if (message.apolloMsg !== undefined) {
      obj.apolloMsg = ApolloActMsg.toJSON(message.apolloMsg);
    }
    if (message.groupPubAccInfo !== undefined) {
      obj.groupPubAccInfo = GroupPubAccountInfo.toJSON(message.groupPubAccInfo);
    }
    if (message.blessMsg !== undefined) {
      obj.blessMsg = BlessingMessage.toJSON(message.blessMsg);
    }
    if (message.srcMsg !== undefined) {
      obj.srcMsg = SourceMsg.toJSON(message.srcMsg);
    }
    if (message.lolaMsg !== undefined) {
      obj.lolaMsg = LolaMsg.toJSON(message.lolaMsg);
    }
    if (message.groupBusinessMsg !== undefined) {
      obj.groupBusinessMsg = GroupBusinessMsg.toJSON(message.groupBusinessMsg);
    }
    if (message.msgWorkflowNotify !== undefined) {
      obj.msgWorkflowNotify = WorkflowNotifyMsg.toJSON(message.msgWorkflowNotify);
    }
    if (message.patElem !== undefined) {
      obj.patElem = PatsElem.toJSON(message.patElem);
    }
    if (message.groupPostElem !== undefined) {
      obj.groupPostElem = GroupPostElem.toJSON(message.groupPostElem);
    }
    if (message.lightApp !== undefined) {
      obj.lightApp = LightAppElem.toJSON(message.lightApp);
    }
    if (message.eimInfo !== undefined) {
      obj.eimInfo = EIMInfo.toJSON(message.eimInfo);
    }
    if (message.commonElem !== undefined) {
      obj.commonElem = CommonElem.toJSON(message.commonElem);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Elem>, I>>(base?: I): Elem {
    return Elem.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Elem>, I>>(object: I): Elem {
    const message = createBaseElem();
    message.text = (object.text !== undefined && object.text !== null) ? Text.fromPartial(object.text) : undefined;
    message.face = (object.face !== undefined && object.face !== null) ? Face.fromPartial(object.face) : undefined;
    message.onlineImage = (object.onlineImage !== undefined && object.onlineImage !== null)
      ? OnlineImage.fromPartial(object.onlineImage)
      : undefined;
    message.notOnlineImage = (object.notOnlineImage !== undefined && object.notOnlineImage !== null)
      ? NotOnlineImage.fromPartial(object.notOnlineImage)
      : undefined;
    message.transElemInfo = (object.transElemInfo !== undefined && object.transElemInfo !== null)
      ? TransElem.fromPartial(object.transElemInfo)
      : undefined;
    message.marketFace = (object.marketFace !== undefined && object.marketFace !== null)
      ? MarketFace.fromPartial(object.marketFace)
      : undefined;
    message.elemFlags = (object.elemFlags !== undefined && object.elemFlags !== null)
      ? ElemFlags.fromPartial(object.elemFlags)
      : undefined;
    message.customFace = (object.customFace !== undefined && object.customFace !== null)
      ? CustomFace.fromPartial(object.customFace)
      : undefined;
    message.elemFlags2 = (object.elemFlags2 !== undefined && object.elemFlags2 !== null)
      ? ElemFlags2.fromPartial(object.elemFlags2)
      : undefined;
    message.funFace = (object.funFace !== undefined && object.funFace !== null)
      ? FunFace.fromPartial(object.funFace)
      : undefined;
    message.secretFile = (object.secretFile !== undefined && object.secretFile !== null)
      ? SecretFileMsg.fromPartial(object.secretFile)
      : undefined;
    message.richMsg = (object.richMsg !== undefined && object.richMsg !== null)
      ? RichMsg.fromPartial(object.richMsg)
      : undefined;
    message.groupFile = (object.groupFile !== undefined && object.groupFile !== null)
      ? GroupFile.fromPartial(object.groupFile)
      : undefined;
    message.pubGroup = (object.pubGroup !== undefined && object.pubGroup !== null)
      ? PubGroup.fromPartial(object.pubGroup)
      : undefined;
    message.marketTrans = (object.marketTrans !== undefined && object.marketTrans !== null)
      ? MarketTrans.fromPartial(object.marketTrans)
      : undefined;
    message.extraInfo = (object.extraInfo !== undefined && object.extraInfo !== null)
      ? ExtraInfo.fromPartial(object.extraInfo)
      : undefined;
    message.shakeWindow = (object.shakeWindow !== undefined && object.shakeWindow !== null)
      ? ShakeWindow.fromPartial(object.shakeWindow)
      : undefined;
    message.pubAccount = (object.pubAccount !== undefined && object.pubAccount !== null)
      ? PubAccount.fromPartial(object.pubAccount)
      : undefined;
    message.videoFile = (object.videoFile !== undefined && object.videoFile !== null)
      ? VideoFile.fromPartial(object.videoFile)
      : undefined;
    message.tipsInfo = (object.tipsInfo !== undefined && object.tipsInfo !== null)
      ? TipsInfo.fromPartial(object.tipsInfo)
      : undefined;
    message.anonGroupMsg = (object.anonGroupMsg !== undefined && object.anonGroupMsg !== null)
      ? AnonymousGroupMsg.fromPartial(object.anonGroupMsg)
      : undefined;
    message.qqLiveOld = (object.qqLiveOld !== undefined && object.qqLiveOld !== null)
      ? QQLiveOld.fromPartial(object.qqLiveOld)
      : undefined;
    message.lifeOnline = (object.lifeOnline !== undefined && object.lifeOnline !== null)
      ? LifeOnlineAccount.fromPartial(object.lifeOnline)
      : undefined;
    message.qqwalletMsg = (object.qqwalletMsg !== undefined && object.qqwalletMsg !== null)
      ? QQWalletMsg.fromPartial(object.qqwalletMsg)
      : undefined;
    message.crmElem = (object.crmElem !== undefined && object.crmElem !== null)
      ? CrmElem.fromPartial(object.crmElem)
      : undefined;
    message.conferenceTipsInfo = (object.conferenceTipsInfo !== undefined && object.conferenceTipsInfo !== null)
      ? ConferenceTipsInfo.fromPartial(object.conferenceTipsInfo)
      : undefined;
    message.redbagInfo = (object.redbagInfo !== undefined && object.redbagInfo !== null)
      ? RedBagInfo.fromPartial(object.redbagInfo)
      : undefined;
    message.lowVersionTips = (object.lowVersionTips !== undefined && object.lowVersionTips !== null)
      ? LowVersionTips.fromPartial(object.lowVersionTips)
      : undefined;
    message.bankcodeCtrlInfo = object.bankcodeCtrlInfo ?? new Uint8Array(0);
    message.nearByMsg = (object.nearByMsg !== undefined && object.nearByMsg !== null)
      ? NearByMessageType.fromPartial(object.nearByMsg)
      : undefined;
    message.customElem = (object.customElem !== undefined && object.customElem !== null)
      ? CustomElem.fromPartial(object.customElem)
      : undefined;
    message.locationInfo = (object.locationInfo !== undefined && object.locationInfo !== null)
      ? LocationInfo.fromPartial(object.locationInfo)
      : undefined;
    message.pubAccInfo = (object.pubAccInfo !== undefined && object.pubAccInfo !== null)
      ? PubAccInfo.fromPartial(object.pubAccInfo)
      : undefined;
    message.smallEmoji = (object.smallEmoji !== undefined && object.smallEmoji !== null)
      ? SmallEmoji.fromPartial(object.smallEmoji)
      : undefined;
    message.fsjMsgElem = (object.fsjMsgElem !== undefined && object.fsjMsgElem !== null)
      ? FSJMessageElem.fromPartial(object.fsjMsgElem)
      : undefined;
    message.arkApp = (object.arkApp !== undefined && object.arkApp !== null)
      ? ArkAppElem.fromPartial(object.arkApp)
      : undefined;
    message.generalFlags = (object.generalFlags !== undefined && object.generalFlags !== null)
      ? GeneralFlags.fromPartial(object.generalFlags)
      : undefined;
    message.hcFlashPic = (object.hcFlashPic !== undefined && object.hcFlashPic !== null)
      ? CustomFace.fromPartial(object.hcFlashPic)
      : undefined;
    message.deliverGiftMsg = (object.deliverGiftMsg !== undefined && object.deliverGiftMsg !== null)
      ? DeliverGiftMsg.fromPartial(object.deliverGiftMsg)
      : undefined;
    message.bitappMsg = (object.bitappMsg !== undefined && object.bitappMsg !== null)
      ? BitAppMsg.fromPartial(object.bitappMsg)
      : undefined;
    message.openQqData = (object.openQqData !== undefined && object.openQqData !== null)
      ? OpenQQData.fromPartial(object.openQqData)
      : undefined;
    message.apolloMsg = (object.apolloMsg !== undefined && object.apolloMsg !== null)
      ? ApolloActMsg.fromPartial(object.apolloMsg)
      : undefined;
    message.groupPubAccInfo = (object.groupPubAccInfo !== undefined && object.groupPubAccInfo !== null)
      ? GroupPubAccountInfo.fromPartial(object.groupPubAccInfo)
      : undefined;
    message.blessMsg = (object.blessMsg !== undefined && object.blessMsg !== null)
      ? BlessingMessage.fromPartial(object.blessMsg)
      : undefined;
    message.srcMsg = (object.srcMsg !== undefined && object.srcMsg !== null)
      ? SourceMsg.fromPartial(object.srcMsg)
      : undefined;
    message.lolaMsg = (object.lolaMsg !== undefined && object.lolaMsg !== null)
      ? LolaMsg.fromPartial(object.lolaMsg)
      : undefined;
    message.groupBusinessMsg = (object.groupBusinessMsg !== undefined && object.groupBusinessMsg !== null)
      ? GroupBusinessMsg.fromPartial(object.groupBusinessMsg)
      : undefined;
    message.msgWorkflowNotify = (object.msgWorkflowNotify !== undefined && object.msgWorkflowNotify !== null)
      ? WorkflowNotifyMsg.fromPartial(object.msgWorkflowNotify)
      : undefined;
    message.patElem = (object.patElem !== undefined && object.patElem !== null)
      ? PatsElem.fromPartial(object.patElem)
      : undefined;
    message.groupPostElem = (object.groupPostElem !== undefined && object.groupPostElem !== null)
      ? GroupPostElem.fromPartial(object.groupPostElem)
      : undefined;
    message.lightApp = (object.lightApp !== undefined && object.lightApp !== null)
      ? LightAppElem.fromPartial(object.lightApp)
      : undefined;
    message.eimInfo = (object.eimInfo !== undefined && object.eimInfo !== null)
      ? EIMInfo.fromPartial(object.eimInfo)
      : undefined;
    message.commonElem = (object.commonElem !== undefined && object.commonElem !== null)
      ? CommonElem.fromPartial(object.commonElem)
      : undefined;
    return message;
  },
};

function createBaseCommonElem(): CommonElem {
  return { uint32ServiceType: 0, bytesPbElem: new Uint8Array(0), uint32BusinessType: 0 };
}

export const CommonElem: MessageFns<CommonElem> = {
  encode(message: CommonElem, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.uint32ServiceType !== 0) {
      writer.uint32(8).uint32(message.uint32ServiceType);
    }
    if (message.bytesPbElem !== undefined && message.bytesPbElem.length !== 0) {
      writer.uint32(18).bytes(message.bytesPbElem);
    }
    if (message.uint32BusinessType !== undefined && message.uint32BusinessType !== 0) {
      writer.uint32(24).uint32(message.uint32BusinessType);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CommonElem {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCommonElem();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.uint32ServiceType = reader.uint32();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.bytesPbElem = reader.bytes();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.uint32BusinessType = reader.uint32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CommonElem {
    return {
      uint32ServiceType: isSet(object.uint32ServiceType) ? globalThis.Number(object.uint32ServiceType) : 0,
      bytesPbElem: isSet(object.bytesPbElem) ? bytesFromBase64(object.bytesPbElem) : new Uint8Array(0),
      uint32BusinessType: isSet(object.uint32BusinessType) ? globalThis.Number(object.uint32BusinessType) : 0,
    };
  },

  toJSON(message: CommonElem): unknown {
    const obj: any = {};
    if (message.uint32ServiceType !== 0) {
      obj.uint32ServiceType = Math.round(message.uint32ServiceType);
    }
    if (message.bytesPbElem !== undefined && message.bytesPbElem.length !== 0) {
      obj.bytesPbElem = base64FromBytes(message.bytesPbElem);
    }
    if (message.uint32BusinessType !== undefined && message.uint32BusinessType !== 0) {
      obj.uint32BusinessType = Math.round(message.uint32BusinessType);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CommonElem>, I>>(base?: I): CommonElem {
    return CommonElem.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CommonElem>, I>>(object: I): CommonElem {
    const message = createBaseCommonElem();
    message.uint32ServiceType = object.uint32ServiceType ?? 0;
    message.bytesPbElem = object.bytesPbElem ?? new Uint8Array(0);
    message.uint32BusinessType = object.uint32BusinessType ?? 0;
    return message;
  },
};

function createBaseGroupBusinessMsg(): GroupBusinessMsg {
  return {
    uint32Flags: 0,
    bytesHeadUrl: new Uint8Array(0),
    bytesHeadClkUrl: new Uint8Array(0),
    bytesNick: new Uint8Array(0),
    bytesNickColor: new Uint8Array(0),
    bytesRank: new Uint8Array(0),
    bytesRankColor: new Uint8Array(0),
    bytesRankBgcolor: new Uint8Array(0),
  };
}

export const GroupBusinessMsg: MessageFns<GroupBusinessMsg> = {
  encode(message: GroupBusinessMsg, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.uint32Flags !== undefined && message.uint32Flags !== 0) {
      writer.uint32(8).uint32(message.uint32Flags);
    }
    if (message.bytesHeadUrl !== undefined && message.bytesHeadUrl.length !== 0) {
      writer.uint32(18).bytes(message.bytesHeadUrl);
    }
    if (message.bytesHeadClkUrl !== undefined && message.bytesHeadClkUrl.length !== 0) {
      writer.uint32(26).bytes(message.bytesHeadClkUrl);
    }
    if (message.bytesNick !== undefined && message.bytesNick.length !== 0) {
      writer.uint32(34).bytes(message.bytesNick);
    }
    if (message.bytesNickColor !== undefined && message.bytesNickColor.length !== 0) {
      writer.uint32(42).bytes(message.bytesNickColor);
    }
    if (message.bytesRank !== undefined && message.bytesRank.length !== 0) {
      writer.uint32(50).bytes(message.bytesRank);
    }
    if (message.bytesRankColor !== undefined && message.bytesRankColor.length !== 0) {
      writer.uint32(58).bytes(message.bytesRankColor);
    }
    if (message.bytesRankBgcolor !== undefined && message.bytesRankBgcolor.length !== 0) {
      writer.uint32(66).bytes(message.bytesRankBgcolor);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GroupBusinessMsg {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGroupBusinessMsg();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.uint32Flags = reader.uint32();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.bytesHeadUrl = reader.bytes();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.bytesHeadClkUrl = reader.bytes();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.bytesNick = reader.bytes();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.bytesNickColor = reader.bytes();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.bytesRank = reader.bytes();
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.bytesRankColor = reader.bytes();
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.bytesRankBgcolor = reader.bytes();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GroupBusinessMsg {
    return {
      uint32Flags: isSet(object.uint32Flags) ? globalThis.Number(object.uint32Flags) : 0,
      bytesHeadUrl: isSet(object.bytesHeadUrl) ? bytesFromBase64(object.bytesHeadUrl) : new Uint8Array(0),
      bytesHeadClkUrl: isSet(object.bytesHeadClkUrl) ? bytesFromBase64(object.bytesHeadClkUrl) : new Uint8Array(0),
      bytesNick: isSet(object.bytesNick) ? bytesFromBase64(object.bytesNick) : new Uint8Array(0),
      bytesNickColor: isSet(object.bytesNickColor) ? bytesFromBase64(object.bytesNickColor) : new Uint8Array(0),
      bytesRank: isSet(object.bytesRank) ? bytesFromBase64(object.bytesRank) : new Uint8Array(0),
      bytesRankColor: isSet(object.bytesRankColor) ? bytesFromBase64(object.bytesRankColor) : new Uint8Array(0),
      bytesRankBgcolor: isSet(object.bytesRankBgcolor) ? bytesFromBase64(object.bytesRankBgcolor) : new Uint8Array(0),
    };
  },

  toJSON(message: GroupBusinessMsg): unknown {
    const obj: any = {};
    if (message.uint32Flags !== undefined && message.uint32Flags !== 0) {
      obj.uint32Flags = Math.round(message.uint32Flags);
    }
    if (message.bytesHeadUrl !== undefined && message.bytesHeadUrl.length !== 0) {
      obj.bytesHeadUrl = base64FromBytes(message.bytesHeadUrl);
    }
    if (message.bytesHeadClkUrl !== undefined && message.bytesHeadClkUrl.length !== 0) {
      obj.bytesHeadClkUrl = base64FromBytes(message.bytesHeadClkUrl);
    }
    if (message.bytesNick !== undefined && message.bytesNick.length !== 0) {
      obj.bytesNick = base64FromBytes(message.bytesNick);
    }
    if (message.bytesNickColor !== undefined && message.bytesNickColor.length !== 0) {
      obj.bytesNickColor = base64FromBytes(message.bytesNickColor);
    }
    if (message.bytesRank !== undefined && message.bytesRank.length !== 0) {
      obj.bytesRank = base64FromBytes(message.bytesRank);
    }
    if (message.bytesRankColor !== undefined && message.bytesRankColor.length !== 0) {
      obj.bytesRankColor = base64FromBytes(message.bytesRankColor);
    }
    if (message.bytesRankBgcolor !== undefined && message.bytesRankBgcolor.length !== 0) {
      obj.bytesRankBgcolor = base64FromBytes(message.bytesRankBgcolor);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GroupBusinessMsg>, I>>(base?: I): GroupBusinessMsg {
    return GroupBusinessMsg.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GroupBusinessMsg>, I>>(object: I): GroupBusinessMsg {
    const message = createBaseGroupBusinessMsg();
    message.uint32Flags = object.uint32Flags ?? 0;
    message.bytesHeadUrl = object.bytesHeadUrl ?? new Uint8Array(0);
    message.bytesHeadClkUrl = object.bytesHeadClkUrl ?? new Uint8Array(0);
    message.bytesNick = object.bytesNick ?? new Uint8Array(0);
    message.bytesNickColor = object.bytesNickColor ?? new Uint8Array(0);
    message.bytesRank = object.bytesRank ?? new Uint8Array(0);
    message.bytesRankColor = object.bytesRankColor ?? new Uint8Array(0);
    message.bytesRankBgcolor = object.bytesRankBgcolor ?? new Uint8Array(0);
    return message;
  },
};

function createBaseLolaMsg(): LolaMsg {
  return {
    bytesMsgResid: new Uint8Array(0),
    bytesEncodeContent: new Uint8Array(0),
    bytesLongMsgUrl: new Uint8Array(0),
    bytesDownloadKey: new Uint8Array(0),
  };
}

export const LolaMsg: MessageFns<LolaMsg> = {
  encode(message: LolaMsg, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.bytesMsgResid !== undefined && message.bytesMsgResid.length !== 0) {
      writer.uint32(10).bytes(message.bytesMsgResid);
    }
    if (message.bytesEncodeContent !== undefined && message.bytesEncodeContent.length !== 0) {
      writer.uint32(18).bytes(message.bytesEncodeContent);
    }
    if (message.bytesLongMsgUrl !== undefined && message.bytesLongMsgUrl.length !== 0) {
      writer.uint32(26).bytes(message.bytesLongMsgUrl);
    }
    if (message.bytesDownloadKey !== undefined && message.bytesDownloadKey.length !== 0) {
      writer.uint32(34).bytes(message.bytesDownloadKey);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): LolaMsg {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseLolaMsg();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.bytesMsgResid = reader.bytes();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.bytesEncodeContent = reader.bytes();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.bytesLongMsgUrl = reader.bytes();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.bytesDownloadKey = reader.bytes();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): LolaMsg {
    return {
      bytesMsgResid: isSet(object.bytesMsgResid) ? bytesFromBase64(object.bytesMsgResid) : new Uint8Array(0),
      bytesEncodeContent: isSet(object.bytesEncodeContent)
        ? bytesFromBase64(object.bytesEncodeContent)
        : new Uint8Array(0),
      bytesLongMsgUrl: isSet(object.bytesLongMsgUrl) ? bytesFromBase64(object.bytesLongMsgUrl) : new Uint8Array(0),
      bytesDownloadKey: isSet(object.bytesDownloadKey) ? bytesFromBase64(object.bytesDownloadKey) : new Uint8Array(0),
    };
  },

  toJSON(message: LolaMsg): unknown {
    const obj: any = {};
    if (message.bytesMsgResid !== undefined && message.bytesMsgResid.length !== 0) {
      obj.bytesMsgResid = base64FromBytes(message.bytesMsgResid);
    }
    if (message.bytesEncodeContent !== undefined && message.bytesEncodeContent.length !== 0) {
      obj.bytesEncodeContent = base64FromBytes(message.bytesEncodeContent);
    }
    if (message.bytesLongMsgUrl !== undefined && message.bytesLongMsgUrl.length !== 0) {
      obj.bytesLongMsgUrl = base64FromBytes(message.bytesLongMsgUrl);
    }
    if (message.bytesDownloadKey !== undefined && message.bytesDownloadKey.length !== 0) {
      obj.bytesDownloadKey = base64FromBytes(message.bytesDownloadKey);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<LolaMsg>, I>>(base?: I): LolaMsg {
    return LolaMsg.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<LolaMsg>, I>>(object: I): LolaMsg {
    const message = createBaseLolaMsg();
    message.bytesMsgResid = object.bytesMsgResid ?? new Uint8Array(0);
    message.bytesEncodeContent = object.bytesEncodeContent ?? new Uint8Array(0);
    message.bytesLongMsgUrl = object.bytesLongMsgUrl ?? new Uint8Array(0);
    message.bytesDownloadKey = object.bytesDownloadKey ?? new Uint8Array(0);
    return message;
  },
};

function createBaseGroupPubAccountInfo(): GroupPubAccountInfo {
  return { uint64PubAccount: 0 };
}

export const GroupPubAccountInfo: MessageFns<GroupPubAccountInfo> = {
  encode(message: GroupPubAccountInfo, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.uint64PubAccount !== undefined && message.uint64PubAccount !== 0) {
      writer.uint32(8).uint64(message.uint64PubAccount);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GroupPubAccountInfo {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGroupPubAccountInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.uint64PubAccount = longToNumber(reader.uint64());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GroupPubAccountInfo {
    return { uint64PubAccount: isSet(object.uint64PubAccount) ? globalThis.Number(object.uint64PubAccount) : 0 };
  },

  toJSON(message: GroupPubAccountInfo): unknown {
    const obj: any = {};
    if (message.uint64PubAccount !== undefined && message.uint64PubAccount !== 0) {
      obj.uint64PubAccount = Math.round(message.uint64PubAccount);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GroupPubAccountInfo>, I>>(base?: I): GroupPubAccountInfo {
    return GroupPubAccountInfo.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GroupPubAccountInfo>, I>>(object: I): GroupPubAccountInfo {
    const message = createBaseGroupPubAccountInfo();
    message.uint64PubAccount = object.uint64PubAccount ?? 0;
    return message;
  },
};

function createBaseApolloActMsg(): ApolloActMsg {
  return {
    uint32ActionId: 0,
    bytesActionName: new Uint8Array(0),
    bytesActionText: new Uint8Array(0),
    uint32Flag: 0,
    uint32PeerUin: 0,
    uint32SenderTs: 0,
    uint32PeerTs: 0,
    int32SenderStatus: 0,
    int32PeerStatus: 0,
    diytextId: 0,
    diytextContent: new Uint8Array(0),
    inputText: new Uint8Array(0),
    bytesPbReserve: new Uint8Array(0),
  };
}

export const ApolloActMsg: MessageFns<ApolloActMsg> = {
  encode(message: ApolloActMsg, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.uint32ActionId !== undefined && message.uint32ActionId !== 0) {
      writer.uint32(8).uint32(message.uint32ActionId);
    }
    if (message.bytesActionName !== undefined && message.bytesActionName.length !== 0) {
      writer.uint32(18).bytes(message.bytesActionName);
    }
    if (message.bytesActionText !== undefined && message.bytesActionText.length !== 0) {
      writer.uint32(26).bytes(message.bytesActionText);
    }
    if (message.uint32Flag !== undefined && message.uint32Flag !== 0) {
      writer.uint32(32).uint32(message.uint32Flag);
    }
    if (message.uint32PeerUin !== undefined && message.uint32PeerUin !== 0) {
      writer.uint32(40).uint32(message.uint32PeerUin);
    }
    if (message.uint32SenderTs !== undefined && message.uint32SenderTs !== 0) {
      writer.uint32(48).uint32(message.uint32SenderTs);
    }
    if (message.uint32PeerTs !== undefined && message.uint32PeerTs !== 0) {
      writer.uint32(56).uint32(message.uint32PeerTs);
    }
    if (message.int32SenderStatus !== undefined && message.int32SenderStatus !== 0) {
      writer.uint32(64).int32(message.int32SenderStatus);
    }
    if (message.int32PeerStatus !== undefined && message.int32PeerStatus !== 0) {
      writer.uint32(72).int32(message.int32PeerStatus);
    }
    if (message.diytextId !== undefined && message.diytextId !== 0) {
      writer.uint32(80).uint32(message.diytextId);
    }
    if (message.diytextContent !== undefined && message.diytextContent.length !== 0) {
      writer.uint32(90).bytes(message.diytextContent);
    }
    if (message.inputText !== undefined && message.inputText.length !== 0) {
      writer.uint32(98).bytes(message.inputText);
    }
    if (message.bytesPbReserve !== undefined && message.bytesPbReserve.length !== 0) {
      writer.uint32(106).bytes(message.bytesPbReserve);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ApolloActMsg {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseApolloActMsg();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.uint32ActionId = reader.uint32();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.bytesActionName = reader.bytes();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.bytesActionText = reader.bytes();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.uint32Flag = reader.uint32();
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.uint32PeerUin = reader.uint32();
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.uint32SenderTs = reader.uint32();
          continue;
        }
        case 7: {
          if (tag !== 56) {
            break;
          }

          message.uint32PeerTs = reader.uint32();
          continue;
        }
        case 8: {
          if (tag !== 64) {
            break;
          }

          message.int32SenderStatus = reader.int32();
          continue;
        }
        case 9: {
          if (tag !== 72) {
            break;
          }

          message.int32PeerStatus = reader.int32();
          continue;
        }
        case 10: {
          if (tag !== 80) {
            break;
          }

          message.diytextId = reader.uint32();
          continue;
        }
        case 11: {
          if (tag !== 90) {
            break;
          }

          message.diytextContent = reader.bytes();
          continue;
        }
        case 12: {
          if (tag !== 98) {
            break;
          }

          message.inputText = reader.bytes();
          continue;
        }
        case 13: {
          if (tag !== 106) {
            break;
          }

          message.bytesPbReserve = reader.bytes();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ApolloActMsg {
    return {
      uint32ActionId: isSet(object.uint32ActionId) ? globalThis.Number(object.uint32ActionId) : 0,
      bytesActionName: isSet(object.bytesActionName) ? bytesFromBase64(object.bytesActionName) : new Uint8Array(0),
      bytesActionText: isSet(object.bytesActionText) ? bytesFromBase64(object.bytesActionText) : new Uint8Array(0),
      uint32Flag: isSet(object.uint32Flag) ? globalThis.Number(object.uint32Flag) : 0,
      uint32PeerUin: isSet(object.uint32PeerUin) ? globalThis.Number(object.uint32PeerUin) : 0,
      uint32SenderTs: isSet(object.uint32SenderTs) ? globalThis.Number(object.uint32SenderTs) : 0,
      uint32PeerTs: isSet(object.uint32PeerTs) ? globalThis.Number(object.uint32PeerTs) : 0,
      int32SenderStatus: isSet(object.int32SenderStatus) ? globalThis.Number(object.int32SenderStatus) : 0,
      int32PeerStatus: isSet(object.int32PeerStatus) ? globalThis.Number(object.int32PeerStatus) : 0,
      diytextId: isSet(object.diytextId) ? globalThis.Number(object.diytextId) : 0,
      diytextContent: isSet(object.diytextContent) ? bytesFromBase64(object.diytextContent) : new Uint8Array(0),
      inputText: isSet(object.inputText) ? bytesFromBase64(object.inputText) : new Uint8Array(0),
      bytesPbReserve: isSet(object.bytesPbReserve) ? bytesFromBase64(object.bytesPbReserve) : new Uint8Array(0),
    };
  },

  toJSON(message: ApolloActMsg): unknown {
    const obj: any = {};
    if (message.uint32ActionId !== undefined && message.uint32ActionId !== 0) {
      obj.uint32ActionId = Math.round(message.uint32ActionId);
    }
    if (message.bytesActionName !== undefined && message.bytesActionName.length !== 0) {
      obj.bytesActionName = base64FromBytes(message.bytesActionName);
    }
    if (message.bytesActionText !== undefined && message.bytesActionText.length !== 0) {
      obj.bytesActionText = base64FromBytes(message.bytesActionText);
    }
    if (message.uint32Flag !== undefined && message.uint32Flag !== 0) {
      obj.uint32Flag = Math.round(message.uint32Flag);
    }
    if (message.uint32PeerUin !== undefined && message.uint32PeerUin !== 0) {
      obj.uint32PeerUin = Math.round(message.uint32PeerUin);
    }
    if (message.uint32SenderTs !== undefined && message.uint32SenderTs !== 0) {
      obj.uint32SenderTs = Math.round(message.uint32SenderTs);
    }
    if (message.uint32PeerTs !== undefined && message.uint32PeerTs !== 0) {
      obj.uint32PeerTs = Math.round(message.uint32PeerTs);
    }
    if (message.int32SenderStatus !== undefined && message.int32SenderStatus !== 0) {
      obj.int32SenderStatus = Math.round(message.int32SenderStatus);
    }
    if (message.int32PeerStatus !== undefined && message.int32PeerStatus !== 0) {
      obj.int32PeerStatus = Math.round(message.int32PeerStatus);
    }
    if (message.diytextId !== undefined && message.diytextId !== 0) {
      obj.diytextId = Math.round(message.diytextId);
    }
    if (message.diytextContent !== undefined && message.diytextContent.length !== 0) {
      obj.diytextContent = base64FromBytes(message.diytextContent);
    }
    if (message.inputText !== undefined && message.inputText.length !== 0) {
      obj.inputText = base64FromBytes(message.inputText);
    }
    if (message.bytesPbReserve !== undefined && message.bytesPbReserve.length !== 0) {
      obj.bytesPbReserve = base64FromBytes(message.bytesPbReserve);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ApolloActMsg>, I>>(base?: I): ApolloActMsg {
    return ApolloActMsg.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ApolloActMsg>, I>>(object: I): ApolloActMsg {
    const message = createBaseApolloActMsg();
    message.uint32ActionId = object.uint32ActionId ?? 0;
    message.bytesActionName = object.bytesActionName ?? new Uint8Array(0);
    message.bytesActionText = object.bytesActionText ?? new Uint8Array(0);
    message.uint32Flag = object.uint32Flag ?? 0;
    message.uint32PeerUin = object.uint32PeerUin ?? 0;
    message.uint32SenderTs = object.uint32SenderTs ?? 0;
    message.uint32PeerTs = object.uint32PeerTs ?? 0;
    message.int32SenderStatus = object.int32SenderStatus ?? 0;
    message.int32PeerStatus = object.int32PeerStatus ?? 0;
    message.diytextId = object.diytextId ?? 0;
    message.diytextContent = object.diytextContent ?? new Uint8Array(0);
    message.inputText = object.inputText ?? new Uint8Array(0);
    message.bytesPbReserve = object.bytesPbReserve ?? new Uint8Array(0);
    return message;
  },
};

function createBaseText(): Text {
  return {
    str: new Uint8Array(0),
    link: "",
    attr6Buf: new Uint8Array(0),
    attr7Buf: new Uint8Array(0),
    buf: new Uint8Array(0),
    bytesPbReserve: new Uint8Array(0),
  };
}

export const Text: MessageFns<Text> = {
  encode(message: Text, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.str !== undefined && message.str.length !== 0) {
      writer.uint32(10).bytes(message.str);
    }
    if (message.link !== undefined && message.link !== "") {
      writer.uint32(18).string(message.link);
    }
    if (message.attr6Buf !== undefined && message.attr6Buf.length !== 0) {
      writer.uint32(26).bytes(message.attr6Buf);
    }
    if (message.attr7Buf !== undefined && message.attr7Buf.length !== 0) {
      writer.uint32(34).bytes(message.attr7Buf);
    }
    if (message.buf !== undefined && message.buf.length !== 0) {
      writer.uint32(90).bytes(message.buf);
    }
    if (message.bytesPbReserve !== undefined && message.bytesPbReserve.length !== 0) {
      writer.uint32(98).bytes(message.bytesPbReserve);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Text {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseText();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.str = reader.bytes();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.link = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.attr6Buf = reader.bytes();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.attr7Buf = reader.bytes();
          continue;
        }
        case 11: {
          if (tag !== 90) {
            break;
          }

          message.buf = reader.bytes();
          continue;
        }
        case 12: {
          if (tag !== 98) {
            break;
          }

          message.bytesPbReserve = reader.bytes();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Text {
    return {
      str: isSet(object.str) ? bytesFromBase64(object.str) : new Uint8Array(0),
      link: isSet(object.link) ? globalThis.String(object.link) : "",
      attr6Buf: isSet(object.attr6Buf) ? bytesFromBase64(object.attr6Buf) : new Uint8Array(0),
      attr7Buf: isSet(object.attr7Buf) ? bytesFromBase64(object.attr7Buf) : new Uint8Array(0),
      buf: isSet(object.buf) ? bytesFromBase64(object.buf) : new Uint8Array(0),
      bytesPbReserve: isSet(object.bytesPbReserve) ? bytesFromBase64(object.bytesPbReserve) : new Uint8Array(0),
    };
  },

  toJSON(message: Text): unknown {
    const obj: any = {};
    if (message.str !== undefined && message.str.length !== 0) {
      obj.str = base64FromBytes(message.str);
    }
    if (message.link !== undefined && message.link !== "") {
      obj.link = message.link;
    }
    if (message.attr6Buf !== undefined && message.attr6Buf.length !== 0) {
      obj.attr6Buf = base64FromBytes(message.attr6Buf);
    }
    if (message.attr7Buf !== undefined && message.attr7Buf.length !== 0) {
      obj.attr7Buf = base64FromBytes(message.attr7Buf);
    }
    if (message.buf !== undefined && message.buf.length !== 0) {
      obj.buf = base64FromBytes(message.buf);
    }
    if (message.bytesPbReserve !== undefined && message.bytesPbReserve.length !== 0) {
      obj.bytesPbReserve = base64FromBytes(message.bytesPbReserve);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Text>, I>>(base?: I): Text {
    return Text.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Text>, I>>(object: I): Text {
    const message = createBaseText();
    message.str = object.str ?? new Uint8Array(0);
    message.link = object.link ?? "";
    message.attr6Buf = object.attr6Buf ?? new Uint8Array(0);
    message.attr7Buf = object.attr7Buf ?? new Uint8Array(0);
    message.buf = object.buf ?? new Uint8Array(0);
    message.bytesPbReserve = object.bytesPbReserve ?? new Uint8Array(0);
    return message;
  },
};

function createBaseFace(): Face {
  return { index: 0, old: new Uint8Array(0), buf: new Uint8Array(0) };
}

export const Face: MessageFns<Face> = {
  encode(message: Face, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.index !== undefined && message.index !== 0) {
      writer.uint32(8).uint32(message.index);
    }
    if (message.old !== undefined && message.old.length !== 0) {
      writer.uint32(18).bytes(message.old);
    }
    if (message.buf !== undefined && message.buf.length !== 0) {
      writer.uint32(90).bytes(message.buf);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Face {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseFace();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.index = reader.uint32();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.old = reader.bytes();
          continue;
        }
        case 11: {
          if (tag !== 90) {
            break;
          }

          message.buf = reader.bytes();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Face {
    return {
      index: isSet(object.index) ? globalThis.Number(object.index) : 0,
      old: isSet(object.old) ? bytesFromBase64(object.old) : new Uint8Array(0),
      buf: isSet(object.buf) ? bytesFromBase64(object.buf) : new Uint8Array(0),
    };
  },

  toJSON(message: Face): unknown {
    const obj: any = {};
    if (message.index !== undefined && message.index !== 0) {
      obj.index = Math.round(message.index);
    }
    if (message.old !== undefined && message.old.length !== 0) {
      obj.old = base64FromBytes(message.old);
    }
    if (message.buf !== undefined && message.buf.length !== 0) {
      obj.buf = base64FromBytes(message.buf);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Face>, I>>(base?: I): Face {
    return Face.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Face>, I>>(object: I): Face {
    const message = createBaseFace();
    message.index = object.index ?? 0;
    message.old = object.old ?? new Uint8Array(0);
    message.buf = object.buf ?? new Uint8Array(0);
    return message;
  },
};

function createBaseCustomFace(): CustomFace {
  return {
    bytesGuid: new Uint8Array(0),
    strFilePath: "",
    strShortcut: "",
    bytesBuffer: new Uint8Array(0),
    bytesFlag: new Uint8Array(0),
    bytesOldData: new Uint8Array(0),
    uint32FileId: 0,
    uint32ServerIp: 0,
    uint32ServerPort: 0,
    uint32FileType: 0,
    bytesSignature: new Uint8Array(0),
    uint32Useful: 0,
    bytesMd5: new Uint8Array(0),
    strThumbUrl: "",
    strBigUrl: "",
    strOrigUrl: "",
    bizType: 0,
    repeatIndex: 0,
    repeatImage: 0,
    imageType: 0,
    index: 0,
    uint32Width: 0,
    uint32Height: 0,
    uint32Source: 0,
    uint32Size: 0,
    uint32Origin: 0,
    uint32ThumbWidth: 0,
    uint32ThumbHeight: 0,
    uint32ShowLen: 0,
    uint32DownloadLen: 0,
    str400Url: "",
    uint32400Width: 0,
    uint32400Height: 0,
    bytesPbReserve: new Uint8Array(0),
  };
}

export const CustomFace: MessageFns<CustomFace> = {
  encode(message: CustomFace, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.bytesGuid !== undefined && message.bytesGuid.length !== 0) {
      writer.uint32(10).bytes(message.bytesGuid);
    }
    if (message.strFilePath !== undefined && message.strFilePath !== "") {
      writer.uint32(18).string(message.strFilePath);
    }
    if (message.strShortcut !== undefined && message.strShortcut !== "") {
      writer.uint32(26).string(message.strShortcut);
    }
    if (message.bytesBuffer !== undefined && message.bytesBuffer.length !== 0) {
      writer.uint32(34).bytes(message.bytesBuffer);
    }
    if (message.bytesFlag !== undefined && message.bytesFlag.length !== 0) {
      writer.uint32(42).bytes(message.bytesFlag);
    }
    if (message.bytesOldData !== undefined && message.bytesOldData.length !== 0) {
      writer.uint32(50).bytes(message.bytesOldData);
    }
    if (message.uint32FileId !== undefined && message.uint32FileId !== 0) {
      writer.uint32(56).uint32(message.uint32FileId);
    }
    if (message.uint32ServerIp !== undefined && message.uint32ServerIp !== 0) {
      writer.uint32(64).uint32(message.uint32ServerIp);
    }
    if (message.uint32ServerPort !== undefined && message.uint32ServerPort !== 0) {
      writer.uint32(72).uint32(message.uint32ServerPort);
    }
    if (message.uint32FileType !== undefined && message.uint32FileType !== 0) {
      writer.uint32(80).uint32(message.uint32FileType);
    }
    if (message.bytesSignature !== undefined && message.bytesSignature.length !== 0) {
      writer.uint32(90).bytes(message.bytesSignature);
    }
    if (message.uint32Useful !== undefined && message.uint32Useful !== 0) {
      writer.uint32(96).uint32(message.uint32Useful);
    }
    if (message.bytesMd5 !== undefined && message.bytesMd5.length !== 0) {
      writer.uint32(106).bytes(message.bytesMd5);
    }
    if (message.strThumbUrl !== undefined && message.strThumbUrl !== "") {
      writer.uint32(114).string(message.strThumbUrl);
    }
    if (message.strBigUrl !== undefined && message.strBigUrl !== "") {
      writer.uint32(122).string(message.strBigUrl);
    }
    if (message.strOrigUrl !== undefined && message.strOrigUrl !== "") {
      writer.uint32(130).string(message.strOrigUrl);
    }
    if (message.bizType !== undefined && message.bizType !== 0) {
      writer.uint32(136).uint32(message.bizType);
    }
    if (message.repeatIndex !== undefined && message.repeatIndex !== 0) {
      writer.uint32(144).uint32(message.repeatIndex);
    }
    if (message.repeatImage !== undefined && message.repeatImage !== 0) {
      writer.uint32(152).uint32(message.repeatImage);
    }
    if (message.imageType !== undefined && message.imageType !== 0) {
      writer.uint32(160).uint32(message.imageType);
    }
    if (message.index !== undefined && message.index !== 0) {
      writer.uint32(168).uint32(message.index);
    }
    if (message.uint32Width !== undefined && message.uint32Width !== 0) {
      writer.uint32(176).uint32(message.uint32Width);
    }
    if (message.uint32Height !== undefined && message.uint32Height !== 0) {
      writer.uint32(184).uint32(message.uint32Height);
    }
    if (message.uint32Source !== undefined && message.uint32Source !== 0) {
      writer.uint32(192).uint32(message.uint32Source);
    }
    if (message.uint32Size !== undefined && message.uint32Size !== 0) {
      writer.uint32(200).uint32(message.uint32Size);
    }
    if (message.uint32Origin !== undefined && message.uint32Origin !== 0) {
      writer.uint32(208).uint32(message.uint32Origin);
    }
    if (message.uint32ThumbWidth !== undefined && message.uint32ThumbWidth !== 0) {
      writer.uint32(216).uint32(message.uint32ThumbWidth);
    }
    if (message.uint32ThumbHeight !== undefined && message.uint32ThumbHeight !== 0) {
      writer.uint32(224).uint32(message.uint32ThumbHeight);
    }
    if (message.uint32ShowLen !== undefined && message.uint32ShowLen !== 0) {
      writer.uint32(232).uint32(message.uint32ShowLen);
    }
    if (message.uint32DownloadLen !== undefined && message.uint32DownloadLen !== 0) {
      writer.uint32(240).uint32(message.uint32DownloadLen);
    }
    if (message.str400Url !== undefined && message.str400Url !== "") {
      writer.uint32(250).string(message.str400Url);
    }
    if (message.uint32400Width !== undefined && message.uint32400Width !== 0) {
      writer.uint32(256).uint32(message.uint32400Width);
    }
    if (message.uint32400Height !== undefined && message.uint32400Height !== 0) {
      writer.uint32(264).uint32(message.uint32400Height);
    }
    if (message.bytesPbReserve !== undefined && message.bytesPbReserve.length !== 0) {
      writer.uint32(274).bytes(message.bytesPbReserve);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CustomFace {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCustomFace();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.bytesGuid = reader.bytes();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.strFilePath = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.strShortcut = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.bytesBuffer = reader.bytes();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.bytesFlag = reader.bytes();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.bytesOldData = reader.bytes();
          continue;
        }
        case 7: {
          if (tag !== 56) {
            break;
          }

          message.uint32FileId = reader.uint32();
          continue;
        }
        case 8: {
          if (tag !== 64) {
            break;
          }

          message.uint32ServerIp = reader.uint32();
          continue;
        }
        case 9: {
          if (tag !== 72) {
            break;
          }

          message.uint32ServerPort = reader.uint32();
          continue;
        }
        case 10: {
          if (tag !== 80) {
            break;
          }

          message.uint32FileType = reader.uint32();
          continue;
        }
        case 11: {
          if (tag !== 90) {
            break;
          }

          message.bytesSignature = reader.bytes();
          continue;
        }
        case 12: {
          if (tag !== 96) {
            break;
          }

          message.uint32Useful = reader.uint32();
          continue;
        }
        case 13: {
          if (tag !== 106) {
            break;
          }

          message.bytesMd5 = reader.bytes();
          continue;
        }
        case 14: {
          if (tag !== 114) {
            break;
          }

          message.strThumbUrl = reader.string();
          continue;
        }
        case 15: {
          if (tag !== 122) {
            break;
          }

          message.strBigUrl = reader.string();
          continue;
        }
        case 16: {
          if (tag !== 130) {
            break;
          }

          message.strOrigUrl = reader.string();
          continue;
        }
        case 17: {
          if (tag !== 136) {
            break;
          }

          message.bizType = reader.uint32();
          continue;
        }
        case 18: {
          if (tag !== 144) {
            break;
          }

          message.repeatIndex = reader.uint32();
          continue;
        }
        case 19: {
          if (tag !== 152) {
            break;
          }

          message.repeatImage = reader.uint32();
          continue;
        }
        case 20: {
          if (tag !== 160) {
            break;
          }

          message.imageType = reader.uint32();
          continue;
        }
        case 21: {
          if (tag !== 168) {
            break;
          }

          message.index = reader.uint32();
          continue;
        }
        case 22: {
          if (tag !== 176) {
            break;
          }

          message.uint32Width = reader.uint32();
          continue;
        }
        case 23: {
          if (tag !== 184) {
            break;
          }

          message.uint32Height = reader.uint32();
          continue;
        }
        case 24: {
          if (tag !== 192) {
            break;
          }

          message.uint32Source = reader.uint32();
          continue;
        }
        case 25: {
          if (tag !== 200) {
            break;
          }

          message.uint32Size = reader.uint32();
          continue;
        }
        case 26: {
          if (tag !== 208) {
            break;
          }

          message.uint32Origin = reader.uint32();
          continue;
        }
        case 27: {
          if (tag !== 216) {
            break;
          }

          message.uint32ThumbWidth = reader.uint32();
          continue;
        }
        case 28: {
          if (tag !== 224) {
            break;
          }

          message.uint32ThumbHeight = reader.uint32();
          continue;
        }
        case 29: {
          if (tag !== 232) {
            break;
          }

          message.uint32ShowLen = reader.uint32();
          continue;
        }
        case 30: {
          if (tag !== 240) {
            break;
          }

          message.uint32DownloadLen = reader.uint32();
          continue;
        }
        case 31: {
          if (tag !== 250) {
            break;
          }

          message.str400Url = reader.string();
          continue;
        }
        case 32: {
          if (tag !== 256) {
            break;
          }

          message.uint32400Width = reader.uint32();
          continue;
        }
        case 33: {
          if (tag !== 264) {
            break;
          }

          message.uint32400Height = reader.uint32();
          continue;
        }
        case 34: {
          if (tag !== 274) {
            break;
          }

          message.bytesPbReserve = reader.bytes();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CustomFace {
    return {
      bytesGuid: isSet(object.bytesGuid) ? bytesFromBase64(object.bytesGuid) : new Uint8Array(0),
      strFilePath: isSet(object.strFilePath) ? globalThis.String(object.strFilePath) : "",
      strShortcut: isSet(object.strShortcut) ? globalThis.String(object.strShortcut) : "",
      bytesBuffer: isSet(object.bytesBuffer) ? bytesFromBase64(object.bytesBuffer) : new Uint8Array(0),
      bytesFlag: isSet(object.bytesFlag) ? bytesFromBase64(object.bytesFlag) : new Uint8Array(0),
      bytesOldData: isSet(object.bytesOldData) ? bytesFromBase64(object.bytesOldData) : new Uint8Array(0),
      uint32FileId: isSet(object.uint32FileId) ? globalThis.Number(object.uint32FileId) : 0,
      uint32ServerIp: isSet(object.uint32ServerIp) ? globalThis.Number(object.uint32ServerIp) : 0,
      uint32ServerPort: isSet(object.uint32ServerPort) ? globalThis.Number(object.uint32ServerPort) : 0,
      uint32FileType: isSet(object.uint32FileType) ? globalThis.Number(object.uint32FileType) : 0,
      bytesSignature: isSet(object.bytesSignature) ? bytesFromBase64(object.bytesSignature) : new Uint8Array(0),
      uint32Useful: isSet(object.uint32Useful) ? globalThis.Number(object.uint32Useful) : 0,
      bytesMd5: isSet(object.bytesMd5) ? bytesFromBase64(object.bytesMd5) : new Uint8Array(0),
      strThumbUrl: isSet(object.strThumbUrl) ? globalThis.String(object.strThumbUrl) : "",
      strBigUrl: isSet(object.strBigUrl) ? globalThis.String(object.strBigUrl) : "",
      strOrigUrl: isSet(object.strOrigUrl) ? globalThis.String(object.strOrigUrl) : "",
      bizType: isSet(object.bizType) ? globalThis.Number(object.bizType) : 0,
      repeatIndex: isSet(object.repeatIndex) ? globalThis.Number(object.repeatIndex) : 0,
      repeatImage: isSet(object.repeatImage) ? globalThis.Number(object.repeatImage) : 0,
      imageType: isSet(object.imageType) ? globalThis.Number(object.imageType) : 0,
      index: isSet(object.index) ? globalThis.Number(object.index) : 0,
      uint32Width: isSet(object.uint32Width) ? globalThis.Number(object.uint32Width) : 0,
      uint32Height: isSet(object.uint32Height) ? globalThis.Number(object.uint32Height) : 0,
      uint32Source: isSet(object.uint32Source) ? globalThis.Number(object.uint32Source) : 0,
      uint32Size: isSet(object.uint32Size) ? globalThis.Number(object.uint32Size) : 0,
      uint32Origin: isSet(object.uint32Origin) ? globalThis.Number(object.uint32Origin) : 0,
      uint32ThumbWidth: isSet(object.uint32ThumbWidth) ? globalThis.Number(object.uint32ThumbWidth) : 0,
      uint32ThumbHeight: isSet(object.uint32ThumbHeight) ? globalThis.Number(object.uint32ThumbHeight) : 0,
      uint32ShowLen: isSet(object.uint32ShowLen) ? globalThis.Number(object.uint32ShowLen) : 0,
      uint32DownloadLen: isSet(object.uint32DownloadLen) ? globalThis.Number(object.uint32DownloadLen) : 0,
      str400Url: isSet(object.str400Url) ? globalThis.String(object.str400Url) : "",
      uint32400Width: isSet(object.uint32400Width) ? globalThis.Number(object.uint32400Width) : 0,
      uint32400Height: isSet(object.uint32400Height) ? globalThis.Number(object.uint32400Height) : 0,
      bytesPbReserve: isSet(object.bytesPbReserve) ? bytesFromBase64(object.bytesPbReserve) : new Uint8Array(0),
    };
  },

  toJSON(message: CustomFace): unknown {
    const obj: any = {};
    if (message.bytesGuid !== undefined && message.bytesGuid.length !== 0) {
      obj.bytesGuid = base64FromBytes(message.bytesGuid);
    }
    if (message.strFilePath !== undefined && message.strFilePath !== "") {
      obj.strFilePath = message.strFilePath;
    }
    if (message.strShortcut !== undefined && message.strShortcut !== "") {
      obj.strShortcut = message.strShortcut;
    }
    if (message.bytesBuffer !== undefined && message.bytesBuffer.length !== 0) {
      obj.bytesBuffer = base64FromBytes(message.bytesBuffer);
    }
    if (message.bytesFlag !== undefined && message.bytesFlag.length !== 0) {
      obj.bytesFlag = base64FromBytes(message.bytesFlag);
    }
    if (message.bytesOldData !== undefined && message.bytesOldData.length !== 0) {
      obj.bytesOldData = base64FromBytes(message.bytesOldData);
    }
    if (message.uint32FileId !== undefined && message.uint32FileId !== 0) {
      obj.uint32FileId = Math.round(message.uint32FileId);
    }
    if (message.uint32ServerIp !== undefined && message.uint32ServerIp !== 0) {
      obj.uint32ServerIp = Math.round(message.uint32ServerIp);
    }
    if (message.uint32ServerPort !== undefined && message.uint32ServerPort !== 0) {
      obj.uint32ServerPort = Math.round(message.uint32ServerPort);
    }
    if (message.uint32FileType !== undefined && message.uint32FileType !== 0) {
      obj.uint32FileType = Math.round(message.uint32FileType);
    }
    if (message.bytesSignature !== undefined && message.bytesSignature.length !== 0) {
      obj.bytesSignature = base64FromBytes(message.bytesSignature);
    }
    if (message.uint32Useful !== undefined && message.uint32Useful !== 0) {
      obj.uint32Useful = Math.round(message.uint32Useful);
    }
    if (message.bytesMd5 !== undefined && message.bytesMd5.length !== 0) {
      obj.bytesMd5 = base64FromBytes(message.bytesMd5);
    }
    if (message.strThumbUrl !== undefined && message.strThumbUrl !== "") {
      obj.strThumbUrl = message.strThumbUrl;
    }
    if (message.strBigUrl !== undefined && message.strBigUrl !== "") {
      obj.strBigUrl = message.strBigUrl;
    }
    if (message.strOrigUrl !== undefined && message.strOrigUrl !== "") {
      obj.strOrigUrl = message.strOrigUrl;
    }
    if (message.bizType !== undefined && message.bizType !== 0) {
      obj.bizType = Math.round(message.bizType);
    }
    if (message.repeatIndex !== undefined && message.repeatIndex !== 0) {
      obj.repeatIndex = Math.round(message.repeatIndex);
    }
    if (message.repeatImage !== undefined && message.repeatImage !== 0) {
      obj.repeatImage = Math.round(message.repeatImage);
    }
    if (message.imageType !== undefined && message.imageType !== 0) {
      obj.imageType = Math.round(message.imageType);
    }
    if (message.index !== undefined && message.index !== 0) {
      obj.index = Math.round(message.index);
    }
    if (message.uint32Width !== undefined && message.uint32Width !== 0) {
      obj.uint32Width = Math.round(message.uint32Width);
    }
    if (message.uint32Height !== undefined && message.uint32Height !== 0) {
      obj.uint32Height = Math.round(message.uint32Height);
    }
    if (message.uint32Source !== undefined && message.uint32Source !== 0) {
      obj.uint32Source = Math.round(message.uint32Source);
    }
    if (message.uint32Size !== undefined && message.uint32Size !== 0) {
      obj.uint32Size = Math.round(message.uint32Size);
    }
    if (message.uint32Origin !== undefined && message.uint32Origin !== 0) {
      obj.uint32Origin = Math.round(message.uint32Origin);
    }
    if (message.uint32ThumbWidth !== undefined && message.uint32ThumbWidth !== 0) {
      obj.uint32ThumbWidth = Math.round(message.uint32ThumbWidth);
    }
    if (message.uint32ThumbHeight !== undefined && message.uint32ThumbHeight !== 0) {
      obj.uint32ThumbHeight = Math.round(message.uint32ThumbHeight);
    }
    if (message.uint32ShowLen !== undefined && message.uint32ShowLen !== 0) {
      obj.uint32ShowLen = Math.round(message.uint32ShowLen);
    }
    if (message.uint32DownloadLen !== undefined && message.uint32DownloadLen !== 0) {
      obj.uint32DownloadLen = Math.round(message.uint32DownloadLen);
    }
    if (message.str400Url !== undefined && message.str400Url !== "") {
      obj.str400Url = message.str400Url;
    }
    if (message.uint32400Width !== undefined && message.uint32400Width !== 0) {
      obj.uint32400Width = Math.round(message.uint32400Width);
    }
    if (message.uint32400Height !== undefined && message.uint32400Height !== 0) {
      obj.uint32400Height = Math.round(message.uint32400Height);
    }
    if (message.bytesPbReserve !== undefined && message.bytesPbReserve.length !== 0) {
      obj.bytesPbReserve = base64FromBytes(message.bytesPbReserve);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CustomFace>, I>>(base?: I): CustomFace {
    return CustomFace.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CustomFace>, I>>(object: I): CustomFace {
    const message = createBaseCustomFace();
    message.bytesGuid = object.bytesGuid ?? new Uint8Array(0);
    message.strFilePath = object.strFilePath ?? "";
    message.strShortcut = object.strShortcut ?? "";
    message.bytesBuffer = object.bytesBuffer ?? new Uint8Array(0);
    message.bytesFlag = object.bytesFlag ?? new Uint8Array(0);
    message.bytesOldData = object.bytesOldData ?? new Uint8Array(0);
    message.uint32FileId = object.uint32FileId ?? 0;
    message.uint32ServerIp = object.uint32ServerIp ?? 0;
    message.uint32ServerPort = object.uint32ServerPort ?? 0;
    message.uint32FileType = object.uint32FileType ?? 0;
    message.bytesSignature = object.bytesSignature ?? new Uint8Array(0);
    message.uint32Useful = object.uint32Useful ?? 0;
    message.bytesMd5 = object.bytesMd5 ?? new Uint8Array(0);
    message.strThumbUrl = object.strThumbUrl ?? "";
    message.strBigUrl = object.strBigUrl ?? "";
    message.strOrigUrl = object.strOrigUrl ?? "";
    message.bizType = object.bizType ?? 0;
    message.repeatIndex = object.repeatIndex ?? 0;
    message.repeatImage = object.repeatImage ?? 0;
    message.imageType = object.imageType ?? 0;
    message.index = object.index ?? 0;
    message.uint32Width = object.uint32Width ?? 0;
    message.uint32Height = object.uint32Height ?? 0;
    message.uint32Source = object.uint32Source ?? 0;
    message.uint32Size = object.uint32Size ?? 0;
    message.uint32Origin = object.uint32Origin ?? 0;
    message.uint32ThumbWidth = object.uint32ThumbWidth ?? 0;
    message.uint32ThumbHeight = object.uint32ThumbHeight ?? 0;
    message.uint32ShowLen = object.uint32ShowLen ?? 0;
    message.uint32DownloadLen = object.uint32DownloadLen ?? 0;
    message.str400Url = object.str400Url ?? "";
    message.uint32400Width = object.uint32400Width ?? 0;
    message.uint32400Height = object.uint32400Height ?? 0;
    message.bytesPbReserve = object.bytesPbReserve ?? new Uint8Array(0);
    return message;
  },
};

function createBaseMarketFace(): MarketFace {
  return {
    bytesFaceName: new Uint8Array(0),
    uint32ItemType: 0,
    uint32FaceInfo: 0,
    bytesFaceId: new Uint8Array(0),
    uint32TabId: 0,
    uint32SubType: 0,
    bytesKey: new Uint8Array(0),
    bytesParam: new Uint8Array(0),
    uint32MediaType: 0,
    uint32ImageWidth: 0,
    uint32ImageHeight: 0,
    bytesMobileparam: new Uint8Array(0),
    bytesPbReserve: new Uint8Array(0),
  };
}

export const MarketFace: MessageFns<MarketFace> = {
  encode(message: MarketFace, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.bytesFaceName !== undefined && message.bytesFaceName.length !== 0) {
      writer.uint32(10).bytes(message.bytesFaceName);
    }
    if (message.uint32ItemType !== undefined && message.uint32ItemType !== 0) {
      writer.uint32(16).uint32(message.uint32ItemType);
    }
    if (message.uint32FaceInfo !== undefined && message.uint32FaceInfo !== 0) {
      writer.uint32(24).uint32(message.uint32FaceInfo);
    }
    if (message.bytesFaceId !== undefined && message.bytesFaceId.length !== 0) {
      writer.uint32(34).bytes(message.bytesFaceId);
    }
    if (message.uint32TabId !== undefined && message.uint32TabId !== 0) {
      writer.uint32(40).uint32(message.uint32TabId);
    }
    if (message.uint32SubType !== undefined && message.uint32SubType !== 0) {
      writer.uint32(48).uint32(message.uint32SubType);
    }
    if (message.bytesKey !== undefined && message.bytesKey.length !== 0) {
      writer.uint32(58).bytes(message.bytesKey);
    }
    if (message.bytesParam !== undefined && message.bytesParam.length !== 0) {
      writer.uint32(66).bytes(message.bytesParam);
    }
    if (message.uint32MediaType !== undefined && message.uint32MediaType !== 0) {
      writer.uint32(72).uint32(message.uint32MediaType);
    }
    if (message.uint32ImageWidth !== undefined && message.uint32ImageWidth !== 0) {
      writer.uint32(80).uint32(message.uint32ImageWidth);
    }
    if (message.uint32ImageHeight !== undefined && message.uint32ImageHeight !== 0) {
      writer.uint32(88).uint32(message.uint32ImageHeight);
    }
    if (message.bytesMobileparam !== undefined && message.bytesMobileparam.length !== 0) {
      writer.uint32(98).bytes(message.bytesMobileparam);
    }
    if (message.bytesPbReserve !== undefined && message.bytesPbReserve.length !== 0) {
      writer.uint32(106).bytes(message.bytesPbReserve);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MarketFace {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMarketFace();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.bytesFaceName = reader.bytes();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.uint32ItemType = reader.uint32();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.uint32FaceInfo = reader.uint32();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.bytesFaceId = reader.bytes();
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.uint32TabId = reader.uint32();
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.uint32SubType = reader.uint32();
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.bytesKey = reader.bytes();
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.bytesParam = reader.bytes();
          continue;
        }
        case 9: {
          if (tag !== 72) {
            break;
          }

          message.uint32MediaType = reader.uint32();
          continue;
        }
        case 10: {
          if (tag !== 80) {
            break;
          }

          message.uint32ImageWidth = reader.uint32();
          continue;
        }
        case 11: {
          if (tag !== 88) {
            break;
          }

          message.uint32ImageHeight = reader.uint32();
          continue;
        }
        case 12: {
          if (tag !== 98) {
            break;
          }

          message.bytesMobileparam = reader.bytes();
          continue;
        }
        case 13: {
          if (tag !== 106) {
            break;
          }

          message.bytesPbReserve = reader.bytes();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MarketFace {
    return {
      bytesFaceName: isSet(object.bytesFaceName) ? bytesFromBase64(object.bytesFaceName) : new Uint8Array(0),
      uint32ItemType: isSet(object.uint32ItemType) ? globalThis.Number(object.uint32ItemType) : 0,
      uint32FaceInfo: isSet(object.uint32FaceInfo) ? globalThis.Number(object.uint32FaceInfo) : 0,
      bytesFaceId: isSet(object.bytesFaceId) ? bytesFromBase64(object.bytesFaceId) : new Uint8Array(0),
      uint32TabId: isSet(object.uint32TabId) ? globalThis.Number(object.uint32TabId) : 0,
      uint32SubType: isSet(object.uint32SubType) ? globalThis.Number(object.uint32SubType) : 0,
      bytesKey: isSet(object.bytesKey) ? bytesFromBase64(object.bytesKey) : new Uint8Array(0),
      bytesParam: isSet(object.bytesParam) ? bytesFromBase64(object.bytesParam) : new Uint8Array(0),
      uint32MediaType: isSet(object.uint32MediaType) ? globalThis.Number(object.uint32MediaType) : 0,
      uint32ImageWidth: isSet(object.uint32ImageWidth) ? globalThis.Number(object.uint32ImageWidth) : 0,
      uint32ImageHeight: isSet(object.uint32ImageHeight) ? globalThis.Number(object.uint32ImageHeight) : 0,
      bytesMobileparam: isSet(object.bytesMobileparam) ? bytesFromBase64(object.bytesMobileparam) : new Uint8Array(0),
      bytesPbReserve: isSet(object.bytesPbReserve) ? bytesFromBase64(object.bytesPbReserve) : new Uint8Array(0),
    };
  },

  toJSON(message: MarketFace): unknown {
    const obj: any = {};
    if (message.bytesFaceName !== undefined && message.bytesFaceName.length !== 0) {
      obj.bytesFaceName = base64FromBytes(message.bytesFaceName);
    }
    if (message.uint32ItemType !== undefined && message.uint32ItemType !== 0) {
      obj.uint32ItemType = Math.round(message.uint32ItemType);
    }
    if (message.uint32FaceInfo !== undefined && message.uint32FaceInfo !== 0) {
      obj.uint32FaceInfo = Math.round(message.uint32FaceInfo);
    }
    if (message.bytesFaceId !== undefined && message.bytesFaceId.length !== 0) {
      obj.bytesFaceId = base64FromBytes(message.bytesFaceId);
    }
    if (message.uint32TabId !== undefined && message.uint32TabId !== 0) {
      obj.uint32TabId = Math.round(message.uint32TabId);
    }
    if (message.uint32SubType !== undefined && message.uint32SubType !== 0) {
      obj.uint32SubType = Math.round(message.uint32SubType);
    }
    if (message.bytesKey !== undefined && message.bytesKey.length !== 0) {
      obj.bytesKey = base64FromBytes(message.bytesKey);
    }
    if (message.bytesParam !== undefined && message.bytesParam.length !== 0) {
      obj.bytesParam = base64FromBytes(message.bytesParam);
    }
    if (message.uint32MediaType !== undefined && message.uint32MediaType !== 0) {
      obj.uint32MediaType = Math.round(message.uint32MediaType);
    }
    if (message.uint32ImageWidth !== undefined && message.uint32ImageWidth !== 0) {
      obj.uint32ImageWidth = Math.round(message.uint32ImageWidth);
    }
    if (message.uint32ImageHeight !== undefined && message.uint32ImageHeight !== 0) {
      obj.uint32ImageHeight = Math.round(message.uint32ImageHeight);
    }
    if (message.bytesMobileparam !== undefined && message.bytesMobileparam.length !== 0) {
      obj.bytesMobileparam = base64FromBytes(message.bytesMobileparam);
    }
    if (message.bytesPbReserve !== undefined && message.bytesPbReserve.length !== 0) {
      obj.bytesPbReserve = base64FromBytes(message.bytesPbReserve);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MarketFace>, I>>(base?: I): MarketFace {
    return MarketFace.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MarketFace>, I>>(object: I): MarketFace {
    const message = createBaseMarketFace();
    message.bytesFaceName = object.bytesFaceName ?? new Uint8Array(0);
    message.uint32ItemType = object.uint32ItemType ?? 0;
    message.uint32FaceInfo = object.uint32FaceInfo ?? 0;
    message.bytesFaceId = object.bytesFaceId ?? new Uint8Array(0);
    message.uint32TabId = object.uint32TabId ?? 0;
    message.uint32SubType = object.uint32SubType ?? 0;
    message.bytesKey = object.bytesKey ?? new Uint8Array(0);
    message.bytesParam = object.bytesParam ?? new Uint8Array(0);
    message.uint32MediaType = object.uint32MediaType ?? 0;
    message.uint32ImageWidth = object.uint32ImageWidth ?? 0;
    message.uint32ImageHeight = object.uint32ImageHeight ?? 0;
    message.bytesMobileparam = object.bytesMobileparam ?? new Uint8Array(0);
    message.bytesPbReserve = object.bytesPbReserve ?? new Uint8Array(0);
    return message;
  },
};

function createBaseOnlineImage(): OnlineImage {
  return { guid: new Uint8Array(0), filePath: new Uint8Array(0), oldVerSendFile: new Uint8Array(0) };
}

export const OnlineImage: MessageFns<OnlineImage> = {
  encode(message: OnlineImage, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.guid !== undefined && message.guid.length !== 0) {
      writer.uint32(10).bytes(message.guid);
    }
    if (message.filePath !== undefined && message.filePath.length !== 0) {
      writer.uint32(18).bytes(message.filePath);
    }
    if (message.oldVerSendFile !== undefined && message.oldVerSendFile.length !== 0) {
      writer.uint32(26).bytes(message.oldVerSendFile);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): OnlineImage {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseOnlineImage();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.guid = reader.bytes();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.filePath = reader.bytes();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.oldVerSendFile = reader.bytes();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): OnlineImage {
    return {
      guid: isSet(object.guid) ? bytesFromBase64(object.guid) : new Uint8Array(0),
      filePath: isSet(object.filePath) ? bytesFromBase64(object.filePath) : new Uint8Array(0),
      oldVerSendFile: isSet(object.oldVerSendFile) ? bytesFromBase64(object.oldVerSendFile) : new Uint8Array(0),
    };
  },

  toJSON(message: OnlineImage): unknown {
    const obj: any = {};
    if (message.guid !== undefined && message.guid.length !== 0) {
      obj.guid = base64FromBytes(message.guid);
    }
    if (message.filePath !== undefined && message.filePath.length !== 0) {
      obj.filePath = base64FromBytes(message.filePath);
    }
    if (message.oldVerSendFile !== undefined && message.oldVerSendFile.length !== 0) {
      obj.oldVerSendFile = base64FromBytes(message.oldVerSendFile);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<OnlineImage>, I>>(base?: I): OnlineImage {
    return OnlineImage.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<OnlineImage>, I>>(object: I): OnlineImage {
    const message = createBaseOnlineImage();
    message.guid = object.guid ?? new Uint8Array(0);
    message.filePath = object.filePath ?? new Uint8Array(0);
    message.oldVerSendFile = object.oldVerSendFile ?? new Uint8Array(0);
    return message;
  },
};

function createBaseNotOnlineImage(): NotOnlineImage {
  return {
    filePath: new Uint8Array(0),
    fileLen: 0,
    downloadPath: new Uint8Array(0),
    oldVerSendFile: new Uint8Array(0),
    imgType: 0,
    previewsImage: new Uint8Array(0),
    picMd5: new Uint8Array(0),
    picHeight: 0,
    picWidth: 0,
    resId: new Uint8Array(0),
    flag: new Uint8Array(0),
    strThumbUrl: "",
    original: 0,
    strBigUrl: "",
    strOrigUrl: "",
    bizType: 0,
    result: 0,
    index: 0,
    opFaceBuf: new Uint8Array(0),
    oldPicMd5: false,
    uint32ThumbWidth: 0,
    uint32ThumbHeight: 0,
    uint32FileId: 0,
    uint32ShowLen: 0,
    uint32DownloadLen: 0,
    str400Url: "",
    uint32400Width: 0,
    uint32400Height: 0,
    bytesPbReserve: new Uint8Array(0),
  };
}

export const NotOnlineImage: MessageFns<NotOnlineImage> = {
  encode(message: NotOnlineImage, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.filePath !== undefined && message.filePath.length !== 0) {
      writer.uint32(10).bytes(message.filePath);
    }
    if (message.fileLen !== undefined && message.fileLen !== 0) {
      writer.uint32(16).uint32(message.fileLen);
    }
    if (message.downloadPath !== undefined && message.downloadPath.length !== 0) {
      writer.uint32(26).bytes(message.downloadPath);
    }
    if (message.oldVerSendFile !== undefined && message.oldVerSendFile.length !== 0) {
      writer.uint32(34).bytes(message.oldVerSendFile);
    }
    if (message.imgType !== undefined && message.imgType !== 0) {
      writer.uint32(40).uint32(message.imgType);
    }
    if (message.previewsImage !== undefined && message.previewsImage.length !== 0) {
      writer.uint32(50).bytes(message.previewsImage);
    }
    if (message.picMd5 !== undefined && message.picMd5.length !== 0) {
      writer.uint32(58).bytes(message.picMd5);
    }
    if (message.picHeight !== undefined && message.picHeight !== 0) {
      writer.uint32(64).uint32(message.picHeight);
    }
    if (message.picWidth !== undefined && message.picWidth !== 0) {
      writer.uint32(72).uint32(message.picWidth);
    }
    if (message.resId !== undefined && message.resId.length !== 0) {
      writer.uint32(82).bytes(message.resId);
    }
    if (message.flag !== undefined && message.flag.length !== 0) {
      writer.uint32(90).bytes(message.flag);
    }
    if (message.strThumbUrl !== undefined && message.strThumbUrl !== "") {
      writer.uint32(98).string(message.strThumbUrl);
    }
    if (message.original !== undefined && message.original !== 0) {
      writer.uint32(104).uint32(message.original);
    }
    if (message.strBigUrl !== undefined && message.strBigUrl !== "") {
      writer.uint32(114).string(message.strBigUrl);
    }
    if (message.strOrigUrl !== undefined && message.strOrigUrl !== "") {
      writer.uint32(122).string(message.strOrigUrl);
    }
    if (message.bizType !== undefined && message.bizType !== 0) {
      writer.uint32(128).uint32(message.bizType);
    }
    if (message.result !== undefined && message.result !== 0) {
      writer.uint32(136).uint32(message.result);
    }
    if (message.index !== undefined && message.index !== 0) {
      writer.uint32(144).uint32(message.index);
    }
    if (message.opFaceBuf !== undefined && message.opFaceBuf.length !== 0) {
      writer.uint32(154).bytes(message.opFaceBuf);
    }
    if (message.oldPicMd5 !== undefined && message.oldPicMd5 !== false) {
      writer.uint32(160).bool(message.oldPicMd5);
    }
    if (message.uint32ThumbWidth !== undefined && message.uint32ThumbWidth !== 0) {
      writer.uint32(168).uint32(message.uint32ThumbWidth);
    }
    if (message.uint32ThumbHeight !== undefined && message.uint32ThumbHeight !== 0) {
      writer.uint32(176).uint32(message.uint32ThumbHeight);
    }
    if (message.uint32FileId !== undefined && message.uint32FileId !== 0) {
      writer.uint32(184).uint32(message.uint32FileId);
    }
    if (message.uint32ShowLen !== undefined && message.uint32ShowLen !== 0) {
      writer.uint32(192).uint32(message.uint32ShowLen);
    }
    if (message.uint32DownloadLen !== undefined && message.uint32DownloadLen !== 0) {
      writer.uint32(200).uint32(message.uint32DownloadLen);
    }
    if (message.str400Url !== undefined && message.str400Url !== "") {
      writer.uint32(210).string(message.str400Url);
    }
    if (message.uint32400Width !== undefined && message.uint32400Width !== 0) {
      writer.uint32(216).uint32(message.uint32400Width);
    }
    if (message.uint32400Height !== undefined && message.uint32400Height !== 0) {
      writer.uint32(224).uint32(message.uint32400Height);
    }
    if (message.bytesPbReserve !== undefined && message.bytesPbReserve.length !== 0) {
      writer.uint32(234).bytes(message.bytesPbReserve);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): NotOnlineImage {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseNotOnlineImage();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.filePath = reader.bytes();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.fileLen = reader.uint32();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.downloadPath = reader.bytes();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.oldVerSendFile = reader.bytes();
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.imgType = reader.uint32();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.previewsImage = reader.bytes();
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.picMd5 = reader.bytes();
          continue;
        }
        case 8: {
          if (tag !== 64) {
            break;
          }

          message.picHeight = reader.uint32();
          continue;
        }
        case 9: {
          if (tag !== 72) {
            break;
          }

          message.picWidth = reader.uint32();
          continue;
        }
        case 10: {
          if (tag !== 82) {
            break;
          }

          message.resId = reader.bytes();
          continue;
        }
        case 11: {
          if (tag !== 90) {
            break;
          }

          message.flag = reader.bytes();
          continue;
        }
        case 12: {
          if (tag !== 98) {
            break;
          }

          message.strThumbUrl = reader.string();
          continue;
        }
        case 13: {
          if (tag !== 104) {
            break;
          }

          message.original = reader.uint32();
          continue;
        }
        case 14: {
          if (tag !== 114) {
            break;
          }

          message.strBigUrl = reader.string();
          continue;
        }
        case 15: {
          if (tag !== 122) {
            break;
          }

          message.strOrigUrl = reader.string();
          continue;
        }
        case 16: {
          if (tag !== 128) {
            break;
          }

          message.bizType = reader.uint32();
          continue;
        }
        case 17: {
          if (tag !== 136) {
            break;
          }

          message.result = reader.uint32();
          continue;
        }
        case 18: {
          if (tag !== 144) {
            break;
          }

          message.index = reader.uint32();
          continue;
        }
        case 19: {
          if (tag !== 154) {
            break;
          }

          message.opFaceBuf = reader.bytes();
          continue;
        }
        case 20: {
          if (tag !== 160) {
            break;
          }

          message.oldPicMd5 = reader.bool();
          continue;
        }
        case 21: {
          if (tag !== 168) {
            break;
          }

          message.uint32ThumbWidth = reader.uint32();
          continue;
        }
        case 22: {
          if (tag !== 176) {
            break;
          }

          message.uint32ThumbHeight = reader.uint32();
          continue;
        }
        case 23: {
          if (tag !== 184) {
            break;
          }

          message.uint32FileId = reader.uint32();
          continue;
        }
        case 24: {
          if (tag !== 192) {
            break;
          }

          message.uint32ShowLen = reader.uint32();
          continue;
        }
        case 25: {
          if (tag !== 200) {
            break;
          }

          message.uint32DownloadLen = reader.uint32();
          continue;
        }
        case 26: {
          if (tag !== 210) {
            break;
          }

          message.str400Url = reader.string();
          continue;
        }
        case 27: {
          if (tag !== 216) {
            break;
          }

          message.uint32400Width = reader.uint32();
          continue;
        }
        case 28: {
          if (tag !== 224) {
            break;
          }

          message.uint32400Height = reader.uint32();
          continue;
        }
        case 29: {
          if (tag !== 234) {
            break;
          }

          message.bytesPbReserve = reader.bytes();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): NotOnlineImage {
    return {
      filePath: isSet(object.filePath) ? bytesFromBase64(object.filePath) : new Uint8Array(0),
      fileLen: isSet(object.fileLen) ? globalThis.Number(object.fileLen) : 0,
      downloadPath: isSet(object.downloadPath) ? bytesFromBase64(object.downloadPath) : new Uint8Array(0),
      oldVerSendFile: isSet(object.oldVerSendFile) ? bytesFromBase64(object.oldVerSendFile) : new Uint8Array(0),
      imgType: isSet(object.imgType) ? globalThis.Number(object.imgType) : 0,
      previewsImage: isSet(object.previewsImage) ? bytesFromBase64(object.previewsImage) : new Uint8Array(0),
      picMd5: isSet(object.picMd5) ? bytesFromBase64(object.picMd5) : new Uint8Array(0),
      picHeight: isSet(object.picHeight) ? globalThis.Number(object.picHeight) : 0,
      picWidth: isSet(object.picWidth) ? globalThis.Number(object.picWidth) : 0,
      resId: isSet(object.resId) ? bytesFromBase64(object.resId) : new Uint8Array(0),
      flag: isSet(object.flag) ? bytesFromBase64(object.flag) : new Uint8Array(0),
      strThumbUrl: isSet(object.strThumbUrl) ? globalThis.String(object.strThumbUrl) : "",
      original: isSet(object.original) ? globalThis.Number(object.original) : 0,
      strBigUrl: isSet(object.strBigUrl) ? globalThis.String(object.strBigUrl) : "",
      strOrigUrl: isSet(object.strOrigUrl) ? globalThis.String(object.strOrigUrl) : "",
      bizType: isSet(object.bizType) ? globalThis.Number(object.bizType) : 0,
      result: isSet(object.result) ? globalThis.Number(object.result) : 0,
      index: isSet(object.index) ? globalThis.Number(object.index) : 0,
      opFaceBuf: isSet(object.opFaceBuf) ? bytesFromBase64(object.opFaceBuf) : new Uint8Array(0),
      oldPicMd5: isSet(object.oldPicMd5) ? globalThis.Boolean(object.oldPicMd5) : false,
      uint32ThumbWidth: isSet(object.uint32ThumbWidth) ? globalThis.Number(object.uint32ThumbWidth) : 0,
      uint32ThumbHeight: isSet(object.uint32ThumbHeight) ? globalThis.Number(object.uint32ThumbHeight) : 0,
      uint32FileId: isSet(object.uint32FileId) ? globalThis.Number(object.uint32FileId) : 0,
      uint32ShowLen: isSet(object.uint32ShowLen) ? globalThis.Number(object.uint32ShowLen) : 0,
      uint32DownloadLen: isSet(object.uint32DownloadLen) ? globalThis.Number(object.uint32DownloadLen) : 0,
      str400Url: isSet(object.str400Url) ? globalThis.String(object.str400Url) : "",
      uint32400Width: isSet(object.uint32400Width) ? globalThis.Number(object.uint32400Width) : 0,
      uint32400Height: isSet(object.uint32400Height) ? globalThis.Number(object.uint32400Height) : 0,
      bytesPbReserve: isSet(object.bytesPbReserve) ? bytesFromBase64(object.bytesPbReserve) : new Uint8Array(0),
    };
  },

  toJSON(message: NotOnlineImage): unknown {
    const obj: any = {};
    if (message.filePath !== undefined && message.filePath.length !== 0) {
      obj.filePath = base64FromBytes(message.filePath);
    }
    if (message.fileLen !== undefined && message.fileLen !== 0) {
      obj.fileLen = Math.round(message.fileLen);
    }
    if (message.downloadPath !== undefined && message.downloadPath.length !== 0) {
      obj.downloadPath = base64FromBytes(message.downloadPath);
    }
    if (message.oldVerSendFile !== undefined && message.oldVerSendFile.length !== 0) {
      obj.oldVerSendFile = base64FromBytes(message.oldVerSendFile);
    }
    if (message.imgType !== undefined && message.imgType !== 0) {
      obj.imgType = Math.round(message.imgType);
    }
    if (message.previewsImage !== undefined && message.previewsImage.length !== 0) {
      obj.previewsImage = base64FromBytes(message.previewsImage);
    }
    if (message.picMd5 !== undefined && message.picMd5.length !== 0) {
      obj.picMd5 = base64FromBytes(message.picMd5);
    }
    if (message.picHeight !== undefined && message.picHeight !== 0) {
      obj.picHeight = Math.round(message.picHeight);
    }
    if (message.picWidth !== undefined && message.picWidth !== 0) {
      obj.picWidth = Math.round(message.picWidth);
    }
    if (message.resId !== undefined && message.resId.length !== 0) {
      obj.resId = base64FromBytes(message.resId);
    }
    if (message.flag !== undefined && message.flag.length !== 0) {
      obj.flag = base64FromBytes(message.flag);
    }
    if (message.strThumbUrl !== undefined && message.strThumbUrl !== "") {
      obj.strThumbUrl = message.strThumbUrl;
    }
    if (message.original !== undefined && message.original !== 0) {
      obj.original = Math.round(message.original);
    }
    if (message.strBigUrl !== undefined && message.strBigUrl !== "") {
      obj.strBigUrl = message.strBigUrl;
    }
    if (message.strOrigUrl !== undefined && message.strOrigUrl !== "") {
      obj.strOrigUrl = message.strOrigUrl;
    }
    if (message.bizType !== undefined && message.bizType !== 0) {
      obj.bizType = Math.round(message.bizType);
    }
    if (message.result !== undefined && message.result !== 0) {
      obj.result = Math.round(message.result);
    }
    if (message.index !== undefined && message.index !== 0) {
      obj.index = Math.round(message.index);
    }
    if (message.opFaceBuf !== undefined && message.opFaceBuf.length !== 0) {
      obj.opFaceBuf = base64FromBytes(message.opFaceBuf);
    }
    if (message.oldPicMd5 !== undefined && message.oldPicMd5 !== false) {
      obj.oldPicMd5 = message.oldPicMd5;
    }
    if (message.uint32ThumbWidth !== undefined && message.uint32ThumbWidth !== 0) {
      obj.uint32ThumbWidth = Math.round(message.uint32ThumbWidth);
    }
    if (message.uint32ThumbHeight !== undefined && message.uint32ThumbHeight !== 0) {
      obj.uint32ThumbHeight = Math.round(message.uint32ThumbHeight);
    }
    if (message.uint32FileId !== undefined && message.uint32FileId !== 0) {
      obj.uint32FileId = Math.round(message.uint32FileId);
    }
    if (message.uint32ShowLen !== undefined && message.uint32ShowLen !== 0) {
      obj.uint32ShowLen = Math.round(message.uint32ShowLen);
    }
    if (message.uint32DownloadLen !== undefined && message.uint32DownloadLen !== 0) {
      obj.uint32DownloadLen = Math.round(message.uint32DownloadLen);
    }
    if (message.str400Url !== undefined && message.str400Url !== "") {
      obj.str400Url = message.str400Url;
    }
    if (message.uint32400Width !== undefined && message.uint32400Width !== 0) {
      obj.uint32400Width = Math.round(message.uint32400Width);
    }
    if (message.uint32400Height !== undefined && message.uint32400Height !== 0) {
      obj.uint32400Height = Math.round(message.uint32400Height);
    }
    if (message.bytesPbReserve !== undefined && message.bytesPbReserve.length !== 0) {
      obj.bytesPbReserve = base64FromBytes(message.bytesPbReserve);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<NotOnlineImage>, I>>(base?: I): NotOnlineImage {
    return NotOnlineImage.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<NotOnlineImage>, I>>(object: I): NotOnlineImage {
    const message = createBaseNotOnlineImage();
    message.filePath = object.filePath ?? new Uint8Array(0);
    message.fileLen = object.fileLen ?? 0;
    message.downloadPath = object.downloadPath ?? new Uint8Array(0);
    message.oldVerSendFile = object.oldVerSendFile ?? new Uint8Array(0);
    message.imgType = object.imgType ?? 0;
    message.previewsImage = object.previewsImage ?? new Uint8Array(0);
    message.picMd5 = object.picMd5 ?? new Uint8Array(0);
    message.picHeight = object.picHeight ?? 0;
    message.picWidth = object.picWidth ?? 0;
    message.resId = object.resId ?? new Uint8Array(0);
    message.flag = object.flag ?? new Uint8Array(0);
    message.strThumbUrl = object.strThumbUrl ?? "";
    message.original = object.original ?? 0;
    message.strBigUrl = object.strBigUrl ?? "";
    message.strOrigUrl = object.strOrigUrl ?? "";
    message.bizType = object.bizType ?? 0;
    message.result = object.result ?? 0;
    message.index = object.index ?? 0;
    message.opFaceBuf = object.opFaceBuf ?? new Uint8Array(0);
    message.oldPicMd5 = object.oldPicMd5 ?? false;
    message.uint32ThumbWidth = object.uint32ThumbWidth ?? 0;
    message.uint32ThumbHeight = object.uint32ThumbHeight ?? 0;
    message.uint32FileId = object.uint32FileId ?? 0;
    message.uint32ShowLen = object.uint32ShowLen ?? 0;
    message.uint32DownloadLen = object.uint32DownloadLen ?? 0;
    message.str400Url = object.str400Url ?? "";
    message.uint32400Width = object.uint32400Width ?? 0;
    message.uint32400Height = object.uint32400Height ?? 0;
    message.bytesPbReserve = object.bytesPbReserve ?? new Uint8Array(0);
    return message;
  },
};

function createBaseTransElem(): TransElem {
  return { elemType: 0, elemValue: new Uint8Array(0) };
}

export const TransElem: MessageFns<TransElem> = {
  encode(message: TransElem, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.elemType !== undefined && message.elemType !== 0) {
      writer.uint32(8).uint32(message.elemType);
    }
    if (message.elemValue !== undefined && message.elemValue.length !== 0) {
      writer.uint32(18).bytes(message.elemValue);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): TransElem {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTransElem();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.elemType = reader.uint32();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.elemValue = reader.bytes();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TransElem {
    return {
      elemType: isSet(object.elemType) ? globalThis.Number(object.elemType) : 0,
      elemValue: isSet(object.elemValue) ? bytesFromBase64(object.elemValue) : new Uint8Array(0),
    };
  },

  toJSON(message: TransElem): unknown {
    const obj: any = {};
    if (message.elemType !== undefined && message.elemType !== 0) {
      obj.elemType = Math.round(message.elemType);
    }
    if (message.elemValue !== undefined && message.elemValue.length !== 0) {
      obj.elemValue = base64FromBytes(message.elemValue);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<TransElem>, I>>(base?: I): TransElem {
    return TransElem.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<TransElem>, I>>(object: I): TransElem {
    const message = createBaseTransElem();
    message.elemType = object.elemType ?? 0;
    message.elemValue = object.elemValue ?? new Uint8Array(0);
    return message;
  },
};

function createBaseNotOnlineFile(): NotOnlineFile {
  return {
    uint32FileType: 0,
    bytesSig: new Uint8Array(0),
    bytesFileUuid: new Uint8Array(0),
    bytesFileMd5: new Uint8Array(0),
    bytesFileName: new Uint8Array(0),
    uint64FileSize: 0,
    bytesNote: new Uint8Array(0),
    uint32Reserved: 0,
    uint32Subcmd: 0,
    uint32MicroCloud: 0,
    rptBytesFileUrls: [],
    uint32DownloadFlag: 0,
    uint32DangerEvel: 0,
    uint32LifeTime: 0,
    uint32UploadTime: 0,
    uint32AbsFileType: 0,
    uint32ClientType: 0,
    uint32ExpireTime: 0,
    bytesPbReserve: new Uint8Array(0),
    strFileidcrcMedia: "",
  };
}

export const NotOnlineFile: MessageFns<NotOnlineFile> = {
  encode(message: NotOnlineFile, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.uint32FileType !== undefined && message.uint32FileType !== 0) {
      writer.uint32(8).uint32(message.uint32FileType);
    }
    if (message.bytesSig !== undefined && message.bytesSig.length !== 0) {
      writer.uint32(18).bytes(message.bytesSig);
    }
    if (message.bytesFileUuid !== undefined && message.bytesFileUuid.length !== 0) {
      writer.uint32(26).bytes(message.bytesFileUuid);
    }
    if (message.bytesFileMd5 !== undefined && message.bytesFileMd5.length !== 0) {
      writer.uint32(34).bytes(message.bytesFileMd5);
    }
    if (message.bytesFileName !== undefined && message.bytesFileName.length !== 0) {
      writer.uint32(42).bytes(message.bytesFileName);
    }
    if (message.uint64FileSize !== undefined && message.uint64FileSize !== 0) {
      writer.uint32(48).uint64(message.uint64FileSize);
    }
    if (message.bytesNote !== undefined && message.bytesNote.length !== 0) {
      writer.uint32(58).bytes(message.bytesNote);
    }
    if (message.uint32Reserved !== undefined && message.uint32Reserved !== 0) {
      writer.uint32(64).uint32(message.uint32Reserved);
    }
    if (message.uint32Subcmd !== undefined && message.uint32Subcmd !== 0) {
      writer.uint32(72).uint32(message.uint32Subcmd);
    }
    if (message.uint32MicroCloud !== undefined && message.uint32MicroCloud !== 0) {
      writer.uint32(80).uint32(message.uint32MicroCloud);
    }
    for (const v of message.rptBytesFileUrls) {
      writer.uint32(90).bytes(v!);
    }
    if (message.uint32DownloadFlag !== undefined && message.uint32DownloadFlag !== 0) {
      writer.uint32(96).uint32(message.uint32DownloadFlag);
    }
    if (message.uint32DangerEvel !== undefined && message.uint32DangerEvel !== 0) {
      writer.uint32(400).uint32(message.uint32DangerEvel);
    }
    if (message.uint32LifeTime !== undefined && message.uint32LifeTime !== 0) {
      writer.uint32(408).uint32(message.uint32LifeTime);
    }
    if (message.uint32UploadTime !== undefined && message.uint32UploadTime !== 0) {
      writer.uint32(416).uint32(message.uint32UploadTime);
    }
    if (message.uint32AbsFileType !== undefined && message.uint32AbsFileType !== 0) {
      writer.uint32(424).uint32(message.uint32AbsFileType);
    }
    if (message.uint32ClientType !== undefined && message.uint32ClientType !== 0) {
      writer.uint32(432).uint32(message.uint32ClientType);
    }
    if (message.uint32ExpireTime !== undefined && message.uint32ExpireTime !== 0) {
      writer.uint32(440).uint32(message.uint32ExpireTime);
    }
    if (message.bytesPbReserve !== undefined && message.bytesPbReserve.length !== 0) {
      writer.uint32(450).bytes(message.bytesPbReserve);
    }
    if (message.strFileidcrcMedia !== undefined && message.strFileidcrcMedia !== "") {
      writer.uint32(458).string(message.strFileidcrcMedia);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): NotOnlineFile {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseNotOnlineFile();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.uint32FileType = reader.uint32();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.bytesSig = reader.bytes();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.bytesFileUuid = reader.bytes();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.bytesFileMd5 = reader.bytes();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.bytesFileName = reader.bytes();
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.uint64FileSize = longToNumber(reader.uint64());
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.bytesNote = reader.bytes();
          continue;
        }
        case 8: {
          if (tag !== 64) {
            break;
          }

          message.uint32Reserved = reader.uint32();
          continue;
        }
        case 9: {
          if (tag !== 72) {
            break;
          }

          message.uint32Subcmd = reader.uint32();
          continue;
        }
        case 10: {
          if (tag !== 80) {
            break;
          }

          message.uint32MicroCloud = reader.uint32();
          continue;
        }
        case 11: {
          if (tag !== 90) {
            break;
          }

          message.rptBytesFileUrls.push(reader.bytes());
          continue;
        }
        case 12: {
          if (tag !== 96) {
            break;
          }

          message.uint32DownloadFlag = reader.uint32();
          continue;
        }
        case 50: {
          if (tag !== 400) {
            break;
          }

          message.uint32DangerEvel = reader.uint32();
          continue;
        }
        case 51: {
          if (tag !== 408) {
            break;
          }

          message.uint32LifeTime = reader.uint32();
          continue;
        }
        case 52: {
          if (tag !== 416) {
            break;
          }

          message.uint32UploadTime = reader.uint32();
          continue;
        }
        case 53: {
          if (tag !== 424) {
            break;
          }

          message.uint32AbsFileType = reader.uint32();
          continue;
        }
        case 54: {
          if (tag !== 432) {
            break;
          }

          message.uint32ClientType = reader.uint32();
          continue;
        }
        case 55: {
          if (tag !== 440) {
            break;
          }

          message.uint32ExpireTime = reader.uint32();
          continue;
        }
        case 56: {
          if (tag !== 450) {
            break;
          }

          message.bytesPbReserve = reader.bytes();
          continue;
        }
        case 57: {
          if (tag !== 458) {
            break;
          }

          message.strFileidcrcMedia = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): NotOnlineFile {
    return {
      uint32FileType: isSet(object.uint32FileType) ? globalThis.Number(object.uint32FileType) : 0,
      bytesSig: isSet(object.bytesSig) ? bytesFromBase64(object.bytesSig) : new Uint8Array(0),
      bytesFileUuid: isSet(object.bytesFileUuid) ? bytesFromBase64(object.bytesFileUuid) : new Uint8Array(0),
      bytesFileMd5: isSet(object.bytesFileMd5) ? bytesFromBase64(object.bytesFileMd5) : new Uint8Array(0),
      bytesFileName: isSet(object.bytesFileName) ? bytesFromBase64(object.bytesFileName) : new Uint8Array(0),
      uint64FileSize: isSet(object.uint64FileSize) ? globalThis.Number(object.uint64FileSize) : 0,
      bytesNote: isSet(object.bytesNote) ? bytesFromBase64(object.bytesNote) : new Uint8Array(0),
      uint32Reserved: isSet(object.uint32Reserved) ? globalThis.Number(object.uint32Reserved) : 0,
      uint32Subcmd: isSet(object.uint32Subcmd) ? globalThis.Number(object.uint32Subcmd) : 0,
      uint32MicroCloud: isSet(object.uint32MicroCloud) ? globalThis.Number(object.uint32MicroCloud) : 0,
      rptBytesFileUrls: globalThis.Array.isArray(object?.rptBytesFileUrls)
        ? object.rptBytesFileUrls.map((e: any) => bytesFromBase64(e))
        : [],
      uint32DownloadFlag: isSet(object.uint32DownloadFlag) ? globalThis.Number(object.uint32DownloadFlag) : 0,
      uint32DangerEvel: isSet(object.uint32DangerEvel) ? globalThis.Number(object.uint32DangerEvel) : 0,
      uint32LifeTime: isSet(object.uint32LifeTime) ? globalThis.Number(object.uint32LifeTime) : 0,
      uint32UploadTime: isSet(object.uint32UploadTime) ? globalThis.Number(object.uint32UploadTime) : 0,
      uint32AbsFileType: isSet(object.uint32AbsFileType) ? globalThis.Number(object.uint32AbsFileType) : 0,
      uint32ClientType: isSet(object.uint32ClientType) ? globalThis.Number(object.uint32ClientType) : 0,
      uint32ExpireTime: isSet(object.uint32ExpireTime) ? globalThis.Number(object.uint32ExpireTime) : 0,
      bytesPbReserve: isSet(object.bytesPbReserve) ? bytesFromBase64(object.bytesPbReserve) : new Uint8Array(0),
      strFileidcrcMedia: isSet(object.strFileidcrcMedia) ? globalThis.String(object.strFileidcrcMedia) : "",
    };
  },

  toJSON(message: NotOnlineFile): unknown {
    const obj: any = {};
    if (message.uint32FileType !== undefined && message.uint32FileType !== 0) {
      obj.uint32FileType = Math.round(message.uint32FileType);
    }
    if (message.bytesSig !== undefined && message.bytesSig.length !== 0) {
      obj.bytesSig = base64FromBytes(message.bytesSig);
    }
    if (message.bytesFileUuid !== undefined && message.bytesFileUuid.length !== 0) {
      obj.bytesFileUuid = base64FromBytes(message.bytesFileUuid);
    }
    if (message.bytesFileMd5 !== undefined && message.bytesFileMd5.length !== 0) {
      obj.bytesFileMd5 = base64FromBytes(message.bytesFileMd5);
    }
    if (message.bytesFileName !== undefined && message.bytesFileName.length !== 0) {
      obj.bytesFileName = base64FromBytes(message.bytesFileName);
    }
    if (message.uint64FileSize !== undefined && message.uint64FileSize !== 0) {
      obj.uint64FileSize = Math.round(message.uint64FileSize);
    }
    if (message.bytesNote !== undefined && message.bytesNote.length !== 0) {
      obj.bytesNote = base64FromBytes(message.bytesNote);
    }
    if (message.uint32Reserved !== undefined && message.uint32Reserved !== 0) {
      obj.uint32Reserved = Math.round(message.uint32Reserved);
    }
    if (message.uint32Subcmd !== undefined && message.uint32Subcmd !== 0) {
      obj.uint32Subcmd = Math.round(message.uint32Subcmd);
    }
    if (message.uint32MicroCloud !== undefined && message.uint32MicroCloud !== 0) {
      obj.uint32MicroCloud = Math.round(message.uint32MicroCloud);
    }
    if (message.rptBytesFileUrls?.length) {
      obj.rptBytesFileUrls = message.rptBytesFileUrls.map((e) => base64FromBytes(e));
    }
    if (message.uint32DownloadFlag !== undefined && message.uint32DownloadFlag !== 0) {
      obj.uint32DownloadFlag = Math.round(message.uint32DownloadFlag);
    }
    if (message.uint32DangerEvel !== undefined && message.uint32DangerEvel !== 0) {
      obj.uint32DangerEvel = Math.round(message.uint32DangerEvel);
    }
    if (message.uint32LifeTime !== undefined && message.uint32LifeTime !== 0) {
      obj.uint32LifeTime = Math.round(message.uint32LifeTime);
    }
    if (message.uint32UploadTime !== undefined && message.uint32UploadTime !== 0) {
      obj.uint32UploadTime = Math.round(message.uint32UploadTime);
    }
    if (message.uint32AbsFileType !== undefined && message.uint32AbsFileType !== 0) {
      obj.uint32AbsFileType = Math.round(message.uint32AbsFileType);
    }
    if (message.uint32ClientType !== undefined && message.uint32ClientType !== 0) {
      obj.uint32ClientType = Math.round(message.uint32ClientType);
    }
    if (message.uint32ExpireTime !== undefined && message.uint32ExpireTime !== 0) {
      obj.uint32ExpireTime = Math.round(message.uint32ExpireTime);
    }
    if (message.bytesPbReserve !== undefined && message.bytesPbReserve.length !== 0) {
      obj.bytesPbReserve = base64FromBytes(message.bytesPbReserve);
    }
    if (message.strFileidcrcMedia !== undefined && message.strFileidcrcMedia !== "") {
      obj.strFileidcrcMedia = message.strFileidcrcMedia;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<NotOnlineFile>, I>>(base?: I): NotOnlineFile {
    return NotOnlineFile.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<NotOnlineFile>, I>>(object: I): NotOnlineFile {
    const message = createBaseNotOnlineFile();
    message.uint32FileType = object.uint32FileType ?? 0;
    message.bytesSig = object.bytesSig ?? new Uint8Array(0);
    message.bytesFileUuid = object.bytesFileUuid ?? new Uint8Array(0);
    message.bytesFileMd5 = object.bytesFileMd5 ?? new Uint8Array(0);
    message.bytesFileName = object.bytesFileName ?? new Uint8Array(0);
    message.uint64FileSize = object.uint64FileSize ?? 0;
    message.bytesNote = object.bytesNote ?? new Uint8Array(0);
    message.uint32Reserved = object.uint32Reserved ?? 0;
    message.uint32Subcmd = object.uint32Subcmd ?? 0;
    message.uint32MicroCloud = object.uint32MicroCloud ?? 0;
    message.rptBytesFileUrls = object.rptBytesFileUrls?.map((e) => e) || [];
    message.uint32DownloadFlag = object.uint32DownloadFlag ?? 0;
    message.uint32DangerEvel = object.uint32DangerEvel ?? 0;
    message.uint32LifeTime = object.uint32LifeTime ?? 0;
    message.uint32UploadTime = object.uint32UploadTime ?? 0;
    message.uint32AbsFileType = object.uint32AbsFileType ?? 0;
    message.uint32ClientType = object.uint32ClientType ?? 0;
    message.uint32ExpireTime = object.uint32ExpireTime ?? 0;
    message.bytesPbReserve = object.bytesPbReserve ?? new Uint8Array(0);
    message.strFileidcrcMedia = object.strFileidcrcMedia ?? "";
    return message;
  },
};

function createBasePtt(): Ptt {
  return {
    uint32FileType: 0,
    uint64SrcUin: 0,
    bytesFileUuid: new Uint8Array(0),
    bytesFileMd5: new Uint8Array(0),
    bytesFileName: new Uint8Array(0),
    uint32FileSize: 0,
    bytesReserve: new Uint8Array(0),
    uint32FileId: 0,
    uint32ServerIp: 0,
    uint32ServerPort: 0,
    boolValid: false,
    bytesSignature: new Uint8Array(0),
    bytesShortcut: new Uint8Array(0),
    bytesFileKey: new Uint8Array(0),
    uint32MagicPttIndex: 0,
    uint32VoiceSwitch: 0,
    bytesPttUrl: new Uint8Array(0),
    bytesGroupFileKey: new Uint8Array(0),
    uint32Time: 0,
    bytesDownPara: new Uint8Array(0),
    uint32Format: 0,
    bytesPbReserve: new Uint8Array(0),
    rptBytesPttUrls: [],
    uint32DownloadFlag: 0,
  };
}

export const Ptt: MessageFns<Ptt> = {
  encode(message: Ptt, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.uint32FileType !== undefined && message.uint32FileType !== 0) {
      writer.uint32(8).uint32(message.uint32FileType);
    }
    if (message.uint64SrcUin !== undefined && message.uint64SrcUin !== 0) {
      writer.uint32(16).uint64(message.uint64SrcUin);
    }
    if (message.bytesFileUuid !== undefined && message.bytesFileUuid.length !== 0) {
      writer.uint32(26).bytes(message.bytesFileUuid);
    }
    if (message.bytesFileMd5 !== undefined && message.bytesFileMd5.length !== 0) {
      writer.uint32(34).bytes(message.bytesFileMd5);
    }
    if (message.bytesFileName !== undefined && message.bytesFileName.length !== 0) {
      writer.uint32(42).bytes(message.bytesFileName);
    }
    if (message.uint32FileSize !== undefined && message.uint32FileSize !== 0) {
      writer.uint32(48).uint32(message.uint32FileSize);
    }
    if (message.bytesReserve !== undefined && message.bytesReserve.length !== 0) {
      writer.uint32(58).bytes(message.bytesReserve);
    }
    if (message.uint32FileId !== undefined && message.uint32FileId !== 0) {
      writer.uint32(64).uint32(message.uint32FileId);
    }
    if (message.uint32ServerIp !== undefined && message.uint32ServerIp !== 0) {
      writer.uint32(72).uint32(message.uint32ServerIp);
    }
    if (message.uint32ServerPort !== undefined && message.uint32ServerPort !== 0) {
      writer.uint32(80).uint32(message.uint32ServerPort);
    }
    if (message.boolValid !== undefined && message.boolValid !== false) {
      writer.uint32(88).bool(message.boolValid);
    }
    if (message.bytesSignature !== undefined && message.bytesSignature.length !== 0) {
      writer.uint32(98).bytes(message.bytesSignature);
    }
    if (message.bytesShortcut !== undefined && message.bytesShortcut.length !== 0) {
      writer.uint32(106).bytes(message.bytesShortcut);
    }
    if (message.bytesFileKey !== undefined && message.bytesFileKey.length !== 0) {
      writer.uint32(114).bytes(message.bytesFileKey);
    }
    if (message.uint32MagicPttIndex !== undefined && message.uint32MagicPttIndex !== 0) {
      writer.uint32(120).uint32(message.uint32MagicPttIndex);
    }
    if (message.uint32VoiceSwitch !== undefined && message.uint32VoiceSwitch !== 0) {
      writer.uint32(128).uint32(message.uint32VoiceSwitch);
    }
    if (message.bytesPttUrl !== undefined && message.bytesPttUrl.length !== 0) {
      writer.uint32(138).bytes(message.bytesPttUrl);
    }
    if (message.bytesGroupFileKey !== undefined && message.bytesGroupFileKey.length !== 0) {
      writer.uint32(146).bytes(message.bytesGroupFileKey);
    }
    if (message.uint32Time !== undefined && message.uint32Time !== 0) {
      writer.uint32(152).uint32(message.uint32Time);
    }
    if (message.bytesDownPara !== undefined && message.bytesDownPara.length !== 0) {
      writer.uint32(162).bytes(message.bytesDownPara);
    }
    if (message.uint32Format !== undefined && message.uint32Format !== 0) {
      writer.uint32(232).uint32(message.uint32Format);
    }
    if (message.bytesPbReserve !== undefined && message.bytesPbReserve.length !== 0) {
      writer.uint32(242).bytes(message.bytesPbReserve);
    }
    for (const v of message.rptBytesPttUrls) {
      writer.uint32(250).bytes(v!);
    }
    if (message.uint32DownloadFlag !== undefined && message.uint32DownloadFlag !== 0) {
      writer.uint32(256).uint32(message.uint32DownloadFlag);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Ptt {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePtt();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.uint32FileType = reader.uint32();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.uint64SrcUin = longToNumber(reader.uint64());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.bytesFileUuid = reader.bytes();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.bytesFileMd5 = reader.bytes();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.bytesFileName = reader.bytes();
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.uint32FileSize = reader.uint32();
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.bytesReserve = reader.bytes();
          continue;
        }
        case 8: {
          if (tag !== 64) {
            break;
          }

          message.uint32FileId = reader.uint32();
          continue;
        }
        case 9: {
          if (tag !== 72) {
            break;
          }

          message.uint32ServerIp = reader.uint32();
          continue;
        }
        case 10: {
          if (tag !== 80) {
            break;
          }

          message.uint32ServerPort = reader.uint32();
          continue;
        }
        case 11: {
          if (tag !== 88) {
            break;
          }

          message.boolValid = reader.bool();
          continue;
        }
        case 12: {
          if (tag !== 98) {
            break;
          }

          message.bytesSignature = reader.bytes();
          continue;
        }
        case 13: {
          if (tag !== 106) {
            break;
          }

          message.bytesShortcut = reader.bytes();
          continue;
        }
        case 14: {
          if (tag !== 114) {
            break;
          }

          message.bytesFileKey = reader.bytes();
          continue;
        }
        case 15: {
          if (tag !== 120) {
            break;
          }

          message.uint32MagicPttIndex = reader.uint32();
          continue;
        }
        case 16: {
          if (tag !== 128) {
            break;
          }

          message.uint32VoiceSwitch = reader.uint32();
          continue;
        }
        case 17: {
          if (tag !== 138) {
            break;
          }

          message.bytesPttUrl = reader.bytes();
          continue;
        }
        case 18: {
          if (tag !== 146) {
            break;
          }

          message.bytesGroupFileKey = reader.bytes();
          continue;
        }
        case 19: {
          if (tag !== 152) {
            break;
          }

          message.uint32Time = reader.uint32();
          continue;
        }
        case 20: {
          if (tag !== 162) {
            break;
          }

          message.bytesDownPara = reader.bytes();
          continue;
        }
        case 29: {
          if (tag !== 232) {
            break;
          }

          message.uint32Format = reader.uint32();
          continue;
        }
        case 30: {
          if (tag !== 242) {
            break;
          }

          message.bytesPbReserve = reader.bytes();
          continue;
        }
        case 31: {
          if (tag !== 250) {
            break;
          }

          message.rptBytesPttUrls.push(reader.bytes());
          continue;
        }
        case 32: {
          if (tag !== 256) {
            break;
          }

          message.uint32DownloadFlag = reader.uint32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Ptt {
    return {
      uint32FileType: isSet(object.uint32FileType) ? globalThis.Number(object.uint32FileType) : 0,
      uint64SrcUin: isSet(object.uint64SrcUin) ? globalThis.Number(object.uint64SrcUin) : 0,
      bytesFileUuid: isSet(object.bytesFileUuid) ? bytesFromBase64(object.bytesFileUuid) : new Uint8Array(0),
      bytesFileMd5: isSet(object.bytesFileMd5) ? bytesFromBase64(object.bytesFileMd5) : new Uint8Array(0),
      bytesFileName: isSet(object.bytesFileName) ? bytesFromBase64(object.bytesFileName) : new Uint8Array(0),
      uint32FileSize: isSet(object.uint32FileSize) ? globalThis.Number(object.uint32FileSize) : 0,
      bytesReserve: isSet(object.bytesReserve) ? bytesFromBase64(object.bytesReserve) : new Uint8Array(0),
      uint32FileId: isSet(object.uint32FileId) ? globalThis.Number(object.uint32FileId) : 0,
      uint32ServerIp: isSet(object.uint32ServerIp) ? globalThis.Number(object.uint32ServerIp) : 0,
      uint32ServerPort: isSet(object.uint32ServerPort) ? globalThis.Number(object.uint32ServerPort) : 0,
      boolValid: isSet(object.boolValid) ? globalThis.Boolean(object.boolValid) : false,
      bytesSignature: isSet(object.bytesSignature) ? bytesFromBase64(object.bytesSignature) : new Uint8Array(0),
      bytesShortcut: isSet(object.bytesShortcut) ? bytesFromBase64(object.bytesShortcut) : new Uint8Array(0),
      bytesFileKey: isSet(object.bytesFileKey) ? bytesFromBase64(object.bytesFileKey) : new Uint8Array(0),
      uint32MagicPttIndex: isSet(object.uint32MagicPttIndex) ? globalThis.Number(object.uint32MagicPttIndex) : 0,
      uint32VoiceSwitch: isSet(object.uint32VoiceSwitch) ? globalThis.Number(object.uint32VoiceSwitch) : 0,
      bytesPttUrl: isSet(object.bytesPttUrl) ? bytesFromBase64(object.bytesPttUrl) : new Uint8Array(0),
      bytesGroupFileKey: isSet(object.bytesGroupFileKey)
        ? bytesFromBase64(object.bytesGroupFileKey)
        : new Uint8Array(0),
      uint32Time: isSet(object.uint32Time) ? globalThis.Number(object.uint32Time) : 0,
      bytesDownPara: isSet(object.bytesDownPara) ? bytesFromBase64(object.bytesDownPara) : new Uint8Array(0),
      uint32Format: isSet(object.uint32Format) ? globalThis.Number(object.uint32Format) : 0,
      bytesPbReserve: isSet(object.bytesPbReserve) ? bytesFromBase64(object.bytesPbReserve) : new Uint8Array(0),
      rptBytesPttUrls: globalThis.Array.isArray(object?.rptBytesPttUrls)
        ? object.rptBytesPttUrls.map((e: any) => bytesFromBase64(e))
        : [],
      uint32DownloadFlag: isSet(object.uint32DownloadFlag) ? globalThis.Number(object.uint32DownloadFlag) : 0,
    };
  },

  toJSON(message: Ptt): unknown {
    const obj: any = {};
    if (message.uint32FileType !== undefined && message.uint32FileType !== 0) {
      obj.uint32FileType = Math.round(message.uint32FileType);
    }
    if (message.uint64SrcUin !== undefined && message.uint64SrcUin !== 0) {
      obj.uint64SrcUin = Math.round(message.uint64SrcUin);
    }
    if (message.bytesFileUuid !== undefined && message.bytesFileUuid.length !== 0) {
      obj.bytesFileUuid = base64FromBytes(message.bytesFileUuid);
    }
    if (message.bytesFileMd5 !== undefined && message.bytesFileMd5.length !== 0) {
      obj.bytesFileMd5 = base64FromBytes(message.bytesFileMd5);
    }
    if (message.bytesFileName !== undefined && message.bytesFileName.length !== 0) {
      obj.bytesFileName = base64FromBytes(message.bytesFileName);
    }
    if (message.uint32FileSize !== undefined && message.uint32FileSize !== 0) {
      obj.uint32FileSize = Math.round(message.uint32FileSize);
    }
    if (message.bytesReserve !== undefined && message.bytesReserve.length !== 0) {
      obj.bytesReserve = base64FromBytes(message.bytesReserve);
    }
    if (message.uint32FileId !== undefined && message.uint32FileId !== 0) {
      obj.uint32FileId = Math.round(message.uint32FileId);
    }
    if (message.uint32ServerIp !== undefined && message.uint32ServerIp !== 0) {
      obj.uint32ServerIp = Math.round(message.uint32ServerIp);
    }
    if (message.uint32ServerPort !== undefined && message.uint32ServerPort !== 0) {
      obj.uint32ServerPort = Math.round(message.uint32ServerPort);
    }
    if (message.boolValid !== undefined && message.boolValid !== false) {
      obj.boolValid = message.boolValid;
    }
    if (message.bytesSignature !== undefined && message.bytesSignature.length !== 0) {
      obj.bytesSignature = base64FromBytes(message.bytesSignature);
    }
    if (message.bytesShortcut !== undefined && message.bytesShortcut.length !== 0) {
      obj.bytesShortcut = base64FromBytes(message.bytesShortcut);
    }
    if (message.bytesFileKey !== undefined && message.bytesFileKey.length !== 0) {
      obj.bytesFileKey = base64FromBytes(message.bytesFileKey);
    }
    if (message.uint32MagicPttIndex !== undefined && message.uint32MagicPttIndex !== 0) {
      obj.uint32MagicPttIndex = Math.round(message.uint32MagicPttIndex);
    }
    if (message.uint32VoiceSwitch !== undefined && message.uint32VoiceSwitch !== 0) {
      obj.uint32VoiceSwitch = Math.round(message.uint32VoiceSwitch);
    }
    if (message.bytesPttUrl !== undefined && message.bytesPttUrl.length !== 0) {
      obj.bytesPttUrl = base64FromBytes(message.bytesPttUrl);
    }
    if (message.bytesGroupFileKey !== undefined && message.bytesGroupFileKey.length !== 0) {
      obj.bytesGroupFileKey = base64FromBytes(message.bytesGroupFileKey);
    }
    if (message.uint32Time !== undefined && message.uint32Time !== 0) {
      obj.uint32Time = Math.round(message.uint32Time);
    }
    if (message.bytesDownPara !== undefined && message.bytesDownPara.length !== 0) {
      obj.bytesDownPara = base64FromBytes(message.bytesDownPara);
    }
    if (message.uint32Format !== undefined && message.uint32Format !== 0) {
      obj.uint32Format = Math.round(message.uint32Format);
    }
    if (message.bytesPbReserve !== undefined && message.bytesPbReserve.length !== 0) {
      obj.bytesPbReserve = base64FromBytes(message.bytesPbReserve);
    }
    if (message.rptBytesPttUrls?.length) {
      obj.rptBytesPttUrls = message.rptBytesPttUrls.map((e) => base64FromBytes(e));
    }
    if (message.uint32DownloadFlag !== undefined && message.uint32DownloadFlag !== 0) {
      obj.uint32DownloadFlag = Math.round(message.uint32DownloadFlag);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Ptt>, I>>(base?: I): Ptt {
    return Ptt.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Ptt>, I>>(object: I): Ptt {
    const message = createBasePtt();
    message.uint32FileType = object.uint32FileType ?? 0;
    message.uint64SrcUin = object.uint64SrcUin ?? 0;
    message.bytesFileUuid = object.bytesFileUuid ?? new Uint8Array(0);
    message.bytesFileMd5 = object.bytesFileMd5 ?? new Uint8Array(0);
    message.bytesFileName = object.bytesFileName ?? new Uint8Array(0);
    message.uint32FileSize = object.uint32FileSize ?? 0;
    message.bytesReserve = object.bytesReserve ?? new Uint8Array(0);
    message.uint32FileId = object.uint32FileId ?? 0;
    message.uint32ServerIp = object.uint32ServerIp ?? 0;
    message.uint32ServerPort = object.uint32ServerPort ?? 0;
    message.boolValid = object.boolValid ?? false;
    message.bytesSignature = object.bytesSignature ?? new Uint8Array(0);
    message.bytesShortcut = object.bytesShortcut ?? new Uint8Array(0);
    message.bytesFileKey = object.bytesFileKey ?? new Uint8Array(0);
    message.uint32MagicPttIndex = object.uint32MagicPttIndex ?? 0;
    message.uint32VoiceSwitch = object.uint32VoiceSwitch ?? 0;
    message.bytesPttUrl = object.bytesPttUrl ?? new Uint8Array(0);
    message.bytesGroupFileKey = object.bytesGroupFileKey ?? new Uint8Array(0);
    message.uint32Time = object.uint32Time ?? 0;
    message.bytesDownPara = object.bytesDownPara ?? new Uint8Array(0);
    message.uint32Format = object.uint32Format ?? 0;
    message.bytesPbReserve = object.bytesPbReserve ?? new Uint8Array(0);
    message.rptBytesPttUrls = object.rptBytesPttUrls?.map((e) => e) || [];
    message.uint32DownloadFlag = object.uint32DownloadFlag ?? 0;
    return message;
  },
};

function createBaseVideoFile(): VideoFile {
  return {
    bytesFileUuid: new Uint8Array(0),
    bytesFileMd5: new Uint8Array(0),
    bytesFileName: new Uint8Array(0),
    uint32FileFormat: 0,
    uint32FileTime: 0,
    uint32FileSize: 0,
    uint32ThumbWidth: 0,
    uint32ThumbHeight: 0,
    bytesThumbFileMd5: new Uint8Array(0),
    bytesSource: new Uint8Array(0),
    uint32ThumbFileSize: 0,
    uint32BusiType: 0,
    uint32FromChatType: 0,
    uint32ToChatType: 0,
    boolSupportProgressive: false,
    uint32FileWidth: 0,
    uint32FileHeight: 0,
    uint32SubBusiType: 0,
    uint32VideoAttr: 0,
    rptBytesThumbFileUrls: [],
    rptBytesVideoFileUrls: [],
    uint32ThumbDownloadFlag: 0,
    uint32VideoDownloadFlag: 0,
    bytesPbReserve: new Uint8Array(0),
  };
}

export const VideoFile: MessageFns<VideoFile> = {
  encode(message: VideoFile, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.bytesFileUuid !== undefined && message.bytesFileUuid.length !== 0) {
      writer.uint32(10).bytes(message.bytesFileUuid);
    }
    if (message.bytesFileMd5 !== undefined && message.bytesFileMd5.length !== 0) {
      writer.uint32(18).bytes(message.bytesFileMd5);
    }
    if (message.bytesFileName !== undefined && message.bytesFileName.length !== 0) {
      writer.uint32(26).bytes(message.bytesFileName);
    }
    if (message.uint32FileFormat !== undefined && message.uint32FileFormat !== 0) {
      writer.uint32(32).uint32(message.uint32FileFormat);
    }
    if (message.uint32FileTime !== undefined && message.uint32FileTime !== 0) {
      writer.uint32(40).uint32(message.uint32FileTime);
    }
    if (message.uint32FileSize !== undefined && message.uint32FileSize !== 0) {
      writer.uint32(48).uint32(message.uint32FileSize);
    }
    if (message.uint32ThumbWidth !== undefined && message.uint32ThumbWidth !== 0) {
      writer.uint32(56).uint32(message.uint32ThumbWidth);
    }
    if (message.uint32ThumbHeight !== undefined && message.uint32ThumbHeight !== 0) {
      writer.uint32(64).uint32(message.uint32ThumbHeight);
    }
    if (message.bytesThumbFileMd5 !== undefined && message.bytesThumbFileMd5.length !== 0) {
      writer.uint32(74).bytes(message.bytesThumbFileMd5);
    }
    if (message.bytesSource !== undefined && message.bytesSource.length !== 0) {
      writer.uint32(82).bytes(message.bytesSource);
    }
    if (message.uint32ThumbFileSize !== undefined && message.uint32ThumbFileSize !== 0) {
      writer.uint32(88).uint32(message.uint32ThumbFileSize);
    }
    if (message.uint32BusiType !== undefined && message.uint32BusiType !== 0) {
      writer.uint32(96).uint32(message.uint32BusiType);
    }
    if (message.uint32FromChatType !== undefined && message.uint32FromChatType !== 0) {
      writer.uint32(104).uint32(message.uint32FromChatType);
    }
    if (message.uint32ToChatType !== undefined && message.uint32ToChatType !== 0) {
      writer.uint32(112).uint32(message.uint32ToChatType);
    }
    if (message.boolSupportProgressive !== undefined && message.boolSupportProgressive !== false) {
      writer.uint32(120).bool(message.boolSupportProgressive);
    }
    if (message.uint32FileWidth !== undefined && message.uint32FileWidth !== 0) {
      writer.uint32(128).uint32(message.uint32FileWidth);
    }
    if (message.uint32FileHeight !== undefined && message.uint32FileHeight !== 0) {
      writer.uint32(136).uint32(message.uint32FileHeight);
    }
    if (message.uint32SubBusiType !== undefined && message.uint32SubBusiType !== 0) {
      writer.uint32(144).uint32(message.uint32SubBusiType);
    }
    if (message.uint32VideoAttr !== undefined && message.uint32VideoAttr !== 0) {
      writer.uint32(152).uint32(message.uint32VideoAttr);
    }
    for (const v of message.rptBytesThumbFileUrls) {
      writer.uint32(162).bytes(v!);
    }
    for (const v of message.rptBytesVideoFileUrls) {
      writer.uint32(170).bytes(v!);
    }
    if (message.uint32ThumbDownloadFlag !== undefined && message.uint32ThumbDownloadFlag !== 0) {
      writer.uint32(176).uint32(message.uint32ThumbDownloadFlag);
    }
    if (message.uint32VideoDownloadFlag !== undefined && message.uint32VideoDownloadFlag !== 0) {
      writer.uint32(184).uint32(message.uint32VideoDownloadFlag);
    }
    if (message.bytesPbReserve !== undefined && message.bytesPbReserve.length !== 0) {
      writer.uint32(194).bytes(message.bytesPbReserve);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): VideoFile {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseVideoFile();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.bytesFileUuid = reader.bytes();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.bytesFileMd5 = reader.bytes();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.bytesFileName = reader.bytes();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.uint32FileFormat = reader.uint32();
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.uint32FileTime = reader.uint32();
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.uint32FileSize = reader.uint32();
          continue;
        }
        case 7: {
          if (tag !== 56) {
            break;
          }

          message.uint32ThumbWidth = reader.uint32();
          continue;
        }
        case 8: {
          if (tag !== 64) {
            break;
          }

          message.uint32ThumbHeight = reader.uint32();
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.bytesThumbFileMd5 = reader.bytes();
          continue;
        }
        case 10: {
          if (tag !== 82) {
            break;
          }

          message.bytesSource = reader.bytes();
          continue;
        }
        case 11: {
          if (tag !== 88) {
            break;
          }

          message.uint32ThumbFileSize = reader.uint32();
          continue;
        }
        case 12: {
          if (tag !== 96) {
            break;
          }

          message.uint32BusiType = reader.uint32();
          continue;
        }
        case 13: {
          if (tag !== 104) {
            break;
          }

          message.uint32FromChatType = reader.uint32();
          continue;
        }
        case 14: {
          if (tag !== 112) {
            break;
          }

          message.uint32ToChatType = reader.uint32();
          continue;
        }
        case 15: {
          if (tag !== 120) {
            break;
          }

          message.boolSupportProgressive = reader.bool();
          continue;
        }
        case 16: {
          if (tag !== 128) {
            break;
          }

          message.uint32FileWidth = reader.uint32();
          continue;
        }
        case 17: {
          if (tag !== 136) {
            break;
          }

          message.uint32FileHeight = reader.uint32();
          continue;
        }
        case 18: {
          if (tag !== 144) {
            break;
          }

          message.uint32SubBusiType = reader.uint32();
          continue;
        }
        case 19: {
          if (tag !== 152) {
            break;
          }

          message.uint32VideoAttr = reader.uint32();
          continue;
        }
        case 20: {
          if (tag !== 162) {
            break;
          }

          message.rptBytesThumbFileUrls.push(reader.bytes());
          continue;
        }
        case 21: {
          if (tag !== 170) {
            break;
          }

          message.rptBytesVideoFileUrls.push(reader.bytes());
          continue;
        }
        case 22: {
          if (tag !== 176) {
            break;
          }

          message.uint32ThumbDownloadFlag = reader.uint32();
          continue;
        }
        case 23: {
          if (tag !== 184) {
            break;
          }

          message.uint32VideoDownloadFlag = reader.uint32();
          continue;
        }
        case 24: {
          if (tag !== 194) {
            break;
          }

          message.bytesPbReserve = reader.bytes();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): VideoFile {
    return {
      bytesFileUuid: isSet(object.bytesFileUuid) ? bytesFromBase64(object.bytesFileUuid) : new Uint8Array(0),
      bytesFileMd5: isSet(object.bytesFileMd5) ? bytesFromBase64(object.bytesFileMd5) : new Uint8Array(0),
      bytesFileName: isSet(object.bytesFileName) ? bytesFromBase64(object.bytesFileName) : new Uint8Array(0),
      uint32FileFormat: isSet(object.uint32FileFormat) ? globalThis.Number(object.uint32FileFormat) : 0,
      uint32FileTime: isSet(object.uint32FileTime) ? globalThis.Number(object.uint32FileTime) : 0,
      uint32FileSize: isSet(object.uint32FileSize) ? globalThis.Number(object.uint32FileSize) : 0,
      uint32ThumbWidth: isSet(object.uint32ThumbWidth) ? globalThis.Number(object.uint32ThumbWidth) : 0,
      uint32ThumbHeight: isSet(object.uint32ThumbHeight) ? globalThis.Number(object.uint32ThumbHeight) : 0,
      bytesThumbFileMd5: isSet(object.bytesThumbFileMd5)
        ? bytesFromBase64(object.bytesThumbFileMd5)
        : new Uint8Array(0),
      bytesSource: isSet(object.bytesSource) ? bytesFromBase64(object.bytesSource) : new Uint8Array(0),
      uint32ThumbFileSize: isSet(object.uint32ThumbFileSize) ? globalThis.Number(object.uint32ThumbFileSize) : 0,
      uint32BusiType: isSet(object.uint32BusiType) ? globalThis.Number(object.uint32BusiType) : 0,
      uint32FromChatType: isSet(object.uint32FromChatType) ? globalThis.Number(object.uint32FromChatType) : 0,
      uint32ToChatType: isSet(object.uint32ToChatType) ? globalThis.Number(object.uint32ToChatType) : 0,
      boolSupportProgressive: isSet(object.boolSupportProgressive)
        ? globalThis.Boolean(object.boolSupportProgressive)
        : false,
      uint32FileWidth: isSet(object.uint32FileWidth) ? globalThis.Number(object.uint32FileWidth) : 0,
      uint32FileHeight: isSet(object.uint32FileHeight) ? globalThis.Number(object.uint32FileHeight) : 0,
      uint32SubBusiType: isSet(object.uint32SubBusiType) ? globalThis.Number(object.uint32SubBusiType) : 0,
      uint32VideoAttr: isSet(object.uint32VideoAttr) ? globalThis.Number(object.uint32VideoAttr) : 0,
      rptBytesThumbFileUrls: globalThis.Array.isArray(object?.rptBytesThumbFileUrls)
        ? object.rptBytesThumbFileUrls.map((e: any) => bytesFromBase64(e))
        : [],
      rptBytesVideoFileUrls: globalThis.Array.isArray(object?.rptBytesVideoFileUrls)
        ? object.rptBytesVideoFileUrls.map((e: any) => bytesFromBase64(e))
        : [],
      uint32ThumbDownloadFlag: isSet(object.uint32ThumbDownloadFlag)
        ? globalThis.Number(object.uint32ThumbDownloadFlag)
        : 0,
      uint32VideoDownloadFlag: isSet(object.uint32VideoDownloadFlag)
        ? globalThis.Number(object.uint32VideoDownloadFlag)
        : 0,
      bytesPbReserve: isSet(object.bytesPbReserve) ? bytesFromBase64(object.bytesPbReserve) : new Uint8Array(0),
    };
  },

  toJSON(message: VideoFile): unknown {
    const obj: any = {};
    if (message.bytesFileUuid !== undefined && message.bytesFileUuid.length !== 0) {
      obj.bytesFileUuid = base64FromBytes(message.bytesFileUuid);
    }
    if (message.bytesFileMd5 !== undefined && message.bytesFileMd5.length !== 0) {
      obj.bytesFileMd5 = base64FromBytes(message.bytesFileMd5);
    }
    if (message.bytesFileName !== undefined && message.bytesFileName.length !== 0) {
      obj.bytesFileName = base64FromBytes(message.bytesFileName);
    }
    if (message.uint32FileFormat !== undefined && message.uint32FileFormat !== 0) {
      obj.uint32FileFormat = Math.round(message.uint32FileFormat);
    }
    if (message.uint32FileTime !== undefined && message.uint32FileTime !== 0) {
      obj.uint32FileTime = Math.round(message.uint32FileTime);
    }
    if (message.uint32FileSize !== undefined && message.uint32FileSize !== 0) {
      obj.uint32FileSize = Math.round(message.uint32FileSize);
    }
    if (message.uint32ThumbWidth !== undefined && message.uint32ThumbWidth !== 0) {
      obj.uint32ThumbWidth = Math.round(message.uint32ThumbWidth);
    }
    if (message.uint32ThumbHeight !== undefined && message.uint32ThumbHeight !== 0) {
      obj.uint32ThumbHeight = Math.round(message.uint32ThumbHeight);
    }
    if (message.bytesThumbFileMd5 !== undefined && message.bytesThumbFileMd5.length !== 0) {
      obj.bytesThumbFileMd5 = base64FromBytes(message.bytesThumbFileMd5);
    }
    if (message.bytesSource !== undefined && message.bytesSource.length !== 0) {
      obj.bytesSource = base64FromBytes(message.bytesSource);
    }
    if (message.uint32ThumbFileSize !== undefined && message.uint32ThumbFileSize !== 0) {
      obj.uint32ThumbFileSize = Math.round(message.uint32ThumbFileSize);
    }
    if (message.uint32BusiType !== undefined && message.uint32BusiType !== 0) {
      obj.uint32BusiType = Math.round(message.uint32BusiType);
    }
    if (message.uint32FromChatType !== undefined && message.uint32FromChatType !== 0) {
      obj.uint32FromChatType = Math.round(message.uint32FromChatType);
    }
    if (message.uint32ToChatType !== undefined && message.uint32ToChatType !== 0) {
      obj.uint32ToChatType = Math.round(message.uint32ToChatType);
    }
    if (message.boolSupportProgressive !== undefined && message.boolSupportProgressive !== false) {
      obj.boolSupportProgressive = message.boolSupportProgressive;
    }
    if (message.uint32FileWidth !== undefined && message.uint32FileWidth !== 0) {
      obj.uint32FileWidth = Math.round(message.uint32FileWidth);
    }
    if (message.uint32FileHeight !== undefined && message.uint32FileHeight !== 0) {
      obj.uint32FileHeight = Math.round(message.uint32FileHeight);
    }
    if (message.uint32SubBusiType !== undefined && message.uint32SubBusiType !== 0) {
      obj.uint32SubBusiType = Math.round(message.uint32SubBusiType);
    }
    if (message.uint32VideoAttr !== undefined && message.uint32VideoAttr !== 0) {
      obj.uint32VideoAttr = Math.round(message.uint32VideoAttr);
    }
    if (message.rptBytesThumbFileUrls?.length) {
      obj.rptBytesThumbFileUrls = message.rptBytesThumbFileUrls.map((e) => base64FromBytes(e));
    }
    if (message.rptBytesVideoFileUrls?.length) {
      obj.rptBytesVideoFileUrls = message.rptBytesVideoFileUrls.map((e) => base64FromBytes(e));
    }
    if (message.uint32ThumbDownloadFlag !== undefined && message.uint32ThumbDownloadFlag !== 0) {
      obj.uint32ThumbDownloadFlag = Math.round(message.uint32ThumbDownloadFlag);
    }
    if (message.uint32VideoDownloadFlag !== undefined && message.uint32VideoDownloadFlag !== 0) {
      obj.uint32VideoDownloadFlag = Math.round(message.uint32VideoDownloadFlag);
    }
    if (message.bytesPbReserve !== undefined && message.bytesPbReserve.length !== 0) {
      obj.bytesPbReserve = base64FromBytes(message.bytesPbReserve);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<VideoFile>, I>>(base?: I): VideoFile {
    return VideoFile.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<VideoFile>, I>>(object: I): VideoFile {
    const message = createBaseVideoFile();
    message.bytesFileUuid = object.bytesFileUuid ?? new Uint8Array(0);
    message.bytesFileMd5 = object.bytesFileMd5 ?? new Uint8Array(0);
    message.bytesFileName = object.bytesFileName ?? new Uint8Array(0);
    message.uint32FileFormat = object.uint32FileFormat ?? 0;
    message.uint32FileTime = object.uint32FileTime ?? 0;
    message.uint32FileSize = object.uint32FileSize ?? 0;
    message.uint32ThumbWidth = object.uint32ThumbWidth ?? 0;
    message.uint32ThumbHeight = object.uint32ThumbHeight ?? 0;
    message.bytesThumbFileMd5 = object.bytesThumbFileMd5 ?? new Uint8Array(0);
    message.bytesSource = object.bytesSource ?? new Uint8Array(0);
    message.uint32ThumbFileSize = object.uint32ThumbFileSize ?? 0;
    message.uint32BusiType = object.uint32BusiType ?? 0;
    message.uint32FromChatType = object.uint32FromChatType ?? 0;
    message.uint32ToChatType = object.uint32ToChatType ?? 0;
    message.boolSupportProgressive = object.boolSupportProgressive ?? false;
    message.uint32FileWidth = object.uint32FileWidth ?? 0;
    message.uint32FileHeight = object.uint32FileHeight ?? 0;
    message.uint32SubBusiType = object.uint32SubBusiType ?? 0;
    message.uint32VideoAttr = object.uint32VideoAttr ?? 0;
    message.rptBytesThumbFileUrls = object.rptBytesThumbFileUrls?.map((e) => e) || [];
    message.rptBytesVideoFileUrls = object.rptBytesVideoFileUrls?.map((e) => e) || [];
    message.uint32ThumbDownloadFlag = object.uint32ThumbDownloadFlag ?? 0;
    message.uint32VideoDownloadFlag = object.uint32VideoDownloadFlag ?? 0;
    message.bytesPbReserve = object.bytesPbReserve ?? new Uint8Array(0);
    return message;
  },
};

function createBaseElemFlags(): ElemFlags {
  return { bytesFlags1: new Uint8Array(0), bytesBusinessData: new Uint8Array(0) };
}

export const ElemFlags: MessageFns<ElemFlags> = {
  encode(message: ElemFlags, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.bytesFlags1 !== undefined && message.bytesFlags1.length !== 0) {
      writer.uint32(10).bytes(message.bytesFlags1);
    }
    if (message.bytesBusinessData !== undefined && message.bytesBusinessData.length !== 0) {
      writer.uint32(18).bytes(message.bytesBusinessData);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ElemFlags {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseElemFlags();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.bytesFlags1 = reader.bytes();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.bytesBusinessData = reader.bytes();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ElemFlags {
    return {
      bytesFlags1: isSet(object.bytesFlags1) ? bytesFromBase64(object.bytesFlags1) : new Uint8Array(0),
      bytesBusinessData: isSet(object.bytesBusinessData)
        ? bytesFromBase64(object.bytesBusinessData)
        : new Uint8Array(0),
    };
  },

  toJSON(message: ElemFlags): unknown {
    const obj: any = {};
    if (message.bytesFlags1 !== undefined && message.bytesFlags1.length !== 0) {
      obj.bytesFlags1 = base64FromBytes(message.bytesFlags1);
    }
    if (message.bytesBusinessData !== undefined && message.bytesBusinessData.length !== 0) {
      obj.bytesBusinessData = base64FromBytes(message.bytesBusinessData);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ElemFlags>, I>>(base?: I): ElemFlags {
    return ElemFlags.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ElemFlags>, I>>(object: I): ElemFlags {
    const message = createBaseElemFlags();
    message.bytesFlags1 = object.bytesFlags1 ?? new Uint8Array(0);
    message.bytesBusinessData = object.bytesBusinessData ?? new Uint8Array(0);
    return message;
  },
};

function createBaseElemFlags2(): ElemFlags2 {
  return {
    uint32ColorTextId: 0,
    uint64MsgId: 0,
    uint32WhisperSessionId: 0,
    uint32PttChangeBit: 0,
    uint32VipStatus: 0,
    uint32CompatibleId: 0,
    rptInsts: [],
    uint32MsgRptCnt: 0,
    srcInst: undefined,
    uint32Longtitude: 0,
    uint32Latitude: 0,
    uint32CustomFont: 0,
    pcSupportDef: undefined,
    uint32CrmFlags: 0,
  };
}

export const ElemFlags2: MessageFns<ElemFlags2> = {
  encode(message: ElemFlags2, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.uint32ColorTextId !== undefined && message.uint32ColorTextId !== 0) {
      writer.uint32(8).uint32(message.uint32ColorTextId);
    }
    if (message.uint64MsgId !== undefined && message.uint64MsgId !== 0) {
      writer.uint32(16).uint64(message.uint64MsgId);
    }
    if (message.uint32WhisperSessionId !== undefined && message.uint32WhisperSessionId !== 0) {
      writer.uint32(24).uint32(message.uint32WhisperSessionId);
    }
    if (message.uint32PttChangeBit !== undefined && message.uint32PttChangeBit !== 0) {
      writer.uint32(32).uint32(message.uint32PttChangeBit);
    }
    if (message.uint32VipStatus !== undefined && message.uint32VipStatus !== 0) {
      writer.uint32(40).uint32(message.uint32VipStatus);
    }
    if (message.uint32CompatibleId !== undefined && message.uint32CompatibleId !== 0) {
      writer.uint32(48).uint32(message.uint32CompatibleId);
    }
    for (const v of message.rptInsts) {
      ElemFlags2_Inst.encode(v!, writer.uint32(58).fork()).join();
    }
    if (message.uint32MsgRptCnt !== undefined && message.uint32MsgRptCnt !== 0) {
      writer.uint32(64).uint32(message.uint32MsgRptCnt);
    }
    if (message.srcInst !== undefined) {
      ElemFlags2_Inst.encode(message.srcInst, writer.uint32(74).fork()).join();
    }
    if (message.uint32Longtitude !== undefined && message.uint32Longtitude !== 0) {
      writer.uint32(80).uint32(message.uint32Longtitude);
    }
    if (message.uint32Latitude !== undefined && message.uint32Latitude !== 0) {
      writer.uint32(88).uint32(message.uint32Latitude);
    }
    if (message.uint32CustomFont !== undefined && message.uint32CustomFont !== 0) {
      writer.uint32(96).uint32(message.uint32CustomFont);
    }
    if (message.pcSupportDef !== undefined) {
      PcSupportDef.encode(message.pcSupportDef, writer.uint32(106).fork()).join();
    }
    if (message.uint32CrmFlags !== undefined && message.uint32CrmFlags !== 0) {
      writer.uint32(112).uint32(message.uint32CrmFlags);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ElemFlags2 {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseElemFlags2();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.uint32ColorTextId = reader.uint32();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.uint64MsgId = longToNumber(reader.uint64());
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.uint32WhisperSessionId = reader.uint32();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.uint32PttChangeBit = reader.uint32();
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.uint32VipStatus = reader.uint32();
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.uint32CompatibleId = reader.uint32();
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.rptInsts.push(ElemFlags2_Inst.decode(reader, reader.uint32()));
          continue;
        }
        case 8: {
          if (tag !== 64) {
            break;
          }

          message.uint32MsgRptCnt = reader.uint32();
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.srcInst = ElemFlags2_Inst.decode(reader, reader.uint32());
          continue;
        }
        case 10: {
          if (tag !== 80) {
            break;
          }

          message.uint32Longtitude = reader.uint32();
          continue;
        }
        case 11: {
          if (tag !== 88) {
            break;
          }

          message.uint32Latitude = reader.uint32();
          continue;
        }
        case 12: {
          if (tag !== 96) {
            break;
          }

          message.uint32CustomFont = reader.uint32();
          continue;
        }
        case 13: {
          if (tag !== 106) {
            break;
          }

          message.pcSupportDef = PcSupportDef.decode(reader, reader.uint32());
          continue;
        }
        case 14: {
          if (tag !== 112) {
            break;
          }

          message.uint32CrmFlags = reader.uint32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ElemFlags2 {
    return {
      uint32ColorTextId: isSet(object.uint32ColorTextId) ? globalThis.Number(object.uint32ColorTextId) : 0,
      uint64MsgId: isSet(object.uint64MsgId) ? globalThis.Number(object.uint64MsgId) : 0,
      uint32WhisperSessionId: isSet(object.uint32WhisperSessionId)
        ? globalThis.Number(object.uint32WhisperSessionId)
        : 0,
      uint32PttChangeBit: isSet(object.uint32PttChangeBit) ? globalThis.Number(object.uint32PttChangeBit) : 0,
      uint32VipStatus: isSet(object.uint32VipStatus) ? globalThis.Number(object.uint32VipStatus) : 0,
      uint32CompatibleId: isSet(object.uint32CompatibleId) ? globalThis.Number(object.uint32CompatibleId) : 0,
      rptInsts: globalThis.Array.isArray(object?.rptInsts)
        ? object.rptInsts.map((e: any) => ElemFlags2_Inst.fromJSON(e))
        : [],
      uint32MsgRptCnt: isSet(object.uint32MsgRptCnt) ? globalThis.Number(object.uint32MsgRptCnt) : 0,
      srcInst: isSet(object.srcInst) ? ElemFlags2_Inst.fromJSON(object.srcInst) : undefined,
      uint32Longtitude: isSet(object.uint32Longtitude) ? globalThis.Number(object.uint32Longtitude) : 0,
      uint32Latitude: isSet(object.uint32Latitude) ? globalThis.Number(object.uint32Latitude) : 0,
      uint32CustomFont: isSet(object.uint32CustomFont) ? globalThis.Number(object.uint32CustomFont) : 0,
      pcSupportDef: isSet(object.pcSupportDef) ? PcSupportDef.fromJSON(object.pcSupportDef) : undefined,
      uint32CrmFlags: isSet(object.uint32CrmFlags) ? globalThis.Number(object.uint32CrmFlags) : 0,
    };
  },

  toJSON(message: ElemFlags2): unknown {
    const obj: any = {};
    if (message.uint32ColorTextId !== undefined && message.uint32ColorTextId !== 0) {
      obj.uint32ColorTextId = Math.round(message.uint32ColorTextId);
    }
    if (message.uint64MsgId !== undefined && message.uint64MsgId !== 0) {
      obj.uint64MsgId = Math.round(message.uint64MsgId);
    }
    if (message.uint32WhisperSessionId !== undefined && message.uint32WhisperSessionId !== 0) {
      obj.uint32WhisperSessionId = Math.round(message.uint32WhisperSessionId);
    }
    if (message.uint32PttChangeBit !== undefined && message.uint32PttChangeBit !== 0) {
      obj.uint32PttChangeBit = Math.round(message.uint32PttChangeBit);
    }
    if (message.uint32VipStatus !== undefined && message.uint32VipStatus !== 0) {
      obj.uint32VipStatus = Math.round(message.uint32VipStatus);
    }
    if (message.uint32CompatibleId !== undefined && message.uint32CompatibleId !== 0) {
      obj.uint32CompatibleId = Math.round(message.uint32CompatibleId);
    }
    if (message.rptInsts?.length) {
      obj.rptInsts = message.rptInsts.map((e) => ElemFlags2_Inst.toJSON(e));
    }
    if (message.uint32MsgRptCnt !== undefined && message.uint32MsgRptCnt !== 0) {
      obj.uint32MsgRptCnt = Math.round(message.uint32MsgRptCnt);
    }
    if (message.srcInst !== undefined) {
      obj.srcInst = ElemFlags2_Inst.toJSON(message.srcInst);
    }
    if (message.uint32Longtitude !== undefined && message.uint32Longtitude !== 0) {
      obj.uint32Longtitude = Math.round(message.uint32Longtitude);
    }
    if (message.uint32Latitude !== undefined && message.uint32Latitude !== 0) {
      obj.uint32Latitude = Math.round(message.uint32Latitude);
    }
    if (message.uint32CustomFont !== undefined && message.uint32CustomFont !== 0) {
      obj.uint32CustomFont = Math.round(message.uint32CustomFont);
    }
    if (message.pcSupportDef !== undefined) {
      obj.pcSupportDef = PcSupportDef.toJSON(message.pcSupportDef);
    }
    if (message.uint32CrmFlags !== undefined && message.uint32CrmFlags !== 0) {
      obj.uint32CrmFlags = Math.round(message.uint32CrmFlags);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ElemFlags2>, I>>(base?: I): ElemFlags2 {
    return ElemFlags2.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ElemFlags2>, I>>(object: I): ElemFlags2 {
    const message = createBaseElemFlags2();
    message.uint32ColorTextId = object.uint32ColorTextId ?? 0;
    message.uint64MsgId = object.uint64MsgId ?? 0;
    message.uint32WhisperSessionId = object.uint32WhisperSessionId ?? 0;
    message.uint32PttChangeBit = object.uint32PttChangeBit ?? 0;
    message.uint32VipStatus = object.uint32VipStatus ?? 0;
    message.uint32CompatibleId = object.uint32CompatibleId ?? 0;
    message.rptInsts = object.rptInsts?.map((e) => ElemFlags2_Inst.fromPartial(e)) || [];
    message.uint32MsgRptCnt = object.uint32MsgRptCnt ?? 0;
    message.srcInst = (object.srcInst !== undefined && object.srcInst !== null)
      ? ElemFlags2_Inst.fromPartial(object.srcInst)
      : undefined;
    message.uint32Longtitude = object.uint32Longtitude ?? 0;
    message.uint32Latitude = object.uint32Latitude ?? 0;
    message.uint32CustomFont = object.uint32CustomFont ?? 0;
    message.pcSupportDef = (object.pcSupportDef !== undefined && object.pcSupportDef !== null)
      ? PcSupportDef.fromPartial(object.pcSupportDef)
      : undefined;
    message.uint32CrmFlags = object.uint32CrmFlags ?? 0;
    return message;
  },
};

function createBaseElemFlags2_Inst(): ElemFlags2_Inst {
  return { uint32AppId: 0, uint32InstId: 0 };
}

export const ElemFlags2_Inst: MessageFns<ElemFlags2_Inst> = {
  encode(message: ElemFlags2_Inst, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.uint32AppId !== undefined && message.uint32AppId !== 0) {
      writer.uint32(8).uint32(message.uint32AppId);
    }
    if (message.uint32InstId !== undefined && message.uint32InstId !== 0) {
      writer.uint32(16).uint32(message.uint32InstId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ElemFlags2_Inst {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseElemFlags2_Inst();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.uint32AppId = reader.uint32();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.uint32InstId = reader.uint32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ElemFlags2_Inst {
    return {
      uint32AppId: isSet(object.uint32AppId) ? globalThis.Number(object.uint32AppId) : 0,
      uint32InstId: isSet(object.uint32InstId) ? globalThis.Number(object.uint32InstId) : 0,
    };
  },

  toJSON(message: ElemFlags2_Inst): unknown {
    const obj: any = {};
    if (message.uint32AppId !== undefined && message.uint32AppId !== 0) {
      obj.uint32AppId = Math.round(message.uint32AppId);
    }
    if (message.uint32InstId !== undefined && message.uint32InstId !== 0) {
      obj.uint32InstId = Math.round(message.uint32InstId);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ElemFlags2_Inst>, I>>(base?: I): ElemFlags2_Inst {
    return ElemFlags2_Inst.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ElemFlags2_Inst>, I>>(object: I): ElemFlags2_Inst {
    const message = createBaseElemFlags2_Inst();
    message.uint32AppId = object.uint32AppId ?? 0;
    message.uint32InstId = object.uint32InstId ?? 0;
    return message;
  },
};

function createBasePcSupportDef(): PcSupportDef {
  return {
    uint32PcPtlBegin: 0,
    uint32PcPtlEnd: 0,
    uint32MacPtlBegin: 0,
    uint32MacPtlEnd: 0,
    rptPtlsSupport: [],
    rptPtlsNotSupport: [],
  };
}

export const PcSupportDef: MessageFns<PcSupportDef> = {
  encode(message: PcSupportDef, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.uint32PcPtlBegin !== undefined && message.uint32PcPtlBegin !== 0) {
      writer.uint32(8).uint32(message.uint32PcPtlBegin);
    }
    if (message.uint32PcPtlEnd !== undefined && message.uint32PcPtlEnd !== 0) {
      writer.uint32(16).uint32(message.uint32PcPtlEnd);
    }
    if (message.uint32MacPtlBegin !== undefined && message.uint32MacPtlBegin !== 0) {
      writer.uint32(24).uint32(message.uint32MacPtlBegin);
    }
    if (message.uint32MacPtlEnd !== undefined && message.uint32MacPtlEnd !== 0) {
      writer.uint32(32).uint32(message.uint32MacPtlEnd);
    }
    writer.uint32(42).fork();
    for (const v of message.rptPtlsSupport) {
      writer.uint32(v);
    }
    writer.join();
    writer.uint32(50).fork();
    for (const v of message.rptPtlsNotSupport) {
      writer.uint32(v);
    }
    writer.join();
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PcSupportDef {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePcSupportDef();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.uint32PcPtlBegin = reader.uint32();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.uint32PcPtlEnd = reader.uint32();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.uint32MacPtlBegin = reader.uint32();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.uint32MacPtlEnd = reader.uint32();
          continue;
        }
        case 5: {
          if (tag === 40) {
            message.rptPtlsSupport.push(reader.uint32());

            continue;
          }

          if (tag === 42) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.rptPtlsSupport.push(reader.uint32());
            }

            continue;
          }

          break;
        }
        case 6: {
          if (tag === 48) {
            message.rptPtlsNotSupport.push(reader.uint32());

            continue;
          }

          if (tag === 50) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.rptPtlsNotSupport.push(reader.uint32());
            }

            continue;
          }

          break;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PcSupportDef {
    return {
      uint32PcPtlBegin: isSet(object.uint32PcPtlBegin) ? globalThis.Number(object.uint32PcPtlBegin) : 0,
      uint32PcPtlEnd: isSet(object.uint32PcPtlEnd) ? globalThis.Number(object.uint32PcPtlEnd) : 0,
      uint32MacPtlBegin: isSet(object.uint32MacPtlBegin) ? globalThis.Number(object.uint32MacPtlBegin) : 0,
      uint32MacPtlEnd: isSet(object.uint32MacPtlEnd) ? globalThis.Number(object.uint32MacPtlEnd) : 0,
      rptPtlsSupport: globalThis.Array.isArray(object?.rptPtlsSupport)
        ? object.rptPtlsSupport.map((e: any) => globalThis.Number(e))
        : [],
      rptPtlsNotSupport: globalThis.Array.isArray(object?.rptPtlsNotSupport)
        ? object.rptPtlsNotSupport.map((e: any) => globalThis.Number(e))
        : [],
    };
  },

  toJSON(message: PcSupportDef): unknown {
    const obj: any = {};
    if (message.uint32PcPtlBegin !== undefined && message.uint32PcPtlBegin !== 0) {
      obj.uint32PcPtlBegin = Math.round(message.uint32PcPtlBegin);
    }
    if (message.uint32PcPtlEnd !== undefined && message.uint32PcPtlEnd !== 0) {
      obj.uint32PcPtlEnd = Math.round(message.uint32PcPtlEnd);
    }
    if (message.uint32MacPtlBegin !== undefined && message.uint32MacPtlBegin !== 0) {
      obj.uint32MacPtlBegin = Math.round(message.uint32MacPtlBegin);
    }
    if (message.uint32MacPtlEnd !== undefined && message.uint32MacPtlEnd !== 0) {
      obj.uint32MacPtlEnd = Math.round(message.uint32MacPtlEnd);
    }
    if (message.rptPtlsSupport?.length) {
      obj.rptPtlsSupport = message.rptPtlsSupport.map((e) => Math.round(e));
    }
    if (message.rptPtlsNotSupport?.length) {
      obj.rptPtlsNotSupport = message.rptPtlsNotSupport.map((e) => Math.round(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<PcSupportDef>, I>>(base?: I): PcSupportDef {
    return PcSupportDef.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<PcSupportDef>, I>>(object: I): PcSupportDef {
    const message = createBasePcSupportDef();
    message.uint32PcPtlBegin = object.uint32PcPtlBegin ?? 0;
    message.uint32PcPtlEnd = object.uint32PcPtlEnd ?? 0;
    message.uint32MacPtlBegin = object.uint32MacPtlBegin ?? 0;
    message.uint32MacPtlEnd = object.uint32MacPtlEnd ?? 0;
    message.rptPtlsSupport = object.rptPtlsSupport?.map((e) => e) || [];
    message.rptPtlsNotSupport = object.rptPtlsNotSupport?.map((e) => e) || [];
    return message;
  },
};

function createBaseExtraInfo(): ExtraInfo {
  return {
    bytesNick: new Uint8Array(0),
    bytesGroupCard: new Uint8Array(0),
    uint32Level: 0,
    uint32Flags: 0,
    uint32GroupMask: 0,
    uint32MsgTailId: 0,
    bytesSenderTitle: new Uint8Array(0),
    bytesApnsTips: new Uint8Array(0),
    uint64Uin: 0,
    uint32MsgStateFlag: 0,
    uint32ApnsSoundType: 0,
    uint32NewGroupFlag: 0,
  };
}

export const ExtraInfo: MessageFns<ExtraInfo> = {
  encode(message: ExtraInfo, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.bytesNick !== undefined && message.bytesNick.length !== 0) {
      writer.uint32(10).bytes(message.bytesNick);
    }
    if (message.bytesGroupCard !== undefined && message.bytesGroupCard.length !== 0) {
      writer.uint32(18).bytes(message.bytesGroupCard);
    }
    if (message.uint32Level !== undefined && message.uint32Level !== 0) {
      writer.uint32(24).uint32(message.uint32Level);
    }
    if (message.uint32Flags !== undefined && message.uint32Flags !== 0) {
      writer.uint32(32).uint32(message.uint32Flags);
    }
    if (message.uint32GroupMask !== undefined && message.uint32GroupMask !== 0) {
      writer.uint32(40).uint32(message.uint32GroupMask);
    }
    if (message.uint32MsgTailId !== undefined && message.uint32MsgTailId !== 0) {
      writer.uint32(48).uint32(message.uint32MsgTailId);
    }
    if (message.bytesSenderTitle !== undefined && message.bytesSenderTitle.length !== 0) {
      writer.uint32(58).bytes(message.bytesSenderTitle);
    }
    if (message.bytesApnsTips !== undefined && message.bytesApnsTips.length !== 0) {
      writer.uint32(66).bytes(message.bytesApnsTips);
    }
    if (message.uint64Uin !== undefined && message.uint64Uin !== 0) {
      writer.uint32(72).uint64(message.uint64Uin);
    }
    if (message.uint32MsgStateFlag !== undefined && message.uint32MsgStateFlag !== 0) {
      writer.uint32(80).uint32(message.uint32MsgStateFlag);
    }
    if (message.uint32ApnsSoundType !== undefined && message.uint32ApnsSoundType !== 0) {
      writer.uint32(88).uint32(message.uint32ApnsSoundType);
    }
    if (message.uint32NewGroupFlag !== undefined && message.uint32NewGroupFlag !== 0) {
      writer.uint32(96).uint32(message.uint32NewGroupFlag);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ExtraInfo {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseExtraInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.bytesNick = reader.bytes();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.bytesGroupCard = reader.bytes();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.uint32Level = reader.uint32();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.uint32Flags = reader.uint32();
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.uint32GroupMask = reader.uint32();
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.uint32MsgTailId = reader.uint32();
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.bytesSenderTitle = reader.bytes();
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.bytesApnsTips = reader.bytes();
          continue;
        }
        case 9: {
          if (tag !== 72) {
            break;
          }

          message.uint64Uin = longToNumber(reader.uint64());
          continue;
        }
        case 10: {
          if (tag !== 80) {
            break;
          }

          message.uint32MsgStateFlag = reader.uint32();
          continue;
        }
        case 11: {
          if (tag !== 88) {
            break;
          }

          message.uint32ApnsSoundType = reader.uint32();
          continue;
        }
        case 12: {
          if (tag !== 96) {
            break;
          }

          message.uint32NewGroupFlag = reader.uint32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ExtraInfo {
    return {
      bytesNick: isSet(object.bytesNick) ? bytesFromBase64(object.bytesNick) : new Uint8Array(0),
      bytesGroupCard: isSet(object.bytesGroupCard) ? bytesFromBase64(object.bytesGroupCard) : new Uint8Array(0),
      uint32Level: isSet(object.uint32Level) ? globalThis.Number(object.uint32Level) : 0,
      uint32Flags: isSet(object.uint32Flags) ? globalThis.Number(object.uint32Flags) : 0,
      uint32GroupMask: isSet(object.uint32GroupMask) ? globalThis.Number(object.uint32GroupMask) : 0,
      uint32MsgTailId: isSet(object.uint32MsgTailId) ? globalThis.Number(object.uint32MsgTailId) : 0,
      bytesSenderTitle: isSet(object.bytesSenderTitle) ? bytesFromBase64(object.bytesSenderTitle) : new Uint8Array(0),
      bytesApnsTips: isSet(object.bytesApnsTips) ? bytesFromBase64(object.bytesApnsTips) : new Uint8Array(0),
      uint64Uin: isSet(object.uint64Uin) ? globalThis.Number(object.uint64Uin) : 0,
      uint32MsgStateFlag: isSet(object.uint32MsgStateFlag) ? globalThis.Number(object.uint32MsgStateFlag) : 0,
      uint32ApnsSoundType: isSet(object.uint32ApnsSoundType) ? globalThis.Number(object.uint32ApnsSoundType) : 0,
      uint32NewGroupFlag: isSet(object.uint32NewGroupFlag) ? globalThis.Number(object.uint32NewGroupFlag) : 0,
    };
  },

  toJSON(message: ExtraInfo): unknown {
    const obj: any = {};
    if (message.bytesNick !== undefined && message.bytesNick.length !== 0) {
      obj.bytesNick = base64FromBytes(message.bytesNick);
    }
    if (message.bytesGroupCard !== undefined && message.bytesGroupCard.length !== 0) {
      obj.bytesGroupCard = base64FromBytes(message.bytesGroupCard);
    }
    if (message.uint32Level !== undefined && message.uint32Level !== 0) {
      obj.uint32Level = Math.round(message.uint32Level);
    }
    if (message.uint32Flags !== undefined && message.uint32Flags !== 0) {
      obj.uint32Flags = Math.round(message.uint32Flags);
    }
    if (message.uint32GroupMask !== undefined && message.uint32GroupMask !== 0) {
      obj.uint32GroupMask = Math.round(message.uint32GroupMask);
    }
    if (message.uint32MsgTailId !== undefined && message.uint32MsgTailId !== 0) {
      obj.uint32MsgTailId = Math.round(message.uint32MsgTailId);
    }
    if (message.bytesSenderTitle !== undefined && message.bytesSenderTitle.length !== 0) {
      obj.bytesSenderTitle = base64FromBytes(message.bytesSenderTitle);
    }
    if (message.bytesApnsTips !== undefined && message.bytesApnsTips.length !== 0) {
      obj.bytesApnsTips = base64FromBytes(message.bytesApnsTips);
    }
    if (message.uint64Uin !== undefined && message.uint64Uin !== 0) {
      obj.uint64Uin = Math.round(message.uint64Uin);
    }
    if (message.uint32MsgStateFlag !== undefined && message.uint32MsgStateFlag !== 0) {
      obj.uint32MsgStateFlag = Math.round(message.uint32MsgStateFlag);
    }
    if (message.uint32ApnsSoundType !== undefined && message.uint32ApnsSoundType !== 0) {
      obj.uint32ApnsSoundType = Math.round(message.uint32ApnsSoundType);
    }
    if (message.uint32NewGroupFlag !== undefined && message.uint32NewGroupFlag !== 0) {
      obj.uint32NewGroupFlag = Math.round(message.uint32NewGroupFlag);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ExtraInfo>, I>>(base?: I): ExtraInfo {
    return ExtraInfo.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ExtraInfo>, I>>(object: I): ExtraInfo {
    const message = createBaseExtraInfo();
    message.bytesNick = object.bytesNick ?? new Uint8Array(0);
    message.bytesGroupCard = object.bytesGroupCard ?? new Uint8Array(0);
    message.uint32Level = object.uint32Level ?? 0;
    message.uint32Flags = object.uint32Flags ?? 0;
    message.uint32GroupMask = object.uint32GroupMask ?? 0;
    message.uint32MsgTailId = object.uint32MsgTailId ?? 0;
    message.bytesSenderTitle = object.bytesSenderTitle ?? new Uint8Array(0);
    message.bytesApnsTips = object.bytesApnsTips ?? new Uint8Array(0);
    message.uint64Uin = object.uint64Uin ?? 0;
    message.uint32MsgStateFlag = object.uint32MsgStateFlag ?? 0;
    message.uint32ApnsSoundType = object.uint32ApnsSoundType ?? 0;
    message.uint32NewGroupFlag = object.uint32NewGroupFlag ?? 0;
    return message;
  },
};

function createBaseFunFace(): FunFace {
  return { msgTurntable: undefined, msgBomb: undefined };
}

export const FunFace: MessageFns<FunFace> = {
  encode(message: FunFace, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.msgTurntable !== undefined) {
      FunFace_Turntable.encode(message.msgTurntable, writer.uint32(10).fork()).join();
    }
    if (message.msgBomb !== undefined) {
      FunFace_Bomb.encode(message.msgBomb, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): FunFace {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseFunFace();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.msgTurntable = FunFace_Turntable.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.msgBomb = FunFace_Bomb.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): FunFace {
    return {
      msgTurntable: isSet(object.msgTurntable) ? FunFace_Turntable.fromJSON(object.msgTurntable) : undefined,
      msgBomb: isSet(object.msgBomb) ? FunFace_Bomb.fromJSON(object.msgBomb) : undefined,
    };
  },

  toJSON(message: FunFace): unknown {
    const obj: any = {};
    if (message.msgTurntable !== undefined) {
      obj.msgTurntable = FunFace_Turntable.toJSON(message.msgTurntable);
    }
    if (message.msgBomb !== undefined) {
      obj.msgBomb = FunFace_Bomb.toJSON(message.msgBomb);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<FunFace>, I>>(base?: I): FunFace {
    return FunFace.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<FunFace>, I>>(object: I): FunFace {
    const message = createBaseFunFace();
    message.msgTurntable = (object.msgTurntable !== undefined && object.msgTurntable !== null)
      ? FunFace_Turntable.fromPartial(object.msgTurntable)
      : undefined;
    message.msgBomb = (object.msgBomb !== undefined && object.msgBomb !== null)
      ? FunFace_Bomb.fromPartial(object.msgBomb)
      : undefined;
    return message;
  },
};

function createBaseFunFace_Turntable(): FunFace_Turntable {
  return { rptUint64UinList: [], uint64HitUin: 0, strHitUinNick: "" };
}

export const FunFace_Turntable: MessageFns<FunFace_Turntable> = {
  encode(message: FunFace_Turntable, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    writer.uint32(10).fork();
    for (const v of message.rptUint64UinList) {
      writer.uint64(v);
    }
    writer.join();
    if (message.uint64HitUin !== undefined && message.uint64HitUin !== 0) {
      writer.uint32(16).uint64(message.uint64HitUin);
    }
    if (message.strHitUinNick !== undefined && message.strHitUinNick !== "") {
      writer.uint32(26).string(message.strHitUinNick);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): FunFace_Turntable {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseFunFace_Turntable();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag === 8) {
            message.rptUint64UinList.push(longToNumber(reader.uint64()));

            continue;
          }

          if (tag === 10) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.rptUint64UinList.push(longToNumber(reader.uint64()));
            }

            continue;
          }

          break;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.uint64HitUin = longToNumber(reader.uint64());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.strHitUinNick = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): FunFace_Turntable {
    return {
      rptUint64UinList: globalThis.Array.isArray(object?.rptUint64UinList)
        ? object.rptUint64UinList.map((e: any) => globalThis.Number(e))
        : [],
      uint64HitUin: isSet(object.uint64HitUin) ? globalThis.Number(object.uint64HitUin) : 0,
      strHitUinNick: isSet(object.strHitUinNick) ? globalThis.String(object.strHitUinNick) : "",
    };
  },

  toJSON(message: FunFace_Turntable): unknown {
    const obj: any = {};
    if (message.rptUint64UinList?.length) {
      obj.rptUint64UinList = message.rptUint64UinList.map((e) => Math.round(e));
    }
    if (message.uint64HitUin !== undefined && message.uint64HitUin !== 0) {
      obj.uint64HitUin = Math.round(message.uint64HitUin);
    }
    if (message.strHitUinNick !== undefined && message.strHitUinNick !== "") {
      obj.strHitUinNick = message.strHitUinNick;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<FunFace_Turntable>, I>>(base?: I): FunFace_Turntable {
    return FunFace_Turntable.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<FunFace_Turntable>, I>>(object: I): FunFace_Turntable {
    const message = createBaseFunFace_Turntable();
    message.rptUint64UinList = object.rptUint64UinList?.map((e) => e) || [];
    message.uint64HitUin = object.uint64HitUin ?? 0;
    message.strHitUinNick = object.strHitUinNick ?? "";
    return message;
  },
};

function createBaseFunFace_Bomb(): FunFace_Bomb {
  return { boolBurst: false };
}

export const FunFace_Bomb: MessageFns<FunFace_Bomb> = {
  encode(message: FunFace_Bomb, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.boolBurst !== undefined && message.boolBurst !== false) {
      writer.uint32(8).bool(message.boolBurst);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): FunFace_Bomb {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseFunFace_Bomb();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.boolBurst = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): FunFace_Bomb {
    return { boolBurst: isSet(object.boolBurst) ? globalThis.Boolean(object.boolBurst) : false };
  },

  toJSON(message: FunFace_Bomb): unknown {
    const obj: any = {};
    if (message.boolBurst !== undefined && message.boolBurst !== false) {
      obj.boolBurst = message.boolBurst;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<FunFace_Bomb>, I>>(base?: I): FunFace_Bomb {
    return FunFace_Bomb.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<FunFace_Bomb>, I>>(object: I): FunFace_Bomb {
    const message = createBaseFunFace_Bomb();
    message.boolBurst = object.boolBurst ?? false;
    return message;
  },
};

function createBaseSecretFileMsg(): SecretFileMsg {
  return {
    bytesFileKey: new Uint8Array(0),
    uint64FromUin: 0,
    uint64ToUin: 0,
    uint32Status: 0,
    uint32Ttl: 0,
    uint32Type: 0,
    uint32EncryptPreheadLength: 0,
    uint32EncryptType: 0,
    bytesEncryptKey: new Uint8Array(0),
    uint32ReadTimes: 0,
    uint32LeftTime: 0,
    notOnlineImage: undefined,
    elemFlags2: undefined,
    uint32Opertype: 0,
    strFromphonenum: "",
  };
}

export const SecretFileMsg: MessageFns<SecretFileMsg> = {
  encode(message: SecretFileMsg, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.bytesFileKey !== undefined && message.bytesFileKey.length !== 0) {
      writer.uint32(10).bytes(message.bytesFileKey);
    }
    if (message.uint64FromUin !== undefined && message.uint64FromUin !== 0) {
      writer.uint32(16).uint64(message.uint64FromUin);
    }
    if (message.uint64ToUin !== undefined && message.uint64ToUin !== 0) {
      writer.uint32(24).uint64(message.uint64ToUin);
    }
    if (message.uint32Status !== undefined && message.uint32Status !== 0) {
      writer.uint32(32).uint32(message.uint32Status);
    }
    if (message.uint32Ttl !== undefined && message.uint32Ttl !== 0) {
      writer.uint32(40).uint32(message.uint32Ttl);
    }
    if (message.uint32Type !== undefined && message.uint32Type !== 0) {
      writer.uint32(48).uint32(message.uint32Type);
    }
    if (message.uint32EncryptPreheadLength !== undefined && message.uint32EncryptPreheadLength !== 0) {
      writer.uint32(56).uint32(message.uint32EncryptPreheadLength);
    }
    if (message.uint32EncryptType !== undefined && message.uint32EncryptType !== 0) {
      writer.uint32(64).uint32(message.uint32EncryptType);
    }
    if (message.bytesEncryptKey !== undefined && message.bytesEncryptKey.length !== 0) {
      writer.uint32(74).bytes(message.bytesEncryptKey);
    }
    if (message.uint32ReadTimes !== undefined && message.uint32ReadTimes !== 0) {
      writer.uint32(80).uint32(message.uint32ReadTimes);
    }
    if (message.uint32LeftTime !== undefined && message.uint32LeftTime !== 0) {
      writer.uint32(88).uint32(message.uint32LeftTime);
    }
    if (message.notOnlineImage !== undefined) {
      NotOnlineImage.encode(message.notOnlineImage, writer.uint32(98).fork()).join();
    }
    if (message.elemFlags2 !== undefined) {
      ElemFlags2.encode(message.elemFlags2, writer.uint32(106).fork()).join();
    }
    if (message.uint32Opertype !== undefined && message.uint32Opertype !== 0) {
      writer.uint32(112).uint32(message.uint32Opertype);
    }
    if (message.strFromphonenum !== undefined && message.strFromphonenum !== "") {
      writer.uint32(122).string(message.strFromphonenum);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SecretFileMsg {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSecretFileMsg();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.bytesFileKey = reader.bytes();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.uint64FromUin = longToNumber(reader.uint64());
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.uint64ToUin = longToNumber(reader.uint64());
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.uint32Status = reader.uint32();
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.uint32Ttl = reader.uint32();
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.uint32Type = reader.uint32();
          continue;
        }
        case 7: {
          if (tag !== 56) {
            break;
          }

          message.uint32EncryptPreheadLength = reader.uint32();
          continue;
        }
        case 8: {
          if (tag !== 64) {
            break;
          }

          message.uint32EncryptType = reader.uint32();
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.bytesEncryptKey = reader.bytes();
          continue;
        }
        case 10: {
          if (tag !== 80) {
            break;
          }

          message.uint32ReadTimes = reader.uint32();
          continue;
        }
        case 11: {
          if (tag !== 88) {
            break;
          }

          message.uint32LeftTime = reader.uint32();
          continue;
        }
        case 12: {
          if (tag !== 98) {
            break;
          }

          message.notOnlineImage = NotOnlineImage.decode(reader, reader.uint32());
          continue;
        }
        case 13: {
          if (tag !== 106) {
            break;
          }

          message.elemFlags2 = ElemFlags2.decode(reader, reader.uint32());
          continue;
        }
        case 14: {
          if (tag !== 112) {
            break;
          }

          message.uint32Opertype = reader.uint32();
          continue;
        }
        case 15: {
          if (tag !== 122) {
            break;
          }

          message.strFromphonenum = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SecretFileMsg {
    return {
      bytesFileKey: isSet(object.bytesFileKey) ? bytesFromBase64(object.bytesFileKey) : new Uint8Array(0),
      uint64FromUin: isSet(object.uint64FromUin) ? globalThis.Number(object.uint64FromUin) : 0,
      uint64ToUin: isSet(object.uint64ToUin) ? globalThis.Number(object.uint64ToUin) : 0,
      uint32Status: isSet(object.uint32Status) ? globalThis.Number(object.uint32Status) : 0,
      uint32Ttl: isSet(object.uint32Ttl) ? globalThis.Number(object.uint32Ttl) : 0,
      uint32Type: isSet(object.uint32Type) ? globalThis.Number(object.uint32Type) : 0,
      uint32EncryptPreheadLength: isSet(object.uint32EncryptPreheadLength)
        ? globalThis.Number(object.uint32EncryptPreheadLength)
        : 0,
      uint32EncryptType: isSet(object.uint32EncryptType) ? globalThis.Number(object.uint32EncryptType) : 0,
      bytesEncryptKey: isSet(object.bytesEncryptKey) ? bytesFromBase64(object.bytesEncryptKey) : new Uint8Array(0),
      uint32ReadTimes: isSet(object.uint32ReadTimes) ? globalThis.Number(object.uint32ReadTimes) : 0,
      uint32LeftTime: isSet(object.uint32LeftTime) ? globalThis.Number(object.uint32LeftTime) : 0,
      notOnlineImage: isSet(object.notOnlineImage) ? NotOnlineImage.fromJSON(object.notOnlineImage) : undefined,
      elemFlags2: isSet(object.elemFlags2) ? ElemFlags2.fromJSON(object.elemFlags2) : undefined,
      uint32Opertype: isSet(object.uint32Opertype) ? globalThis.Number(object.uint32Opertype) : 0,
      strFromphonenum: isSet(object.strFromphonenum) ? globalThis.String(object.strFromphonenum) : "",
    };
  },

  toJSON(message: SecretFileMsg): unknown {
    const obj: any = {};
    if (message.bytesFileKey !== undefined && message.bytesFileKey.length !== 0) {
      obj.bytesFileKey = base64FromBytes(message.bytesFileKey);
    }
    if (message.uint64FromUin !== undefined && message.uint64FromUin !== 0) {
      obj.uint64FromUin = Math.round(message.uint64FromUin);
    }
    if (message.uint64ToUin !== undefined && message.uint64ToUin !== 0) {
      obj.uint64ToUin = Math.round(message.uint64ToUin);
    }
    if (message.uint32Status !== undefined && message.uint32Status !== 0) {
      obj.uint32Status = Math.round(message.uint32Status);
    }
    if (message.uint32Ttl !== undefined && message.uint32Ttl !== 0) {
      obj.uint32Ttl = Math.round(message.uint32Ttl);
    }
    if (message.uint32Type !== undefined && message.uint32Type !== 0) {
      obj.uint32Type = Math.round(message.uint32Type);
    }
    if (message.uint32EncryptPreheadLength !== undefined && message.uint32EncryptPreheadLength !== 0) {
      obj.uint32EncryptPreheadLength = Math.round(message.uint32EncryptPreheadLength);
    }
    if (message.uint32EncryptType !== undefined && message.uint32EncryptType !== 0) {
      obj.uint32EncryptType = Math.round(message.uint32EncryptType);
    }
    if (message.bytesEncryptKey !== undefined && message.bytesEncryptKey.length !== 0) {
      obj.bytesEncryptKey = base64FromBytes(message.bytesEncryptKey);
    }
    if (message.uint32ReadTimes !== undefined && message.uint32ReadTimes !== 0) {
      obj.uint32ReadTimes = Math.round(message.uint32ReadTimes);
    }
    if (message.uint32LeftTime !== undefined && message.uint32LeftTime !== 0) {
      obj.uint32LeftTime = Math.round(message.uint32LeftTime);
    }
    if (message.notOnlineImage !== undefined) {
      obj.notOnlineImage = NotOnlineImage.toJSON(message.notOnlineImage);
    }
    if (message.elemFlags2 !== undefined) {
      obj.elemFlags2 = ElemFlags2.toJSON(message.elemFlags2);
    }
    if (message.uint32Opertype !== undefined && message.uint32Opertype !== 0) {
      obj.uint32Opertype = Math.round(message.uint32Opertype);
    }
    if (message.strFromphonenum !== undefined && message.strFromphonenum !== "") {
      obj.strFromphonenum = message.strFromphonenum;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<SecretFileMsg>, I>>(base?: I): SecretFileMsg {
    return SecretFileMsg.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SecretFileMsg>, I>>(object: I): SecretFileMsg {
    const message = createBaseSecretFileMsg();
    message.bytesFileKey = object.bytesFileKey ?? new Uint8Array(0);
    message.uint64FromUin = object.uint64FromUin ?? 0;
    message.uint64ToUin = object.uint64ToUin ?? 0;
    message.uint32Status = object.uint32Status ?? 0;
    message.uint32Ttl = object.uint32Ttl ?? 0;
    message.uint32Type = object.uint32Type ?? 0;
    message.uint32EncryptPreheadLength = object.uint32EncryptPreheadLength ?? 0;
    message.uint32EncryptType = object.uint32EncryptType ?? 0;
    message.bytesEncryptKey = object.bytesEncryptKey ?? new Uint8Array(0);
    message.uint32ReadTimes = object.uint32ReadTimes ?? 0;
    message.uint32LeftTime = object.uint32LeftTime ?? 0;
    message.notOnlineImage = (object.notOnlineImage !== undefined && object.notOnlineImage !== null)
      ? NotOnlineImage.fromPartial(object.notOnlineImage)
      : undefined;
    message.elemFlags2 = (object.elemFlags2 !== undefined && object.elemFlags2 !== null)
      ? ElemFlags2.fromPartial(object.elemFlags2)
      : undefined;
    message.uint32Opertype = object.uint32Opertype ?? 0;
    message.strFromphonenum = object.strFromphonenum ?? "";
    return message;
  },
};

function createBaseRichMsg(): RichMsg {
  return {
    bytesTemplate1: new Uint8Array(0),
    uint32ServiceId: 0,
    bytesMsgResid: new Uint8Array(0),
    uint32Rand: 0,
    uint32Seq: 0,
    uint32Flags: 0,
  };
}

export const RichMsg: MessageFns<RichMsg> = {
  encode(message: RichMsg, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.bytesTemplate1 !== undefined && message.bytesTemplate1.length !== 0) {
      writer.uint32(10).bytes(message.bytesTemplate1);
    }
    if (message.uint32ServiceId !== undefined && message.uint32ServiceId !== 0) {
      writer.uint32(16).uint32(message.uint32ServiceId);
    }
    if (message.bytesMsgResid !== undefined && message.bytesMsgResid.length !== 0) {
      writer.uint32(26).bytes(message.bytesMsgResid);
    }
    if (message.uint32Rand !== undefined && message.uint32Rand !== 0) {
      writer.uint32(32).uint32(message.uint32Rand);
    }
    if (message.uint32Seq !== undefined && message.uint32Seq !== 0) {
      writer.uint32(40).uint32(message.uint32Seq);
    }
    if (message.uint32Flags !== undefined && message.uint32Flags !== 0) {
      writer.uint32(48).uint32(message.uint32Flags);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RichMsg {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRichMsg();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.bytesTemplate1 = reader.bytes();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.uint32ServiceId = reader.uint32();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.bytesMsgResid = reader.bytes();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.uint32Rand = reader.uint32();
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.uint32Seq = reader.uint32();
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.uint32Flags = reader.uint32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RichMsg {
    return {
      bytesTemplate1: isSet(object.bytesTemplate1) ? bytesFromBase64(object.bytesTemplate1) : new Uint8Array(0),
      uint32ServiceId: isSet(object.uint32ServiceId) ? globalThis.Number(object.uint32ServiceId) : 0,
      bytesMsgResid: isSet(object.bytesMsgResid) ? bytesFromBase64(object.bytesMsgResid) : new Uint8Array(0),
      uint32Rand: isSet(object.uint32Rand) ? globalThis.Number(object.uint32Rand) : 0,
      uint32Seq: isSet(object.uint32Seq) ? globalThis.Number(object.uint32Seq) : 0,
      uint32Flags: isSet(object.uint32Flags) ? globalThis.Number(object.uint32Flags) : 0,
    };
  },

  toJSON(message: RichMsg): unknown {
    const obj: any = {};
    if (message.bytesTemplate1 !== undefined && message.bytesTemplate1.length !== 0) {
      obj.bytesTemplate1 = base64FromBytes(message.bytesTemplate1);
    }
    if (message.uint32ServiceId !== undefined && message.uint32ServiceId !== 0) {
      obj.uint32ServiceId = Math.round(message.uint32ServiceId);
    }
    if (message.bytesMsgResid !== undefined && message.bytesMsgResid.length !== 0) {
      obj.bytesMsgResid = base64FromBytes(message.bytesMsgResid);
    }
    if (message.uint32Rand !== undefined && message.uint32Rand !== 0) {
      obj.uint32Rand = Math.round(message.uint32Rand);
    }
    if (message.uint32Seq !== undefined && message.uint32Seq !== 0) {
      obj.uint32Seq = Math.round(message.uint32Seq);
    }
    if (message.uint32Flags !== undefined && message.uint32Flags !== 0) {
      obj.uint32Flags = Math.round(message.uint32Flags);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<RichMsg>, I>>(base?: I): RichMsg {
    return RichMsg.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<RichMsg>, I>>(object: I): RichMsg {
    const message = createBaseRichMsg();
    message.bytesTemplate1 = object.bytesTemplate1 ?? new Uint8Array(0);
    message.uint32ServiceId = object.uint32ServiceId ?? 0;
    message.bytesMsgResid = object.bytesMsgResid ?? new Uint8Array(0);
    message.uint32Rand = object.uint32Rand ?? 0;
    message.uint32Seq = object.uint32Seq ?? 0;
    message.uint32Flags = object.uint32Flags ?? 0;
    return message;
  },
};

function createBaseGroupFile(): GroupFile {
  return {
    bytesFilename: new Uint8Array(0),
    uint64FileSize: 0,
    bytesFileId: new Uint8Array(0),
    bytesBatchId: new Uint8Array(0),
    bytesFileKey: new Uint8Array(0),
    bytesMark: new Uint8Array(0),
    uint64Sequence: 0,
    bytesBatchItemId: new Uint8Array(0),
    uint32FeedMsgTime: 0,
    bytesPbReserve: new Uint8Array(0),
  };
}

export const GroupFile: MessageFns<GroupFile> = {
  encode(message: GroupFile, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.bytesFilename !== undefined && message.bytesFilename.length !== 0) {
      writer.uint32(10).bytes(message.bytesFilename);
    }
    if (message.uint64FileSize !== undefined && message.uint64FileSize !== 0) {
      writer.uint32(16).uint64(message.uint64FileSize);
    }
    if (message.bytesFileId !== undefined && message.bytesFileId.length !== 0) {
      writer.uint32(26).bytes(message.bytesFileId);
    }
    if (message.bytesBatchId !== undefined && message.bytesBatchId.length !== 0) {
      writer.uint32(34).bytes(message.bytesBatchId);
    }
    if (message.bytesFileKey !== undefined && message.bytesFileKey.length !== 0) {
      writer.uint32(42).bytes(message.bytesFileKey);
    }
    if (message.bytesMark !== undefined && message.bytesMark.length !== 0) {
      writer.uint32(50).bytes(message.bytesMark);
    }
    if (message.uint64Sequence !== undefined && message.uint64Sequence !== 0) {
      writer.uint32(56).uint64(message.uint64Sequence);
    }
    if (message.bytesBatchItemId !== undefined && message.bytesBatchItemId.length !== 0) {
      writer.uint32(66).bytes(message.bytesBatchItemId);
    }
    if (message.uint32FeedMsgTime !== undefined && message.uint32FeedMsgTime !== 0) {
      writer.uint32(72).uint32(message.uint32FeedMsgTime);
    }
    if (message.bytesPbReserve !== undefined && message.bytesPbReserve.length !== 0) {
      writer.uint32(82).bytes(message.bytesPbReserve);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GroupFile {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGroupFile();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.bytesFilename = reader.bytes();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.uint64FileSize = longToNumber(reader.uint64());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.bytesFileId = reader.bytes();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.bytesBatchId = reader.bytes();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.bytesFileKey = reader.bytes();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.bytesMark = reader.bytes();
          continue;
        }
        case 7: {
          if (tag !== 56) {
            break;
          }

          message.uint64Sequence = longToNumber(reader.uint64());
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.bytesBatchItemId = reader.bytes();
          continue;
        }
        case 9: {
          if (tag !== 72) {
            break;
          }

          message.uint32FeedMsgTime = reader.uint32();
          continue;
        }
        case 10: {
          if (tag !== 82) {
            break;
          }

          message.bytesPbReserve = reader.bytes();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GroupFile {
    return {
      bytesFilename: isSet(object.bytesFilename) ? bytesFromBase64(object.bytesFilename) : new Uint8Array(0),
      uint64FileSize: isSet(object.uint64FileSize) ? globalThis.Number(object.uint64FileSize) : 0,
      bytesFileId: isSet(object.bytesFileId) ? bytesFromBase64(object.bytesFileId) : new Uint8Array(0),
      bytesBatchId: isSet(object.bytesBatchId) ? bytesFromBase64(object.bytesBatchId) : new Uint8Array(0),
      bytesFileKey: isSet(object.bytesFileKey) ? bytesFromBase64(object.bytesFileKey) : new Uint8Array(0),
      bytesMark: isSet(object.bytesMark) ? bytesFromBase64(object.bytesMark) : new Uint8Array(0),
      uint64Sequence: isSet(object.uint64Sequence) ? globalThis.Number(object.uint64Sequence) : 0,
      bytesBatchItemId: isSet(object.bytesBatchItemId) ? bytesFromBase64(object.bytesBatchItemId) : new Uint8Array(0),
      uint32FeedMsgTime: isSet(object.uint32FeedMsgTime) ? globalThis.Number(object.uint32FeedMsgTime) : 0,
      bytesPbReserve: isSet(object.bytesPbReserve) ? bytesFromBase64(object.bytesPbReserve) : new Uint8Array(0),
    };
  },

  toJSON(message: GroupFile): unknown {
    const obj: any = {};
    if (message.bytesFilename !== undefined && message.bytesFilename.length !== 0) {
      obj.bytesFilename = base64FromBytes(message.bytesFilename);
    }
    if (message.uint64FileSize !== undefined && message.uint64FileSize !== 0) {
      obj.uint64FileSize = Math.round(message.uint64FileSize);
    }
    if (message.bytesFileId !== undefined && message.bytesFileId.length !== 0) {
      obj.bytesFileId = base64FromBytes(message.bytesFileId);
    }
    if (message.bytesBatchId !== undefined && message.bytesBatchId.length !== 0) {
      obj.bytesBatchId = base64FromBytes(message.bytesBatchId);
    }
    if (message.bytesFileKey !== undefined && message.bytesFileKey.length !== 0) {
      obj.bytesFileKey = base64FromBytes(message.bytesFileKey);
    }
    if (message.bytesMark !== undefined && message.bytesMark.length !== 0) {
      obj.bytesMark = base64FromBytes(message.bytesMark);
    }
    if (message.uint64Sequence !== undefined && message.uint64Sequence !== 0) {
      obj.uint64Sequence = Math.round(message.uint64Sequence);
    }
    if (message.bytesBatchItemId !== undefined && message.bytesBatchItemId.length !== 0) {
      obj.bytesBatchItemId = base64FromBytes(message.bytesBatchItemId);
    }
    if (message.uint32FeedMsgTime !== undefined && message.uint32FeedMsgTime !== 0) {
      obj.uint32FeedMsgTime = Math.round(message.uint32FeedMsgTime);
    }
    if (message.bytesPbReserve !== undefined && message.bytesPbReserve.length !== 0) {
      obj.bytesPbReserve = base64FromBytes(message.bytesPbReserve);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GroupFile>, I>>(base?: I): GroupFile {
    return GroupFile.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GroupFile>, I>>(object: I): GroupFile {
    const message = createBaseGroupFile();
    message.bytesFilename = object.bytesFilename ?? new Uint8Array(0);
    message.uint64FileSize = object.uint64FileSize ?? 0;
    message.bytesFileId = object.bytesFileId ?? new Uint8Array(0);
    message.bytesBatchId = object.bytesBatchId ?? new Uint8Array(0);
    message.bytesFileKey = object.bytesFileKey ?? new Uint8Array(0);
    message.bytesMark = object.bytesMark ?? new Uint8Array(0);
    message.uint64Sequence = object.uint64Sequence ?? 0;
    message.bytesBatchItemId = object.bytesBatchItemId ?? new Uint8Array(0);
    message.uint32FeedMsgTime = object.uint32FeedMsgTime ?? 0;
    message.bytesPbReserve = object.bytesPbReserve ?? new Uint8Array(0);
    return message;
  },
};

function createBaseMarketTrans(): MarketTrans {
  return {
    int32Flag: 0,
    bytesXml: new Uint8Array(0),
    bytesMsgResid: new Uint8Array(0),
    uint32Ability: 0,
    uint32MinAbility: 0,
  };
}

export const MarketTrans: MessageFns<MarketTrans> = {
  encode(message: MarketTrans, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.int32Flag !== undefined && message.int32Flag !== 0) {
      writer.uint32(8).int32(message.int32Flag);
    }
    if (message.bytesXml !== undefined && message.bytesXml.length !== 0) {
      writer.uint32(18).bytes(message.bytesXml);
    }
    if (message.bytesMsgResid !== undefined && message.bytesMsgResid.length !== 0) {
      writer.uint32(26).bytes(message.bytesMsgResid);
    }
    if (message.uint32Ability !== undefined && message.uint32Ability !== 0) {
      writer.uint32(32).uint32(message.uint32Ability);
    }
    if (message.uint32MinAbility !== undefined && message.uint32MinAbility !== 0) {
      writer.uint32(40).uint32(message.uint32MinAbility);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MarketTrans {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMarketTrans();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.int32Flag = reader.int32();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.bytesXml = reader.bytes();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.bytesMsgResid = reader.bytes();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.uint32Ability = reader.uint32();
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.uint32MinAbility = reader.uint32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MarketTrans {
    return {
      int32Flag: isSet(object.int32Flag) ? globalThis.Number(object.int32Flag) : 0,
      bytesXml: isSet(object.bytesXml) ? bytesFromBase64(object.bytesXml) : new Uint8Array(0),
      bytesMsgResid: isSet(object.bytesMsgResid) ? bytesFromBase64(object.bytesMsgResid) : new Uint8Array(0),
      uint32Ability: isSet(object.uint32Ability) ? globalThis.Number(object.uint32Ability) : 0,
      uint32MinAbility: isSet(object.uint32MinAbility) ? globalThis.Number(object.uint32MinAbility) : 0,
    };
  },

  toJSON(message: MarketTrans): unknown {
    const obj: any = {};
    if (message.int32Flag !== undefined && message.int32Flag !== 0) {
      obj.int32Flag = Math.round(message.int32Flag);
    }
    if (message.bytesXml !== undefined && message.bytesXml.length !== 0) {
      obj.bytesXml = base64FromBytes(message.bytesXml);
    }
    if (message.bytesMsgResid !== undefined && message.bytesMsgResid.length !== 0) {
      obj.bytesMsgResid = base64FromBytes(message.bytesMsgResid);
    }
    if (message.uint32Ability !== undefined && message.uint32Ability !== 0) {
      obj.uint32Ability = Math.round(message.uint32Ability);
    }
    if (message.uint32MinAbility !== undefined && message.uint32MinAbility !== 0) {
      obj.uint32MinAbility = Math.round(message.uint32MinAbility);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MarketTrans>, I>>(base?: I): MarketTrans {
    return MarketTrans.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MarketTrans>, I>>(object: I): MarketTrans {
    const message = createBaseMarketTrans();
    message.int32Flag = object.int32Flag ?? 0;
    message.bytesXml = object.bytesXml ?? new Uint8Array(0);
    message.bytesMsgResid = object.bytesMsgResid ?? new Uint8Array(0);
    message.uint32Ability = object.uint32Ability ?? 0;
    message.uint32MinAbility = object.uint32MinAbility ?? 0;
    return message;
  },
};

function createBasePubGroup(): PubGroup {
  return { bytesNickname: new Uint8Array(0), uint32Gender: 0, uint32Age: 0, uint32Distance: 0 };
}

export const PubGroup: MessageFns<PubGroup> = {
  encode(message: PubGroup, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.bytesNickname !== undefined && message.bytesNickname.length !== 0) {
      writer.uint32(10).bytes(message.bytesNickname);
    }
    if (message.uint32Gender !== undefined && message.uint32Gender !== 0) {
      writer.uint32(16).uint32(message.uint32Gender);
    }
    if (message.uint32Age !== undefined && message.uint32Age !== 0) {
      writer.uint32(24).uint32(message.uint32Age);
    }
    if (message.uint32Distance !== undefined && message.uint32Distance !== 0) {
      writer.uint32(32).uint32(message.uint32Distance);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PubGroup {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePubGroup();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.bytesNickname = reader.bytes();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.uint32Gender = reader.uint32();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.uint32Age = reader.uint32();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.uint32Distance = reader.uint32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PubGroup {
    return {
      bytesNickname: isSet(object.bytesNickname) ? bytesFromBase64(object.bytesNickname) : new Uint8Array(0),
      uint32Gender: isSet(object.uint32Gender) ? globalThis.Number(object.uint32Gender) : 0,
      uint32Age: isSet(object.uint32Age) ? globalThis.Number(object.uint32Age) : 0,
      uint32Distance: isSet(object.uint32Distance) ? globalThis.Number(object.uint32Distance) : 0,
    };
  },

  toJSON(message: PubGroup): unknown {
    const obj: any = {};
    if (message.bytesNickname !== undefined && message.bytesNickname.length !== 0) {
      obj.bytesNickname = base64FromBytes(message.bytesNickname);
    }
    if (message.uint32Gender !== undefined && message.uint32Gender !== 0) {
      obj.uint32Gender = Math.round(message.uint32Gender);
    }
    if (message.uint32Age !== undefined && message.uint32Age !== 0) {
      obj.uint32Age = Math.round(message.uint32Age);
    }
    if (message.uint32Distance !== undefined && message.uint32Distance !== 0) {
      obj.uint32Distance = Math.round(message.uint32Distance);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<PubGroup>, I>>(base?: I): PubGroup {
    return PubGroup.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<PubGroup>, I>>(object: I): PubGroup {
    const message = createBasePubGroup();
    message.bytesNickname = object.bytesNickname ?? new Uint8Array(0);
    message.uint32Gender = object.uint32Gender ?? 0;
    message.uint32Age = object.uint32Age ?? 0;
    message.uint32Distance = object.uint32Distance ?? 0;
    return message;
  },
};

function createBaseMsgBodySubtype4(): MsgBodySubtype4 {
  return { msgNotOnlineFile: undefined, uint32MsgTime: 0 };
}

export const MsgBodySubtype4: MessageFns<MsgBodySubtype4> = {
  encode(message: MsgBodySubtype4, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.msgNotOnlineFile !== undefined) {
      NotOnlineFile.encode(message.msgNotOnlineFile, writer.uint32(10).fork()).join();
    }
    if (message.uint32MsgTime !== undefined && message.uint32MsgTime !== 0) {
      writer.uint32(16).uint32(message.uint32MsgTime);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgBodySubtype4 {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgBodySubtype4();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.msgNotOnlineFile = NotOnlineFile.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.uint32MsgTime = reader.uint32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MsgBodySubtype4 {
    return {
      msgNotOnlineFile: isSet(object.msgNotOnlineFile) ? NotOnlineFile.fromJSON(object.msgNotOnlineFile) : undefined,
      uint32MsgTime: isSet(object.uint32MsgTime) ? globalThis.Number(object.uint32MsgTime) : 0,
    };
  },

  toJSON(message: MsgBodySubtype4): unknown {
    const obj: any = {};
    if (message.msgNotOnlineFile !== undefined) {
      obj.msgNotOnlineFile = NotOnlineFile.toJSON(message.msgNotOnlineFile);
    }
    if (message.uint32MsgTime !== undefined && message.uint32MsgTime !== 0) {
      obj.uint32MsgTime = Math.round(message.uint32MsgTime);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MsgBodySubtype4>, I>>(base?: I): MsgBodySubtype4 {
    return MsgBodySubtype4.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MsgBodySubtype4>, I>>(object: I): MsgBodySubtype4 {
    const message = createBaseMsgBodySubtype4();
    message.msgNotOnlineFile = (object.msgNotOnlineFile !== undefined && object.msgNotOnlineFile !== null)
      ? NotOnlineFile.fromPartial(object.msgNotOnlineFile)
      : undefined;
    message.uint32MsgTime = object.uint32MsgTime ?? 0;
    return message;
  },
};

function createBaseTmpPtt(): TmpPtt {
  return {
    uint32FileType: 0,
    bytesFileUuid: new Uint8Array(0),
    bytesFileMd5: new Uint8Array(0),
    bytesFileName: new Uint8Array(0),
    uint32FileSize: 0,
    uint64PttTimes: 0,
    uint32UserType: 0,
    uint32PtttransFlag: 0,
    uint32BusiType: 0,
    uint64MsgId: 0,
    bytesPbReserve: new Uint8Array(0),
    pttEncodeData: new Uint8Array(0),
  };
}

export const TmpPtt: MessageFns<TmpPtt> = {
  encode(message: TmpPtt, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.uint32FileType !== undefined && message.uint32FileType !== 0) {
      writer.uint32(8).uint32(message.uint32FileType);
    }
    if (message.bytesFileUuid !== undefined && message.bytesFileUuid.length !== 0) {
      writer.uint32(18).bytes(message.bytesFileUuid);
    }
    if (message.bytesFileMd5 !== undefined && message.bytesFileMd5.length !== 0) {
      writer.uint32(26).bytes(message.bytesFileMd5);
    }
    if (message.bytesFileName !== undefined && message.bytesFileName.length !== 0) {
      writer.uint32(34).bytes(message.bytesFileName);
    }
    if (message.uint32FileSize !== undefined && message.uint32FileSize !== 0) {
      writer.uint32(40).uint32(message.uint32FileSize);
    }
    if (message.uint64PttTimes !== undefined && message.uint64PttTimes !== 0) {
      writer.uint32(48).uint32(message.uint64PttTimes);
    }
    if (message.uint32UserType !== undefined && message.uint32UserType !== 0) {
      writer.uint32(56).uint32(message.uint32UserType);
    }
    if (message.uint32PtttransFlag !== undefined && message.uint32PtttransFlag !== 0) {
      writer.uint32(64).uint32(message.uint32PtttransFlag);
    }
    if (message.uint32BusiType !== undefined && message.uint32BusiType !== 0) {
      writer.uint32(72).uint32(message.uint32BusiType);
    }
    if (message.uint64MsgId !== undefined && message.uint64MsgId !== 0) {
      writer.uint32(80).uint64(message.uint64MsgId);
    }
    if (message.bytesPbReserve !== undefined && message.bytesPbReserve.length !== 0) {
      writer.uint32(242).bytes(message.bytesPbReserve);
    }
    if (message.pttEncodeData !== undefined && message.pttEncodeData.length !== 0) {
      writer.uint32(250).bytes(message.pttEncodeData);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): TmpPtt {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTmpPtt();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.uint32FileType = reader.uint32();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.bytesFileUuid = reader.bytes();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.bytesFileMd5 = reader.bytes();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.bytesFileName = reader.bytes();
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.uint32FileSize = reader.uint32();
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.uint64PttTimes = reader.uint32();
          continue;
        }
        case 7: {
          if (tag !== 56) {
            break;
          }

          message.uint32UserType = reader.uint32();
          continue;
        }
        case 8: {
          if (tag !== 64) {
            break;
          }

          message.uint32PtttransFlag = reader.uint32();
          continue;
        }
        case 9: {
          if (tag !== 72) {
            break;
          }

          message.uint32BusiType = reader.uint32();
          continue;
        }
        case 10: {
          if (tag !== 80) {
            break;
          }

          message.uint64MsgId = longToNumber(reader.uint64());
          continue;
        }
        case 30: {
          if (tag !== 242) {
            break;
          }

          message.bytesPbReserve = reader.bytes();
          continue;
        }
        case 31: {
          if (tag !== 250) {
            break;
          }

          message.pttEncodeData = reader.bytes();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TmpPtt {
    return {
      uint32FileType: isSet(object.uint32FileType) ? globalThis.Number(object.uint32FileType) : 0,
      bytesFileUuid: isSet(object.bytesFileUuid) ? bytesFromBase64(object.bytesFileUuid) : new Uint8Array(0),
      bytesFileMd5: isSet(object.bytesFileMd5) ? bytesFromBase64(object.bytesFileMd5) : new Uint8Array(0),
      bytesFileName: isSet(object.bytesFileName) ? bytesFromBase64(object.bytesFileName) : new Uint8Array(0),
      uint32FileSize: isSet(object.uint32FileSize) ? globalThis.Number(object.uint32FileSize) : 0,
      uint64PttTimes: isSet(object.uint64PttTimes) ? globalThis.Number(object.uint64PttTimes) : 0,
      uint32UserType: isSet(object.uint32UserType) ? globalThis.Number(object.uint32UserType) : 0,
      uint32PtttransFlag: isSet(object.uint32PtttransFlag) ? globalThis.Number(object.uint32PtttransFlag) : 0,
      uint32BusiType: isSet(object.uint32BusiType) ? globalThis.Number(object.uint32BusiType) : 0,
      uint64MsgId: isSet(object.uint64MsgId) ? globalThis.Number(object.uint64MsgId) : 0,
      bytesPbReserve: isSet(object.bytesPbReserve) ? bytesFromBase64(object.bytesPbReserve) : new Uint8Array(0),
      pttEncodeData: isSet(object.pttEncodeData) ? bytesFromBase64(object.pttEncodeData) : new Uint8Array(0),
    };
  },

  toJSON(message: TmpPtt): unknown {
    const obj: any = {};
    if (message.uint32FileType !== undefined && message.uint32FileType !== 0) {
      obj.uint32FileType = Math.round(message.uint32FileType);
    }
    if (message.bytesFileUuid !== undefined && message.bytesFileUuid.length !== 0) {
      obj.bytesFileUuid = base64FromBytes(message.bytesFileUuid);
    }
    if (message.bytesFileMd5 !== undefined && message.bytesFileMd5.length !== 0) {
      obj.bytesFileMd5 = base64FromBytes(message.bytesFileMd5);
    }
    if (message.bytesFileName !== undefined && message.bytesFileName.length !== 0) {
      obj.bytesFileName = base64FromBytes(message.bytesFileName);
    }
    if (message.uint32FileSize !== undefined && message.uint32FileSize !== 0) {
      obj.uint32FileSize = Math.round(message.uint32FileSize);
    }
    if (message.uint64PttTimes !== undefined && message.uint64PttTimes !== 0) {
      obj.uint64PttTimes = Math.round(message.uint64PttTimes);
    }
    if (message.uint32UserType !== undefined && message.uint32UserType !== 0) {
      obj.uint32UserType = Math.round(message.uint32UserType);
    }
    if (message.uint32PtttransFlag !== undefined && message.uint32PtttransFlag !== 0) {
      obj.uint32PtttransFlag = Math.round(message.uint32PtttransFlag);
    }
    if (message.uint32BusiType !== undefined && message.uint32BusiType !== 0) {
      obj.uint32BusiType = Math.round(message.uint32BusiType);
    }
    if (message.uint64MsgId !== undefined && message.uint64MsgId !== 0) {
      obj.uint64MsgId = Math.round(message.uint64MsgId);
    }
    if (message.bytesPbReserve !== undefined && message.bytesPbReserve.length !== 0) {
      obj.bytesPbReserve = base64FromBytes(message.bytesPbReserve);
    }
    if (message.pttEncodeData !== undefined && message.pttEncodeData.length !== 0) {
      obj.pttEncodeData = base64FromBytes(message.pttEncodeData);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<TmpPtt>, I>>(base?: I): TmpPtt {
    return TmpPtt.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<TmpPtt>, I>>(object: I): TmpPtt {
    const message = createBaseTmpPtt();
    message.uint32FileType = object.uint32FileType ?? 0;
    message.bytesFileUuid = object.bytesFileUuid ?? new Uint8Array(0);
    message.bytesFileMd5 = object.bytesFileMd5 ?? new Uint8Array(0);
    message.bytesFileName = object.bytesFileName ?? new Uint8Array(0);
    message.uint32FileSize = object.uint32FileSize ?? 0;
    message.uint64PttTimes = object.uint64PttTimes ?? 0;
    message.uint32UserType = object.uint32UserType ?? 0;
    message.uint32PtttransFlag = object.uint32PtttransFlag ?? 0;
    message.uint32BusiType = object.uint32BusiType ?? 0;
    message.uint64MsgId = object.uint64MsgId ?? 0;
    message.bytesPbReserve = object.bytesPbReserve ?? new Uint8Array(0);
    message.pttEncodeData = object.pttEncodeData ?? new Uint8Array(0);
    return message;
  },
};

function createBaseShakeWindow(): ShakeWindow {
  return { uint32Type: 0, uint32Reserve: 0, uint64Uin: 0 };
}

export const ShakeWindow: MessageFns<ShakeWindow> = {
  encode(message: ShakeWindow, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.uint32Type !== undefined && message.uint32Type !== 0) {
      writer.uint32(8).uint32(message.uint32Type);
    }
    if (message.uint32Reserve !== undefined && message.uint32Reserve !== 0) {
      writer.uint32(16).uint32(message.uint32Reserve);
    }
    if (message.uint64Uin !== undefined && message.uint64Uin !== 0) {
      writer.uint32(24).uint64(message.uint64Uin);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ShakeWindow {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseShakeWindow();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.uint32Type = reader.uint32();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.uint32Reserve = reader.uint32();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.uint64Uin = longToNumber(reader.uint64());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ShakeWindow {
    return {
      uint32Type: isSet(object.uint32Type) ? globalThis.Number(object.uint32Type) : 0,
      uint32Reserve: isSet(object.uint32Reserve) ? globalThis.Number(object.uint32Reserve) : 0,
      uint64Uin: isSet(object.uint64Uin) ? globalThis.Number(object.uint64Uin) : 0,
    };
  },

  toJSON(message: ShakeWindow): unknown {
    const obj: any = {};
    if (message.uint32Type !== undefined && message.uint32Type !== 0) {
      obj.uint32Type = Math.round(message.uint32Type);
    }
    if (message.uint32Reserve !== undefined && message.uint32Reserve !== 0) {
      obj.uint32Reserve = Math.round(message.uint32Reserve);
    }
    if (message.uint64Uin !== undefined && message.uint64Uin !== 0) {
      obj.uint64Uin = Math.round(message.uint64Uin);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ShakeWindow>, I>>(base?: I): ShakeWindow {
    return ShakeWindow.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ShakeWindow>, I>>(object: I): ShakeWindow {
    const message = createBaseShakeWindow();
    message.uint32Type = object.uint32Type ?? 0;
    message.uint32Reserve = object.uint32Reserve ?? 0;
    message.uint64Uin = object.uint64Uin ?? 0;
    return message;
  },
};

function createBasePubAccount(): PubAccount {
  return { bytesBuf: new Uint8Array(0), uint64PubAccountUin: 0 };
}

export const PubAccount: MessageFns<PubAccount> = {
  encode(message: PubAccount, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.bytesBuf !== undefined && message.bytesBuf.length !== 0) {
      writer.uint32(10).bytes(message.bytesBuf);
    }
    if (message.uint64PubAccountUin !== undefined && message.uint64PubAccountUin !== 0) {
      writer.uint32(16).uint64(message.uint64PubAccountUin);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PubAccount {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePubAccount();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.bytesBuf = reader.bytes();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.uint64PubAccountUin = longToNumber(reader.uint64());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PubAccount {
    return {
      bytesBuf: isSet(object.bytesBuf) ? bytesFromBase64(object.bytesBuf) : new Uint8Array(0),
      uint64PubAccountUin: isSet(object.uint64PubAccountUin) ? globalThis.Number(object.uint64PubAccountUin) : 0,
    };
  },

  toJSON(message: PubAccount): unknown {
    const obj: any = {};
    if (message.bytesBuf !== undefined && message.bytesBuf.length !== 0) {
      obj.bytesBuf = base64FromBytes(message.bytesBuf);
    }
    if (message.uint64PubAccountUin !== undefined && message.uint64PubAccountUin !== 0) {
      obj.uint64PubAccountUin = Math.round(message.uint64PubAccountUin);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<PubAccount>, I>>(base?: I): PubAccount {
    return PubAccount.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<PubAccount>, I>>(object: I): PubAccount {
    const message = createBasePubAccount();
    message.bytesBuf = object.bytesBuf ?? new Uint8Array(0);
    message.uint64PubAccountUin = object.uint64PubAccountUin ?? 0;
    return message;
  },
};

function createBaseTipsInfo(): TipsInfo {
  return { text: "" };
}

export const TipsInfo: MessageFns<TipsInfo> = {
  encode(message: TipsInfo, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.text !== undefined && message.text !== "") {
      writer.uint32(10).string(message.text);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): TipsInfo {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTipsInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.text = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TipsInfo {
    return { text: isSet(object.text) ? globalThis.String(object.text) : "" };
  },

  toJSON(message: TipsInfo): unknown {
    const obj: any = {};
    if (message.text !== undefined && message.text !== "") {
      obj.text = message.text;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<TipsInfo>, I>>(base?: I): TipsInfo {
    return TipsInfo.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<TipsInfo>, I>>(object: I): TipsInfo {
    const message = createBaseTipsInfo();
    message.text = object.text ?? "";
    return message;
  },
};

function createBaseAnonymousGroupMsg(): AnonymousGroupMsg {
  return {
    uint32Flags: 0,
    strAnonId: new Uint8Array(0),
    strAnonNick: new Uint8Array(0),
    uint32HeadPortrait: 0,
    uint32ExpireTime: 0,
    uint32BubbleId: 0,
    strRankColor: new Uint8Array(0),
  };
}

export const AnonymousGroupMsg: MessageFns<AnonymousGroupMsg> = {
  encode(message: AnonymousGroupMsg, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.uint32Flags !== undefined && message.uint32Flags !== 0) {
      writer.uint32(8).uint32(message.uint32Flags);
    }
    if (message.strAnonId !== undefined && message.strAnonId.length !== 0) {
      writer.uint32(18).bytes(message.strAnonId);
    }
    if (message.strAnonNick !== undefined && message.strAnonNick.length !== 0) {
      writer.uint32(26).bytes(message.strAnonNick);
    }
    if (message.uint32HeadPortrait !== undefined && message.uint32HeadPortrait !== 0) {
      writer.uint32(32).uint32(message.uint32HeadPortrait);
    }
    if (message.uint32ExpireTime !== undefined && message.uint32ExpireTime !== 0) {
      writer.uint32(40).uint32(message.uint32ExpireTime);
    }
    if (message.uint32BubbleId !== undefined && message.uint32BubbleId !== 0) {
      writer.uint32(48).uint32(message.uint32BubbleId);
    }
    if (message.strRankColor !== undefined && message.strRankColor.length !== 0) {
      writer.uint32(58).bytes(message.strRankColor);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AnonymousGroupMsg {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAnonymousGroupMsg();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.uint32Flags = reader.uint32();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.strAnonId = reader.bytes();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.strAnonNick = reader.bytes();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.uint32HeadPortrait = reader.uint32();
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.uint32ExpireTime = reader.uint32();
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.uint32BubbleId = reader.uint32();
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.strRankColor = reader.bytes();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AnonymousGroupMsg {
    return {
      uint32Flags: isSet(object.uint32Flags) ? globalThis.Number(object.uint32Flags) : 0,
      strAnonId: isSet(object.strAnonId) ? bytesFromBase64(object.strAnonId) : new Uint8Array(0),
      strAnonNick: isSet(object.strAnonNick) ? bytesFromBase64(object.strAnonNick) : new Uint8Array(0),
      uint32HeadPortrait: isSet(object.uint32HeadPortrait) ? globalThis.Number(object.uint32HeadPortrait) : 0,
      uint32ExpireTime: isSet(object.uint32ExpireTime) ? globalThis.Number(object.uint32ExpireTime) : 0,
      uint32BubbleId: isSet(object.uint32BubbleId) ? globalThis.Number(object.uint32BubbleId) : 0,
      strRankColor: isSet(object.strRankColor) ? bytesFromBase64(object.strRankColor) : new Uint8Array(0),
    };
  },

  toJSON(message: AnonymousGroupMsg): unknown {
    const obj: any = {};
    if (message.uint32Flags !== undefined && message.uint32Flags !== 0) {
      obj.uint32Flags = Math.round(message.uint32Flags);
    }
    if (message.strAnonId !== undefined && message.strAnonId.length !== 0) {
      obj.strAnonId = base64FromBytes(message.strAnonId);
    }
    if (message.strAnonNick !== undefined && message.strAnonNick.length !== 0) {
      obj.strAnonNick = base64FromBytes(message.strAnonNick);
    }
    if (message.uint32HeadPortrait !== undefined && message.uint32HeadPortrait !== 0) {
      obj.uint32HeadPortrait = Math.round(message.uint32HeadPortrait);
    }
    if (message.uint32ExpireTime !== undefined && message.uint32ExpireTime !== 0) {
      obj.uint32ExpireTime = Math.round(message.uint32ExpireTime);
    }
    if (message.uint32BubbleId !== undefined && message.uint32BubbleId !== 0) {
      obj.uint32BubbleId = Math.round(message.uint32BubbleId);
    }
    if (message.strRankColor !== undefined && message.strRankColor.length !== 0) {
      obj.strRankColor = base64FromBytes(message.strRankColor);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<AnonymousGroupMsg>, I>>(base?: I): AnonymousGroupMsg {
    return AnonymousGroupMsg.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<AnonymousGroupMsg>, I>>(object: I): AnonymousGroupMsg {
    const message = createBaseAnonymousGroupMsg();
    message.uint32Flags = object.uint32Flags ?? 0;
    message.strAnonId = object.strAnonId ?? new Uint8Array(0);
    message.strAnonNick = object.strAnonNick ?? new Uint8Array(0);
    message.uint32HeadPortrait = object.uint32HeadPortrait ?? 0;
    message.uint32ExpireTime = object.uint32ExpireTime ?? 0;
    message.uint32BubbleId = object.uint32BubbleId ?? 0;
    message.strRankColor = object.strRankColor ?? new Uint8Array(0);
    return message;
  },
};

function createBaseQQLiveOld(): QQLiveOld {
  return {
    uint32SubCmd: 0,
    strShowText: new Uint8Array(0),
    strParam: new Uint8Array(0),
    strIntroduce: new Uint8Array(0),
  };
}

export const QQLiveOld: MessageFns<QQLiveOld> = {
  encode(message: QQLiveOld, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.uint32SubCmd !== undefined && message.uint32SubCmd !== 0) {
      writer.uint32(8).uint32(message.uint32SubCmd);
    }
    if (message.strShowText !== undefined && message.strShowText.length !== 0) {
      writer.uint32(18).bytes(message.strShowText);
    }
    if (message.strParam !== undefined && message.strParam.length !== 0) {
      writer.uint32(26).bytes(message.strParam);
    }
    if (message.strIntroduce !== undefined && message.strIntroduce.length !== 0) {
      writer.uint32(34).bytes(message.strIntroduce);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): QQLiveOld {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQQLiveOld();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.uint32SubCmd = reader.uint32();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.strShowText = reader.bytes();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.strParam = reader.bytes();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.strIntroduce = reader.bytes();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): QQLiveOld {
    return {
      uint32SubCmd: isSet(object.uint32SubCmd) ? globalThis.Number(object.uint32SubCmd) : 0,
      strShowText: isSet(object.strShowText) ? bytesFromBase64(object.strShowText) : new Uint8Array(0),
      strParam: isSet(object.strParam) ? bytesFromBase64(object.strParam) : new Uint8Array(0),
      strIntroduce: isSet(object.strIntroduce) ? bytesFromBase64(object.strIntroduce) : new Uint8Array(0),
    };
  },

  toJSON(message: QQLiveOld): unknown {
    const obj: any = {};
    if (message.uint32SubCmd !== undefined && message.uint32SubCmd !== 0) {
      obj.uint32SubCmd = Math.round(message.uint32SubCmd);
    }
    if (message.strShowText !== undefined && message.strShowText.length !== 0) {
      obj.strShowText = base64FromBytes(message.strShowText);
    }
    if (message.strParam !== undefined && message.strParam.length !== 0) {
      obj.strParam = base64FromBytes(message.strParam);
    }
    if (message.strIntroduce !== undefined && message.strIntroduce.length !== 0) {
      obj.strIntroduce = base64FromBytes(message.strIntroduce);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<QQLiveOld>, I>>(base?: I): QQLiveOld {
    return QQLiveOld.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<QQLiveOld>, I>>(object: I): QQLiveOld {
    const message = createBaseQQLiveOld();
    message.uint32SubCmd = object.uint32SubCmd ?? 0;
    message.strShowText = object.strShowText ?? new Uint8Array(0);
    message.strParam = object.strParam ?? new Uint8Array(0);
    message.strIntroduce = object.strIntroduce ?? new Uint8Array(0);
    return message;
  },
};

function createBaseQQWalletMsg(): QQWalletMsg {
  return { aioBody: undefined };
}

export const QQWalletMsg: MessageFns<QQWalletMsg> = {
  encode(message: QQWalletMsg, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.aioBody !== undefined) {
      QQWalletAioBody.encode(message.aioBody, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): QQWalletMsg {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQQWalletMsg();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.aioBody = QQWalletAioBody.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): QQWalletMsg {
    return { aioBody: isSet(object.aioBody) ? QQWalletAioBody.fromJSON(object.aioBody) : undefined };
  },

  toJSON(message: QQWalletMsg): unknown {
    const obj: any = {};
    if (message.aioBody !== undefined) {
      obj.aioBody = QQWalletAioBody.toJSON(message.aioBody);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<QQWalletMsg>, I>>(base?: I): QQWalletMsg {
    return QQWalletMsg.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<QQWalletMsg>, I>>(object: I): QQWalletMsg {
    const message = createBaseQQWalletMsg();
    message.aioBody = (object.aioBody !== undefined && object.aioBody !== null)
      ? QQWalletAioBody.fromPartial(object.aioBody)
      : undefined;
    return message;
  },
};

function createBaseQQWalletAioBody(): QQWalletAioBody {
  return {
    uint64Senduin: 0,
    sender: undefined,
    receiver: undefined,
    sint32Channelid: 0,
    sint32Templateid: 0,
    uint32Resend: 0,
    uint32MsgPriority: 0,
    sint32Redtype: 0,
    bytesBillno: new Uint8Array(0),
    bytesAuthkey: new Uint8Array(0),
    sint32Sessiontype: 0,
    sint32Msgtype: 0,
    sint32Envelopeid: 0,
    bytesName: new Uint8Array(0),
    sint32Conftype: 0,
    sint32MsgFrom: 0,
    bytesPcBody: new Uint8Array(0),
    stringIndex: new Uint8Array(0),
    uint32Redchannel: 0,
    uint64GrapUin: [],
    bytesPbReserve: new Uint8Array(0),
  };
}

export const QQWalletAioBody: MessageFns<QQWalletAioBody> = {
  encode(message: QQWalletAioBody, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.uint64Senduin !== undefined && message.uint64Senduin !== 0) {
      writer.uint32(8).uint64(message.uint64Senduin);
    }
    if (message.sender !== undefined) {
      QQWalletAioElem.encode(message.sender, writer.uint32(18).fork()).join();
    }
    if (message.receiver !== undefined) {
      QQWalletAioElem.encode(message.receiver, writer.uint32(26).fork()).join();
    }
    if (message.sint32Channelid !== undefined && message.sint32Channelid !== 0) {
      writer.uint32(32).sint32(message.sint32Channelid);
    }
    if (message.sint32Templateid !== undefined && message.sint32Templateid !== 0) {
      writer.uint32(40).sint32(message.sint32Templateid);
    }
    if (message.uint32Resend !== undefined && message.uint32Resend !== 0) {
      writer.uint32(48).uint32(message.uint32Resend);
    }
    if (message.uint32MsgPriority !== undefined && message.uint32MsgPriority !== 0) {
      writer.uint32(56).uint32(message.uint32MsgPriority);
    }
    if (message.sint32Redtype !== undefined && message.sint32Redtype !== 0) {
      writer.uint32(64).sint32(message.sint32Redtype);
    }
    if (message.bytesBillno !== undefined && message.bytesBillno.length !== 0) {
      writer.uint32(74).bytes(message.bytesBillno);
    }
    if (message.bytesAuthkey !== undefined && message.bytesAuthkey.length !== 0) {
      writer.uint32(82).bytes(message.bytesAuthkey);
    }
    if (message.sint32Sessiontype !== undefined && message.sint32Sessiontype !== 0) {
      writer.uint32(88).sint32(message.sint32Sessiontype);
    }
    if (message.sint32Msgtype !== undefined && message.sint32Msgtype !== 0) {
      writer.uint32(96).sint32(message.sint32Msgtype);
    }
    if (message.sint32Envelopeid !== undefined && message.sint32Envelopeid !== 0) {
      writer.uint32(104).sint32(message.sint32Envelopeid);
    }
    if (message.bytesName !== undefined && message.bytesName.length !== 0) {
      writer.uint32(114).bytes(message.bytesName);
    }
    if (message.sint32Conftype !== undefined && message.sint32Conftype !== 0) {
      writer.uint32(120).sint32(message.sint32Conftype);
    }
    if (message.sint32MsgFrom !== undefined && message.sint32MsgFrom !== 0) {
      writer.uint32(128).sint32(message.sint32MsgFrom);
    }
    if (message.bytesPcBody !== undefined && message.bytesPcBody.length !== 0) {
      writer.uint32(138).bytes(message.bytesPcBody);
    }
    if (message.stringIndex !== undefined && message.stringIndex.length !== 0) {
      writer.uint32(146).bytes(message.stringIndex);
    }
    if (message.uint32Redchannel !== undefined && message.uint32Redchannel !== 0) {
      writer.uint32(152).uint32(message.uint32Redchannel);
    }
    writer.uint32(162).fork();
    for (const v of message.uint64GrapUin) {
      writer.uint64(v);
    }
    writer.join();
    if (message.bytesPbReserve !== undefined && message.bytesPbReserve.length !== 0) {
      writer.uint32(170).bytes(message.bytesPbReserve);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): QQWalletAioBody {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQQWalletAioBody();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.uint64Senduin = longToNumber(reader.uint64());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.sender = QQWalletAioElem.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.receiver = QQWalletAioElem.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.sint32Channelid = reader.sint32();
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.sint32Templateid = reader.sint32();
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.uint32Resend = reader.uint32();
          continue;
        }
        case 7: {
          if (tag !== 56) {
            break;
          }

          message.uint32MsgPriority = reader.uint32();
          continue;
        }
        case 8: {
          if (tag !== 64) {
            break;
          }

          message.sint32Redtype = reader.sint32();
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.bytesBillno = reader.bytes();
          continue;
        }
        case 10: {
          if (tag !== 82) {
            break;
          }

          message.bytesAuthkey = reader.bytes();
          continue;
        }
        case 11: {
          if (tag !== 88) {
            break;
          }

          message.sint32Sessiontype = reader.sint32();
          continue;
        }
        case 12: {
          if (tag !== 96) {
            break;
          }

          message.sint32Msgtype = reader.sint32();
          continue;
        }
        case 13: {
          if (tag !== 104) {
            break;
          }

          message.sint32Envelopeid = reader.sint32();
          continue;
        }
        case 14: {
          if (tag !== 114) {
            break;
          }

          message.bytesName = reader.bytes();
          continue;
        }
        case 15: {
          if (tag !== 120) {
            break;
          }

          message.sint32Conftype = reader.sint32();
          continue;
        }
        case 16: {
          if (tag !== 128) {
            break;
          }

          message.sint32MsgFrom = reader.sint32();
          continue;
        }
        case 17: {
          if (tag !== 138) {
            break;
          }

          message.bytesPcBody = reader.bytes();
          continue;
        }
        case 18: {
          if (tag !== 146) {
            break;
          }

          message.stringIndex = reader.bytes();
          continue;
        }
        case 19: {
          if (tag !== 152) {
            break;
          }

          message.uint32Redchannel = reader.uint32();
          continue;
        }
        case 20: {
          if (tag === 160) {
            message.uint64GrapUin.push(longToNumber(reader.uint64()));

            continue;
          }

          if (tag === 162) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.uint64GrapUin.push(longToNumber(reader.uint64()));
            }

            continue;
          }

          break;
        }
        case 21: {
          if (tag !== 170) {
            break;
          }

          message.bytesPbReserve = reader.bytes();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): QQWalletAioBody {
    return {
      uint64Senduin: isSet(object.uint64Senduin) ? globalThis.Number(object.uint64Senduin) : 0,
      sender: isSet(object.sender) ? QQWalletAioElem.fromJSON(object.sender) : undefined,
      receiver: isSet(object.receiver) ? QQWalletAioElem.fromJSON(object.receiver) : undefined,
      sint32Channelid: isSet(object.sint32Channelid) ? globalThis.Number(object.sint32Channelid) : 0,
      sint32Templateid: isSet(object.sint32Templateid) ? globalThis.Number(object.sint32Templateid) : 0,
      uint32Resend: isSet(object.uint32Resend) ? globalThis.Number(object.uint32Resend) : 0,
      uint32MsgPriority: isSet(object.uint32MsgPriority) ? globalThis.Number(object.uint32MsgPriority) : 0,
      sint32Redtype: isSet(object.sint32Redtype) ? globalThis.Number(object.sint32Redtype) : 0,
      bytesBillno: isSet(object.bytesBillno) ? bytesFromBase64(object.bytesBillno) : new Uint8Array(0),
      bytesAuthkey: isSet(object.bytesAuthkey) ? bytesFromBase64(object.bytesAuthkey) : new Uint8Array(0),
      sint32Sessiontype: isSet(object.sint32Sessiontype) ? globalThis.Number(object.sint32Sessiontype) : 0,
      sint32Msgtype: isSet(object.sint32Msgtype) ? globalThis.Number(object.sint32Msgtype) : 0,
      sint32Envelopeid: isSet(object.sint32Envelopeid) ? globalThis.Number(object.sint32Envelopeid) : 0,
      bytesName: isSet(object.bytesName) ? bytesFromBase64(object.bytesName) : new Uint8Array(0),
      sint32Conftype: isSet(object.sint32Conftype) ? globalThis.Number(object.sint32Conftype) : 0,
      sint32MsgFrom: isSet(object.sint32MsgFrom) ? globalThis.Number(object.sint32MsgFrom) : 0,
      bytesPcBody: isSet(object.bytesPcBody) ? bytesFromBase64(object.bytesPcBody) : new Uint8Array(0),
      stringIndex: isSet(object.stringIndex) ? bytesFromBase64(object.stringIndex) : new Uint8Array(0),
      uint32Redchannel: isSet(object.uint32Redchannel) ? globalThis.Number(object.uint32Redchannel) : 0,
      uint64GrapUin: globalThis.Array.isArray(object?.uint64GrapUin)
        ? object.uint64GrapUin.map((e: any) => globalThis.Number(e))
        : [],
      bytesPbReserve: isSet(object.bytesPbReserve) ? bytesFromBase64(object.bytesPbReserve) : new Uint8Array(0),
    };
  },

  toJSON(message: QQWalletAioBody): unknown {
    const obj: any = {};
    if (message.uint64Senduin !== undefined && message.uint64Senduin !== 0) {
      obj.uint64Senduin = Math.round(message.uint64Senduin);
    }
    if (message.sender !== undefined) {
      obj.sender = QQWalletAioElem.toJSON(message.sender);
    }
    if (message.receiver !== undefined) {
      obj.receiver = QQWalletAioElem.toJSON(message.receiver);
    }
    if (message.sint32Channelid !== undefined && message.sint32Channelid !== 0) {
      obj.sint32Channelid = Math.round(message.sint32Channelid);
    }
    if (message.sint32Templateid !== undefined && message.sint32Templateid !== 0) {
      obj.sint32Templateid = Math.round(message.sint32Templateid);
    }
    if (message.uint32Resend !== undefined && message.uint32Resend !== 0) {
      obj.uint32Resend = Math.round(message.uint32Resend);
    }
    if (message.uint32MsgPriority !== undefined && message.uint32MsgPriority !== 0) {
      obj.uint32MsgPriority = Math.round(message.uint32MsgPriority);
    }
    if (message.sint32Redtype !== undefined && message.sint32Redtype !== 0) {
      obj.sint32Redtype = Math.round(message.sint32Redtype);
    }
    if (message.bytesBillno !== undefined && message.bytesBillno.length !== 0) {
      obj.bytesBillno = base64FromBytes(message.bytesBillno);
    }
    if (message.bytesAuthkey !== undefined && message.bytesAuthkey.length !== 0) {
      obj.bytesAuthkey = base64FromBytes(message.bytesAuthkey);
    }
    if (message.sint32Sessiontype !== undefined && message.sint32Sessiontype !== 0) {
      obj.sint32Sessiontype = Math.round(message.sint32Sessiontype);
    }
    if (message.sint32Msgtype !== undefined && message.sint32Msgtype !== 0) {
      obj.sint32Msgtype = Math.round(message.sint32Msgtype);
    }
    if (message.sint32Envelopeid !== undefined && message.sint32Envelopeid !== 0) {
      obj.sint32Envelopeid = Math.round(message.sint32Envelopeid);
    }
    if (message.bytesName !== undefined && message.bytesName.length !== 0) {
      obj.bytesName = base64FromBytes(message.bytesName);
    }
    if (message.sint32Conftype !== undefined && message.sint32Conftype !== 0) {
      obj.sint32Conftype = Math.round(message.sint32Conftype);
    }
    if (message.sint32MsgFrom !== undefined && message.sint32MsgFrom !== 0) {
      obj.sint32MsgFrom = Math.round(message.sint32MsgFrom);
    }
    if (message.bytesPcBody !== undefined && message.bytesPcBody.length !== 0) {
      obj.bytesPcBody = base64FromBytes(message.bytesPcBody);
    }
    if (message.stringIndex !== undefined && message.stringIndex.length !== 0) {
      obj.stringIndex = base64FromBytes(message.stringIndex);
    }
    if (message.uint32Redchannel !== undefined && message.uint32Redchannel !== 0) {
      obj.uint32Redchannel = Math.round(message.uint32Redchannel);
    }
    if (message.uint64GrapUin?.length) {
      obj.uint64GrapUin = message.uint64GrapUin.map((e) => Math.round(e));
    }
    if (message.bytesPbReserve !== undefined && message.bytesPbReserve.length !== 0) {
      obj.bytesPbReserve = base64FromBytes(message.bytesPbReserve);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<QQWalletAioBody>, I>>(base?: I): QQWalletAioBody {
    return QQWalletAioBody.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<QQWalletAioBody>, I>>(object: I): QQWalletAioBody {
    const message = createBaseQQWalletAioBody();
    message.uint64Senduin = object.uint64Senduin ?? 0;
    message.sender = (object.sender !== undefined && object.sender !== null)
      ? QQWalletAioElem.fromPartial(object.sender)
      : undefined;
    message.receiver = (object.receiver !== undefined && object.receiver !== null)
      ? QQWalletAioElem.fromPartial(object.receiver)
      : undefined;
    message.sint32Channelid = object.sint32Channelid ?? 0;
    message.sint32Templateid = object.sint32Templateid ?? 0;
    message.uint32Resend = object.uint32Resend ?? 0;
    message.uint32MsgPriority = object.uint32MsgPriority ?? 0;
    message.sint32Redtype = object.sint32Redtype ?? 0;
    message.bytesBillno = object.bytesBillno ?? new Uint8Array(0);
    message.bytesAuthkey = object.bytesAuthkey ?? new Uint8Array(0);
    message.sint32Sessiontype = object.sint32Sessiontype ?? 0;
    message.sint32Msgtype = object.sint32Msgtype ?? 0;
    message.sint32Envelopeid = object.sint32Envelopeid ?? 0;
    message.bytesName = object.bytesName ?? new Uint8Array(0);
    message.sint32Conftype = object.sint32Conftype ?? 0;
    message.sint32MsgFrom = object.sint32MsgFrom ?? 0;
    message.bytesPcBody = object.bytesPcBody ?? new Uint8Array(0);
    message.stringIndex = object.stringIndex ?? new Uint8Array(0);
    message.uint32Redchannel = object.uint32Redchannel ?? 0;
    message.uint64GrapUin = object.uint64GrapUin?.map((e) => e) || [];
    message.bytesPbReserve = object.bytesPbReserve ?? new Uint8Array(0);
    return message;
  },
};

function createBaseQQWalletAioElem(): QQWalletAioElem {
  return {
    uint32Background: 0,
    uint32Icon: 0,
    bytesTitle: new Uint8Array(0),
    bytesSubtitle: new Uint8Array(0),
    bytesContent: new Uint8Array(0),
    bytesLinkurl: new Uint8Array(0),
    bytesBlackstripe: new Uint8Array(0),
    bytesNotice: new Uint8Array(0),
    uint32TitleColor: 0,
    uint32SubtitleColor: 0,
    bytesActionsPriority: new Uint8Array(0),
    bytesJumpUrl: new Uint8Array(0),
    bytesNativeIos: new Uint8Array(0),
    bytesNativeAndroid: new Uint8Array(0),
    bytesIconurl: new Uint8Array(0),
    uint32ContentColor: 0,
    uint32ContentBgcolor: 0,
    bytesAioImageLeft: new Uint8Array(0),
    bytesAioImageRight: new Uint8Array(0),
    bytesCftImage: new Uint8Array(0),
    bytesPbReserve: new Uint8Array(0),
  };
}

export const QQWalletAioElem: MessageFns<QQWalletAioElem> = {
  encode(message: QQWalletAioElem, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.uint32Background !== undefined && message.uint32Background !== 0) {
      writer.uint32(8).uint32(message.uint32Background);
    }
    if (message.uint32Icon !== undefined && message.uint32Icon !== 0) {
      writer.uint32(16).uint32(message.uint32Icon);
    }
    if (message.bytesTitle !== undefined && message.bytesTitle.length !== 0) {
      writer.uint32(26).bytes(message.bytesTitle);
    }
    if (message.bytesSubtitle !== undefined && message.bytesSubtitle.length !== 0) {
      writer.uint32(34).bytes(message.bytesSubtitle);
    }
    if (message.bytesContent !== undefined && message.bytesContent.length !== 0) {
      writer.uint32(42).bytes(message.bytesContent);
    }
    if (message.bytesLinkurl !== undefined && message.bytesLinkurl.length !== 0) {
      writer.uint32(50).bytes(message.bytesLinkurl);
    }
    if (message.bytesBlackstripe !== undefined && message.bytesBlackstripe.length !== 0) {
      writer.uint32(58).bytes(message.bytesBlackstripe);
    }
    if (message.bytesNotice !== undefined && message.bytesNotice.length !== 0) {
      writer.uint32(66).bytes(message.bytesNotice);
    }
    if (message.uint32TitleColor !== undefined && message.uint32TitleColor !== 0) {
      writer.uint32(72).uint32(message.uint32TitleColor);
    }
    if (message.uint32SubtitleColor !== undefined && message.uint32SubtitleColor !== 0) {
      writer.uint32(80).uint32(message.uint32SubtitleColor);
    }
    if (message.bytesActionsPriority !== undefined && message.bytesActionsPriority.length !== 0) {
      writer.uint32(90).bytes(message.bytesActionsPriority);
    }
    if (message.bytesJumpUrl !== undefined && message.bytesJumpUrl.length !== 0) {
      writer.uint32(98).bytes(message.bytesJumpUrl);
    }
    if (message.bytesNativeIos !== undefined && message.bytesNativeIos.length !== 0) {
      writer.uint32(106).bytes(message.bytesNativeIos);
    }
    if (message.bytesNativeAndroid !== undefined && message.bytesNativeAndroid.length !== 0) {
      writer.uint32(114).bytes(message.bytesNativeAndroid);
    }
    if (message.bytesIconurl !== undefined && message.bytesIconurl.length !== 0) {
      writer.uint32(122).bytes(message.bytesIconurl);
    }
    if (message.uint32ContentColor !== undefined && message.uint32ContentColor !== 0) {
      writer.uint32(128).uint32(message.uint32ContentColor);
    }
    if (message.uint32ContentBgcolor !== undefined && message.uint32ContentBgcolor !== 0) {
      writer.uint32(136).uint32(message.uint32ContentBgcolor);
    }
    if (message.bytesAioImageLeft !== undefined && message.bytesAioImageLeft.length !== 0) {
      writer.uint32(146).bytes(message.bytesAioImageLeft);
    }
    if (message.bytesAioImageRight !== undefined && message.bytesAioImageRight.length !== 0) {
      writer.uint32(154).bytes(message.bytesAioImageRight);
    }
    if (message.bytesCftImage !== undefined && message.bytesCftImage.length !== 0) {
      writer.uint32(162).bytes(message.bytesCftImage);
    }
    if (message.bytesPbReserve !== undefined && message.bytesPbReserve.length !== 0) {
      writer.uint32(170).bytes(message.bytesPbReserve);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): QQWalletAioElem {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQQWalletAioElem();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.uint32Background = reader.uint32();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.uint32Icon = reader.uint32();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.bytesTitle = reader.bytes();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.bytesSubtitle = reader.bytes();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.bytesContent = reader.bytes();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.bytesLinkurl = reader.bytes();
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.bytesBlackstripe = reader.bytes();
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.bytesNotice = reader.bytes();
          continue;
        }
        case 9: {
          if (tag !== 72) {
            break;
          }

          message.uint32TitleColor = reader.uint32();
          continue;
        }
        case 10: {
          if (tag !== 80) {
            break;
          }

          message.uint32SubtitleColor = reader.uint32();
          continue;
        }
        case 11: {
          if (tag !== 90) {
            break;
          }

          message.bytesActionsPriority = reader.bytes();
          continue;
        }
        case 12: {
          if (tag !== 98) {
            break;
          }

          message.bytesJumpUrl = reader.bytes();
          continue;
        }
        case 13: {
          if (tag !== 106) {
            break;
          }

          message.bytesNativeIos = reader.bytes();
          continue;
        }
        case 14: {
          if (tag !== 114) {
            break;
          }

          message.bytesNativeAndroid = reader.bytes();
          continue;
        }
        case 15: {
          if (tag !== 122) {
            break;
          }

          message.bytesIconurl = reader.bytes();
          continue;
        }
        case 16: {
          if (tag !== 128) {
            break;
          }

          message.uint32ContentColor = reader.uint32();
          continue;
        }
        case 17: {
          if (tag !== 136) {
            break;
          }

          message.uint32ContentBgcolor = reader.uint32();
          continue;
        }
        case 18: {
          if (tag !== 146) {
            break;
          }

          message.bytesAioImageLeft = reader.bytes();
          continue;
        }
        case 19: {
          if (tag !== 154) {
            break;
          }

          message.bytesAioImageRight = reader.bytes();
          continue;
        }
        case 20: {
          if (tag !== 162) {
            break;
          }

          message.bytesCftImage = reader.bytes();
          continue;
        }
        case 21: {
          if (tag !== 170) {
            break;
          }

          message.bytesPbReserve = reader.bytes();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): QQWalletAioElem {
    return {
      uint32Background: isSet(object.uint32Background) ? globalThis.Number(object.uint32Background) : 0,
      uint32Icon: isSet(object.uint32Icon) ? globalThis.Number(object.uint32Icon) : 0,
      bytesTitle: isSet(object.bytesTitle) ? bytesFromBase64(object.bytesTitle) : new Uint8Array(0),
      bytesSubtitle: isSet(object.bytesSubtitle) ? bytesFromBase64(object.bytesSubtitle) : new Uint8Array(0),
      bytesContent: isSet(object.bytesContent) ? bytesFromBase64(object.bytesContent) : new Uint8Array(0),
      bytesLinkurl: isSet(object.bytesLinkurl) ? bytesFromBase64(object.bytesLinkurl) : new Uint8Array(0),
      bytesBlackstripe: isSet(object.bytesBlackstripe) ? bytesFromBase64(object.bytesBlackstripe) : new Uint8Array(0),
      bytesNotice: isSet(object.bytesNotice) ? bytesFromBase64(object.bytesNotice) : new Uint8Array(0),
      uint32TitleColor: isSet(object.uint32TitleColor) ? globalThis.Number(object.uint32TitleColor) : 0,
      uint32SubtitleColor: isSet(object.uint32SubtitleColor) ? globalThis.Number(object.uint32SubtitleColor) : 0,
      bytesActionsPriority: isSet(object.bytesActionsPriority)
        ? bytesFromBase64(object.bytesActionsPriority)
        : new Uint8Array(0),
      bytesJumpUrl: isSet(object.bytesJumpUrl) ? bytesFromBase64(object.bytesJumpUrl) : new Uint8Array(0),
      bytesNativeIos: isSet(object.bytesNativeIos) ? bytesFromBase64(object.bytesNativeIos) : new Uint8Array(0),
      bytesNativeAndroid: isSet(object.bytesNativeAndroid)
        ? bytesFromBase64(object.bytesNativeAndroid)
        : new Uint8Array(0),
      bytesIconurl: isSet(object.bytesIconurl) ? bytesFromBase64(object.bytesIconurl) : new Uint8Array(0),
      uint32ContentColor: isSet(object.uint32ContentColor) ? globalThis.Number(object.uint32ContentColor) : 0,
      uint32ContentBgcolor: isSet(object.uint32ContentBgcolor) ? globalThis.Number(object.uint32ContentBgcolor) : 0,
      bytesAioImageLeft: isSet(object.bytesAioImageLeft)
        ? bytesFromBase64(object.bytesAioImageLeft)
        : new Uint8Array(0),
      bytesAioImageRight: isSet(object.bytesAioImageRight)
        ? bytesFromBase64(object.bytesAioImageRight)
        : new Uint8Array(0),
      bytesCftImage: isSet(object.bytesCftImage) ? bytesFromBase64(object.bytesCftImage) : new Uint8Array(0),
      bytesPbReserve: isSet(object.bytesPbReserve) ? bytesFromBase64(object.bytesPbReserve) : new Uint8Array(0),
    };
  },

  toJSON(message: QQWalletAioElem): unknown {
    const obj: any = {};
    if (message.uint32Background !== undefined && message.uint32Background !== 0) {
      obj.uint32Background = Math.round(message.uint32Background);
    }
    if (message.uint32Icon !== undefined && message.uint32Icon !== 0) {
      obj.uint32Icon = Math.round(message.uint32Icon);
    }
    if (message.bytesTitle !== undefined && message.bytesTitle.length !== 0) {
      obj.bytesTitle = base64FromBytes(message.bytesTitle);
    }
    if (message.bytesSubtitle !== undefined && message.bytesSubtitle.length !== 0) {
      obj.bytesSubtitle = base64FromBytes(message.bytesSubtitle);
    }
    if (message.bytesContent !== undefined && message.bytesContent.length !== 0) {
      obj.bytesContent = base64FromBytes(message.bytesContent);
    }
    if (message.bytesLinkurl !== undefined && message.bytesLinkurl.length !== 0) {
      obj.bytesLinkurl = base64FromBytes(message.bytesLinkurl);
    }
    if (message.bytesBlackstripe !== undefined && message.bytesBlackstripe.length !== 0) {
      obj.bytesBlackstripe = base64FromBytes(message.bytesBlackstripe);
    }
    if (message.bytesNotice !== undefined && message.bytesNotice.length !== 0) {
      obj.bytesNotice = base64FromBytes(message.bytesNotice);
    }
    if (message.uint32TitleColor !== undefined && message.uint32TitleColor !== 0) {
      obj.uint32TitleColor = Math.round(message.uint32TitleColor);
    }
    if (message.uint32SubtitleColor !== undefined && message.uint32SubtitleColor !== 0) {
      obj.uint32SubtitleColor = Math.round(message.uint32SubtitleColor);
    }
    if (message.bytesActionsPriority !== undefined && message.bytesActionsPriority.length !== 0) {
      obj.bytesActionsPriority = base64FromBytes(message.bytesActionsPriority);
    }
    if (message.bytesJumpUrl !== undefined && message.bytesJumpUrl.length !== 0) {
      obj.bytesJumpUrl = base64FromBytes(message.bytesJumpUrl);
    }
    if (message.bytesNativeIos !== undefined && message.bytesNativeIos.length !== 0) {
      obj.bytesNativeIos = base64FromBytes(message.bytesNativeIos);
    }
    if (message.bytesNativeAndroid !== undefined && message.bytesNativeAndroid.length !== 0) {
      obj.bytesNativeAndroid = base64FromBytes(message.bytesNativeAndroid);
    }
    if (message.bytesIconurl !== undefined && message.bytesIconurl.length !== 0) {
      obj.bytesIconurl = base64FromBytes(message.bytesIconurl);
    }
    if (message.uint32ContentColor !== undefined && message.uint32ContentColor !== 0) {
      obj.uint32ContentColor = Math.round(message.uint32ContentColor);
    }
    if (message.uint32ContentBgcolor !== undefined && message.uint32ContentBgcolor !== 0) {
      obj.uint32ContentBgcolor = Math.round(message.uint32ContentBgcolor);
    }
    if (message.bytesAioImageLeft !== undefined && message.bytesAioImageLeft.length !== 0) {
      obj.bytesAioImageLeft = base64FromBytes(message.bytesAioImageLeft);
    }
    if (message.bytesAioImageRight !== undefined && message.bytesAioImageRight.length !== 0) {
      obj.bytesAioImageRight = base64FromBytes(message.bytesAioImageRight);
    }
    if (message.bytesCftImage !== undefined && message.bytesCftImage.length !== 0) {
      obj.bytesCftImage = base64FromBytes(message.bytesCftImage);
    }
    if (message.bytesPbReserve !== undefined && message.bytesPbReserve.length !== 0) {
      obj.bytesPbReserve = base64FromBytes(message.bytesPbReserve);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<QQWalletAioElem>, I>>(base?: I): QQWalletAioElem {
    return QQWalletAioElem.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<QQWalletAioElem>, I>>(object: I): QQWalletAioElem {
    const message = createBaseQQWalletAioElem();
    message.uint32Background = object.uint32Background ?? 0;
    message.uint32Icon = object.uint32Icon ?? 0;
    message.bytesTitle = object.bytesTitle ?? new Uint8Array(0);
    message.bytesSubtitle = object.bytesSubtitle ?? new Uint8Array(0);
    message.bytesContent = object.bytesContent ?? new Uint8Array(0);
    message.bytesLinkurl = object.bytesLinkurl ?? new Uint8Array(0);
    message.bytesBlackstripe = object.bytesBlackstripe ?? new Uint8Array(0);
    message.bytesNotice = object.bytesNotice ?? new Uint8Array(0);
    message.uint32TitleColor = object.uint32TitleColor ?? 0;
    message.uint32SubtitleColor = object.uint32SubtitleColor ?? 0;
    message.bytesActionsPriority = object.bytesActionsPriority ?? new Uint8Array(0);
    message.bytesJumpUrl = object.bytesJumpUrl ?? new Uint8Array(0);
    message.bytesNativeIos = object.bytesNativeIos ?? new Uint8Array(0);
    message.bytesNativeAndroid = object.bytesNativeAndroid ?? new Uint8Array(0);
    message.bytesIconurl = object.bytesIconurl ?? new Uint8Array(0);
    message.uint32ContentColor = object.uint32ContentColor ?? 0;
    message.uint32ContentBgcolor = object.uint32ContentBgcolor ?? 0;
    message.bytesAioImageLeft = object.bytesAioImageLeft ?? new Uint8Array(0);
    message.bytesAioImageRight = object.bytesAioImageRight ?? new Uint8Array(0);
    message.bytesCftImage = object.bytesCftImage ?? new Uint8Array(0);
    message.bytesPbReserve = object.bytesPbReserve ?? new Uint8Array(0);
    return message;
  },
};

function createBaseLifeOnlineAccount(): LifeOnlineAccount {
  return {
    uint64UniqueId: 0,
    uint32Op: 0,
    uint32ShowTime: 0,
    uint32Report: 0,
    uint32Ack: 0,
    uint64Bitmap: 0,
    gdtImpData: new Uint8Array(0),
    gdtCliData: new Uint8Array(0),
    viewId: new Uint8Array(0),
  };
}

export const LifeOnlineAccount: MessageFns<LifeOnlineAccount> = {
  encode(message: LifeOnlineAccount, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.uint64UniqueId !== undefined && message.uint64UniqueId !== 0) {
      writer.uint32(8).uint64(message.uint64UniqueId);
    }
    if (message.uint32Op !== undefined && message.uint32Op !== 0) {
      writer.uint32(16).uint32(message.uint32Op);
    }
    if (message.uint32ShowTime !== undefined && message.uint32ShowTime !== 0) {
      writer.uint32(24).uint32(message.uint32ShowTime);
    }
    if (message.uint32Report !== undefined && message.uint32Report !== 0) {
      writer.uint32(32).uint32(message.uint32Report);
    }
    if (message.uint32Ack !== undefined && message.uint32Ack !== 0) {
      writer.uint32(40).uint32(message.uint32Ack);
    }
    if (message.uint64Bitmap !== undefined && message.uint64Bitmap !== 0) {
      writer.uint32(48).uint64(message.uint64Bitmap);
    }
    if (message.gdtImpData !== undefined && message.gdtImpData.length !== 0) {
      writer.uint32(58).bytes(message.gdtImpData);
    }
    if (message.gdtCliData !== undefined && message.gdtCliData.length !== 0) {
      writer.uint32(66).bytes(message.gdtCliData);
    }
    if (message.viewId !== undefined && message.viewId.length !== 0) {
      writer.uint32(74).bytes(message.viewId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): LifeOnlineAccount {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseLifeOnlineAccount();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.uint64UniqueId = longToNumber(reader.uint64());
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.uint32Op = reader.uint32();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.uint32ShowTime = reader.uint32();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.uint32Report = reader.uint32();
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.uint32Ack = reader.uint32();
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.uint64Bitmap = longToNumber(reader.uint64());
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.gdtImpData = reader.bytes();
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.gdtCliData = reader.bytes();
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.viewId = reader.bytes();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): LifeOnlineAccount {
    return {
      uint64UniqueId: isSet(object.uint64UniqueId) ? globalThis.Number(object.uint64UniqueId) : 0,
      uint32Op: isSet(object.uint32Op) ? globalThis.Number(object.uint32Op) : 0,
      uint32ShowTime: isSet(object.uint32ShowTime) ? globalThis.Number(object.uint32ShowTime) : 0,
      uint32Report: isSet(object.uint32Report) ? globalThis.Number(object.uint32Report) : 0,
      uint32Ack: isSet(object.uint32Ack) ? globalThis.Number(object.uint32Ack) : 0,
      uint64Bitmap: isSet(object.uint64Bitmap) ? globalThis.Number(object.uint64Bitmap) : 0,
      gdtImpData: isSet(object.gdtImpData) ? bytesFromBase64(object.gdtImpData) : new Uint8Array(0),
      gdtCliData: isSet(object.gdtCliData) ? bytesFromBase64(object.gdtCliData) : new Uint8Array(0),
      viewId: isSet(object.viewId) ? bytesFromBase64(object.viewId) : new Uint8Array(0),
    };
  },

  toJSON(message: LifeOnlineAccount): unknown {
    const obj: any = {};
    if (message.uint64UniqueId !== undefined && message.uint64UniqueId !== 0) {
      obj.uint64UniqueId = Math.round(message.uint64UniqueId);
    }
    if (message.uint32Op !== undefined && message.uint32Op !== 0) {
      obj.uint32Op = Math.round(message.uint32Op);
    }
    if (message.uint32ShowTime !== undefined && message.uint32ShowTime !== 0) {
      obj.uint32ShowTime = Math.round(message.uint32ShowTime);
    }
    if (message.uint32Report !== undefined && message.uint32Report !== 0) {
      obj.uint32Report = Math.round(message.uint32Report);
    }
    if (message.uint32Ack !== undefined && message.uint32Ack !== 0) {
      obj.uint32Ack = Math.round(message.uint32Ack);
    }
    if (message.uint64Bitmap !== undefined && message.uint64Bitmap !== 0) {
      obj.uint64Bitmap = Math.round(message.uint64Bitmap);
    }
    if (message.gdtImpData !== undefined && message.gdtImpData.length !== 0) {
      obj.gdtImpData = base64FromBytes(message.gdtImpData);
    }
    if (message.gdtCliData !== undefined && message.gdtCliData.length !== 0) {
      obj.gdtCliData = base64FromBytes(message.gdtCliData);
    }
    if (message.viewId !== undefined && message.viewId.length !== 0) {
      obj.viewId = base64FromBytes(message.viewId);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<LifeOnlineAccount>, I>>(base?: I): LifeOnlineAccount {
    return LifeOnlineAccount.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<LifeOnlineAccount>, I>>(object: I): LifeOnlineAccount {
    const message = createBaseLifeOnlineAccount();
    message.uint64UniqueId = object.uint64UniqueId ?? 0;
    message.uint32Op = object.uint32Op ?? 0;
    message.uint32ShowTime = object.uint32ShowTime ?? 0;
    message.uint32Report = object.uint32Report ?? 0;
    message.uint32Ack = object.uint32Ack ?? 0;
    message.uint64Bitmap = object.uint64Bitmap ?? 0;
    message.gdtImpData = object.gdtImpData ?? new Uint8Array(0);
    message.gdtCliData = object.gdtCliData ?? new Uint8Array(0);
    message.viewId = object.viewId ?? new Uint8Array(0);
    return message;
  },
};

function createBaseCrmElem(): CrmElem {
  return {
    crmBuf: new Uint8Array(0),
    bytesMsgResid: new Uint8Array(0),
    uint32QidianFlag: 0,
    uint32PushFlag: 0,
    uint32CountFlag: 0,
  };
}

export const CrmElem: MessageFns<CrmElem> = {
  encode(message: CrmElem, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.crmBuf !== undefined && message.crmBuf.length !== 0) {
      writer.uint32(10).bytes(message.crmBuf);
    }
    if (message.bytesMsgResid !== undefined && message.bytesMsgResid.length !== 0) {
      writer.uint32(18).bytes(message.bytesMsgResid);
    }
    if (message.uint32QidianFlag !== undefined && message.uint32QidianFlag !== 0) {
      writer.uint32(24).uint32(message.uint32QidianFlag);
    }
    if (message.uint32PushFlag !== undefined && message.uint32PushFlag !== 0) {
      writer.uint32(32).uint32(message.uint32PushFlag);
    }
    if (message.uint32CountFlag !== undefined && message.uint32CountFlag !== 0) {
      writer.uint32(40).uint32(message.uint32CountFlag);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CrmElem {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCrmElem();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.crmBuf = reader.bytes();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.bytesMsgResid = reader.bytes();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.uint32QidianFlag = reader.uint32();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.uint32PushFlag = reader.uint32();
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.uint32CountFlag = reader.uint32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CrmElem {
    return {
      crmBuf: isSet(object.crmBuf) ? bytesFromBase64(object.crmBuf) : new Uint8Array(0),
      bytesMsgResid: isSet(object.bytesMsgResid) ? bytesFromBase64(object.bytesMsgResid) : new Uint8Array(0),
      uint32QidianFlag: isSet(object.uint32QidianFlag) ? globalThis.Number(object.uint32QidianFlag) : 0,
      uint32PushFlag: isSet(object.uint32PushFlag) ? globalThis.Number(object.uint32PushFlag) : 0,
      uint32CountFlag: isSet(object.uint32CountFlag) ? globalThis.Number(object.uint32CountFlag) : 0,
    };
  },

  toJSON(message: CrmElem): unknown {
    const obj: any = {};
    if (message.crmBuf !== undefined && message.crmBuf.length !== 0) {
      obj.crmBuf = base64FromBytes(message.crmBuf);
    }
    if (message.bytesMsgResid !== undefined && message.bytesMsgResid.length !== 0) {
      obj.bytesMsgResid = base64FromBytes(message.bytesMsgResid);
    }
    if (message.uint32QidianFlag !== undefined && message.uint32QidianFlag !== 0) {
      obj.uint32QidianFlag = Math.round(message.uint32QidianFlag);
    }
    if (message.uint32PushFlag !== undefined && message.uint32PushFlag !== 0) {
      obj.uint32PushFlag = Math.round(message.uint32PushFlag);
    }
    if (message.uint32CountFlag !== undefined && message.uint32CountFlag !== 0) {
      obj.uint32CountFlag = Math.round(message.uint32CountFlag);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CrmElem>, I>>(base?: I): CrmElem {
    return CrmElem.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CrmElem>, I>>(object: I): CrmElem {
    const message = createBaseCrmElem();
    message.crmBuf = object.crmBuf ?? new Uint8Array(0);
    message.bytesMsgResid = object.bytesMsgResid ?? new Uint8Array(0);
    message.uint32QidianFlag = object.uint32QidianFlag ?? 0;
    message.uint32PushFlag = object.uint32PushFlag ?? 0;
    message.uint32CountFlag = object.uint32CountFlag ?? 0;
    return message;
  },
};

function createBaseConferenceTipsInfo(): ConferenceTipsInfo {
  return { uint32SessionType: 0, uint64SessionUin: 0, strText: "" };
}

export const ConferenceTipsInfo: MessageFns<ConferenceTipsInfo> = {
  encode(message: ConferenceTipsInfo, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.uint32SessionType !== undefined && message.uint32SessionType !== 0) {
      writer.uint32(8).uint32(message.uint32SessionType);
    }
    if (message.uint64SessionUin !== undefined && message.uint64SessionUin !== 0) {
      writer.uint32(16).uint64(message.uint64SessionUin);
    }
    if (message.strText !== undefined && message.strText !== "") {
      writer.uint32(26).string(message.strText);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ConferenceTipsInfo {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseConferenceTipsInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.uint32SessionType = reader.uint32();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.uint64SessionUin = longToNumber(reader.uint64());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.strText = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ConferenceTipsInfo {
    return {
      uint32SessionType: isSet(object.uint32SessionType) ? globalThis.Number(object.uint32SessionType) : 0,
      uint64SessionUin: isSet(object.uint64SessionUin) ? globalThis.Number(object.uint64SessionUin) : 0,
      strText: isSet(object.strText) ? globalThis.String(object.strText) : "",
    };
  },

  toJSON(message: ConferenceTipsInfo): unknown {
    const obj: any = {};
    if (message.uint32SessionType !== undefined && message.uint32SessionType !== 0) {
      obj.uint32SessionType = Math.round(message.uint32SessionType);
    }
    if (message.uint64SessionUin !== undefined && message.uint64SessionUin !== 0) {
      obj.uint64SessionUin = Math.round(message.uint64SessionUin);
    }
    if (message.strText !== undefined && message.strText !== "") {
      obj.strText = message.strText;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ConferenceTipsInfo>, I>>(base?: I): ConferenceTipsInfo {
    return ConferenceTipsInfo.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ConferenceTipsInfo>, I>>(object: I): ConferenceTipsInfo {
    const message = createBaseConferenceTipsInfo();
    message.uint32SessionType = object.uint32SessionType ?? 0;
    message.uint64SessionUin = object.uint64SessionUin ?? 0;
    message.strText = object.strText ?? "";
    return message;
  },
};

function createBaseRedBagInfo(): RedBagInfo {
  return { redbagType: 0 };
}

export const RedBagInfo: MessageFns<RedBagInfo> = {
  encode(message: RedBagInfo, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.redbagType !== undefined && message.redbagType !== 0) {
      writer.uint32(8).uint32(message.redbagType);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RedBagInfo {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRedBagInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.redbagType = reader.uint32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RedBagInfo {
    return { redbagType: isSet(object.redbagType) ? globalThis.Number(object.redbagType) : 0 };
  },

  toJSON(message: RedBagInfo): unknown {
    const obj: any = {};
    if (message.redbagType !== undefined && message.redbagType !== 0) {
      obj.redbagType = Math.round(message.redbagType);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<RedBagInfo>, I>>(base?: I): RedBagInfo {
    return RedBagInfo.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<RedBagInfo>, I>>(object: I): RedBagInfo {
    const message = createBaseRedBagInfo();
    message.redbagType = object.redbagType ?? 0;
    return message;
  },
};

function createBaseLowVersionTips(): LowVersionTips {
  return { uint32BusinessId: 0, uint32SessionType: 0, uint64SessionUin: 0, uint64SenderUin: 0, strText: "" };
}

export const LowVersionTips: MessageFns<LowVersionTips> = {
  encode(message: LowVersionTips, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.uint32BusinessId !== undefined && message.uint32BusinessId !== 0) {
      writer.uint32(8).uint32(message.uint32BusinessId);
    }
    if (message.uint32SessionType !== undefined && message.uint32SessionType !== 0) {
      writer.uint32(16).uint32(message.uint32SessionType);
    }
    if (message.uint64SessionUin !== undefined && message.uint64SessionUin !== 0) {
      writer.uint32(24).uint64(message.uint64SessionUin);
    }
    if (message.uint64SenderUin !== undefined && message.uint64SenderUin !== 0) {
      writer.uint32(32).uint64(message.uint64SenderUin);
    }
    if (message.strText !== undefined && message.strText !== "") {
      writer.uint32(42).string(message.strText);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): LowVersionTips {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseLowVersionTips();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.uint32BusinessId = reader.uint32();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.uint32SessionType = reader.uint32();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.uint64SessionUin = longToNumber(reader.uint64());
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.uint64SenderUin = longToNumber(reader.uint64());
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.strText = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): LowVersionTips {
    return {
      uint32BusinessId: isSet(object.uint32BusinessId) ? globalThis.Number(object.uint32BusinessId) : 0,
      uint32SessionType: isSet(object.uint32SessionType) ? globalThis.Number(object.uint32SessionType) : 0,
      uint64SessionUin: isSet(object.uint64SessionUin) ? globalThis.Number(object.uint64SessionUin) : 0,
      uint64SenderUin: isSet(object.uint64SenderUin) ? globalThis.Number(object.uint64SenderUin) : 0,
      strText: isSet(object.strText) ? globalThis.String(object.strText) : "",
    };
  },

  toJSON(message: LowVersionTips): unknown {
    const obj: any = {};
    if (message.uint32BusinessId !== undefined && message.uint32BusinessId !== 0) {
      obj.uint32BusinessId = Math.round(message.uint32BusinessId);
    }
    if (message.uint32SessionType !== undefined && message.uint32SessionType !== 0) {
      obj.uint32SessionType = Math.round(message.uint32SessionType);
    }
    if (message.uint64SessionUin !== undefined && message.uint64SessionUin !== 0) {
      obj.uint64SessionUin = Math.round(message.uint64SessionUin);
    }
    if (message.uint64SenderUin !== undefined && message.uint64SenderUin !== 0) {
      obj.uint64SenderUin = Math.round(message.uint64SenderUin);
    }
    if (message.strText !== undefined && message.strText !== "") {
      obj.strText = message.strText;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<LowVersionTips>, I>>(base?: I): LowVersionTips {
    return LowVersionTips.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<LowVersionTips>, I>>(object: I): LowVersionTips {
    const message = createBaseLowVersionTips();
    message.uint32BusinessId = object.uint32BusinessId ?? 0;
    message.uint32SessionType = object.uint32SessionType ?? 0;
    message.uint64SessionUin = object.uint64SessionUin ?? 0;
    message.uint64SenderUin = object.uint64SenderUin ?? 0;
    message.strText = object.strText ?? "";
    return message;
  },
};

function createBaseNearByMessageType(): NearByMessageType {
  return { uint32Type: 0, uint32IdentifyType: 0 };
}

export const NearByMessageType: MessageFns<NearByMessageType> = {
  encode(message: NearByMessageType, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.uint32Type !== undefined && message.uint32Type !== 0) {
      writer.uint32(8).uint32(message.uint32Type);
    }
    if (message.uint32IdentifyType !== undefined && message.uint32IdentifyType !== 0) {
      writer.uint32(16).uint32(message.uint32IdentifyType);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): NearByMessageType {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseNearByMessageType();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.uint32Type = reader.uint32();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.uint32IdentifyType = reader.uint32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): NearByMessageType {
    return {
      uint32Type: isSet(object.uint32Type) ? globalThis.Number(object.uint32Type) : 0,
      uint32IdentifyType: isSet(object.uint32IdentifyType) ? globalThis.Number(object.uint32IdentifyType) : 0,
    };
  },

  toJSON(message: NearByMessageType): unknown {
    const obj: any = {};
    if (message.uint32Type !== undefined && message.uint32Type !== 0) {
      obj.uint32Type = Math.round(message.uint32Type);
    }
    if (message.uint32IdentifyType !== undefined && message.uint32IdentifyType !== 0) {
      obj.uint32IdentifyType = Math.round(message.uint32IdentifyType);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<NearByMessageType>, I>>(base?: I): NearByMessageType {
    return NearByMessageType.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<NearByMessageType>, I>>(object: I): NearByMessageType {
    const message = createBaseNearByMessageType();
    message.uint32Type = object.uint32Type ?? 0;
    message.uint32IdentifyType = object.uint32IdentifyType ?? 0;
    return message;
  },
};

function createBaseCustomElem(): CustomElem {
  return {
    bytesDesc: new Uint8Array(0),
    bytesData: new Uint8Array(0),
    enumType: 1,
    bytesExt: new Uint8Array(0),
    bytesSound: new Uint8Array(0),
  };
}

export const CustomElem: MessageFns<CustomElem> = {
  encode(message: CustomElem, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.bytesDesc !== undefined && message.bytesDesc.length !== 0) {
      writer.uint32(10).bytes(message.bytesDesc);
    }
    if (message.bytesData !== undefined && message.bytesData.length !== 0) {
      writer.uint32(18).bytes(message.bytesData);
    }
    if (message.enumType !== undefined && message.enumType !== 1) {
      writer.uint32(24).int32(message.enumType);
    }
    if (message.bytesExt !== undefined && message.bytesExt.length !== 0) {
      writer.uint32(34).bytes(message.bytesExt);
    }
    if (message.bytesSound !== undefined && message.bytesSound.length !== 0) {
      writer.uint32(42).bytes(message.bytesSound);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CustomElem {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCustomElem();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.bytesDesc = reader.bytes();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.bytesData = reader.bytes();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.enumType = reader.int32() as any;
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.bytesExt = reader.bytes();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.bytesSound = reader.bytes();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CustomElem {
    return {
      bytesDesc: isSet(object.bytesDesc) ? bytesFromBase64(object.bytesDesc) : new Uint8Array(0),
      bytesData: isSet(object.bytesData) ? bytesFromBase64(object.bytesData) : new Uint8Array(0),
      enumType: isSet(object.enumType) ? customElem_DataTypeFromJSON(object.enumType) : 1,
      bytesExt: isSet(object.bytesExt) ? bytesFromBase64(object.bytesExt) : new Uint8Array(0),
      bytesSound: isSet(object.bytesSound) ? bytesFromBase64(object.bytesSound) : new Uint8Array(0),
    };
  },

  toJSON(message: CustomElem): unknown {
    const obj: any = {};
    if (message.bytesDesc !== undefined && message.bytesDesc.length !== 0) {
      obj.bytesDesc = base64FromBytes(message.bytesDesc);
    }
    if (message.bytesData !== undefined && message.bytesData.length !== 0) {
      obj.bytesData = base64FromBytes(message.bytesData);
    }
    if (message.enumType !== undefined && message.enumType !== 1) {
      obj.enumType = customElem_DataTypeToJSON(message.enumType);
    }
    if (message.bytesExt !== undefined && message.bytesExt.length !== 0) {
      obj.bytesExt = base64FromBytes(message.bytesExt);
    }
    if (message.bytesSound !== undefined && message.bytesSound.length !== 0) {
      obj.bytesSound = base64FromBytes(message.bytesSound);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CustomElem>, I>>(base?: I): CustomElem {
    return CustomElem.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CustomElem>, I>>(object: I): CustomElem {
    const message = createBaseCustomElem();
    message.bytesDesc = object.bytesDesc ?? new Uint8Array(0);
    message.bytesData = object.bytesData ?? new Uint8Array(0);
    message.enumType = object.enumType ?? 1;
    message.bytesExt = object.bytesExt ?? new Uint8Array(0);
    message.bytesSound = object.bytesSound ?? new Uint8Array(0);
    return message;
  },
};

function createBaseLocationInfo(): LocationInfo {
  return { doubleLongitude: 0, doubleLatitude: 0, bytesDesc: new Uint8Array(0) };
}

export const LocationInfo: MessageFns<LocationInfo> = {
  encode(message: LocationInfo, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.doubleLongitude !== undefined && message.doubleLongitude !== 0) {
      writer.uint32(9).double(message.doubleLongitude);
    }
    if (message.doubleLatitude !== undefined && message.doubleLatitude !== 0) {
      writer.uint32(17).double(message.doubleLatitude);
    }
    if (message.bytesDesc !== undefined && message.bytesDesc.length !== 0) {
      writer.uint32(26).bytes(message.bytesDesc);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): LocationInfo {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseLocationInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 9) {
            break;
          }

          message.doubleLongitude = reader.double();
          continue;
        }
        case 2: {
          if (tag !== 17) {
            break;
          }

          message.doubleLatitude = reader.double();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.bytesDesc = reader.bytes();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): LocationInfo {
    return {
      doubleLongitude: isSet(object.doubleLongitude) ? globalThis.Number(object.doubleLongitude) : 0,
      doubleLatitude: isSet(object.doubleLatitude) ? globalThis.Number(object.doubleLatitude) : 0,
      bytesDesc: isSet(object.bytesDesc) ? bytesFromBase64(object.bytesDesc) : new Uint8Array(0),
    };
  },

  toJSON(message: LocationInfo): unknown {
    const obj: any = {};
    if (message.doubleLongitude !== undefined && message.doubleLongitude !== 0) {
      obj.doubleLongitude = message.doubleLongitude;
    }
    if (message.doubleLatitude !== undefined && message.doubleLatitude !== 0) {
      obj.doubleLatitude = message.doubleLatitude;
    }
    if (message.bytesDesc !== undefined && message.bytesDesc.length !== 0) {
      obj.bytesDesc = base64FromBytes(message.bytesDesc);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<LocationInfo>, I>>(base?: I): LocationInfo {
    return LocationInfo.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<LocationInfo>, I>>(object: I): LocationInfo {
    const message = createBaseLocationInfo();
    message.doubleLongitude = object.doubleLongitude ?? 0;
    message.doubleLatitude = object.doubleLatitude ?? 0;
    message.bytesDesc = object.bytesDesc ?? new Uint8Array(0);
    return message;
  },
};

function createBasePubAccInfo(): PubAccInfo {
  return { uint32IsInterNum: 0, stringMsgTemplateId: "", stringLongMsgUrl: "", bytesDownloadKey: new Uint8Array(0) };
}

export const PubAccInfo: MessageFns<PubAccInfo> = {
  encode(message: PubAccInfo, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.uint32IsInterNum !== undefined && message.uint32IsInterNum !== 0) {
      writer.uint32(8).uint32(message.uint32IsInterNum);
    }
    if (message.stringMsgTemplateId !== undefined && message.stringMsgTemplateId !== "") {
      writer.uint32(18).string(message.stringMsgTemplateId);
    }
    if (message.stringLongMsgUrl !== undefined && message.stringLongMsgUrl !== "") {
      writer.uint32(26).string(message.stringLongMsgUrl);
    }
    if (message.bytesDownloadKey !== undefined && message.bytesDownloadKey.length !== 0) {
      writer.uint32(34).bytes(message.bytesDownloadKey);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PubAccInfo {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePubAccInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.uint32IsInterNum = reader.uint32();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.stringMsgTemplateId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.stringLongMsgUrl = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.bytesDownloadKey = reader.bytes();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PubAccInfo {
    return {
      uint32IsInterNum: isSet(object.uint32IsInterNum) ? globalThis.Number(object.uint32IsInterNum) : 0,
      stringMsgTemplateId: isSet(object.stringMsgTemplateId) ? globalThis.String(object.stringMsgTemplateId) : "",
      stringLongMsgUrl: isSet(object.stringLongMsgUrl) ? globalThis.String(object.stringLongMsgUrl) : "",
      bytesDownloadKey: isSet(object.bytesDownloadKey) ? bytesFromBase64(object.bytesDownloadKey) : new Uint8Array(0),
    };
  },

  toJSON(message: PubAccInfo): unknown {
    const obj: any = {};
    if (message.uint32IsInterNum !== undefined && message.uint32IsInterNum !== 0) {
      obj.uint32IsInterNum = Math.round(message.uint32IsInterNum);
    }
    if (message.stringMsgTemplateId !== undefined && message.stringMsgTemplateId !== "") {
      obj.stringMsgTemplateId = message.stringMsgTemplateId;
    }
    if (message.stringLongMsgUrl !== undefined && message.stringLongMsgUrl !== "") {
      obj.stringLongMsgUrl = message.stringLongMsgUrl;
    }
    if (message.bytesDownloadKey !== undefined && message.bytesDownloadKey.length !== 0) {
      obj.bytesDownloadKey = base64FromBytes(message.bytesDownloadKey);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<PubAccInfo>, I>>(base?: I): PubAccInfo {
    return PubAccInfo.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<PubAccInfo>, I>>(object: I): PubAccInfo {
    const message = createBasePubAccInfo();
    message.uint32IsInterNum = object.uint32IsInterNum ?? 0;
    message.stringMsgTemplateId = object.stringMsgTemplateId ?? "";
    message.stringLongMsgUrl = object.stringLongMsgUrl ?? "";
    message.bytesDownloadKey = object.bytesDownloadKey ?? new Uint8Array(0);
    return message;
  },
};

function createBaseSmallEmoji(): SmallEmoji {
  return { packIdSum: 0, imageType: 0 };
}

export const SmallEmoji: MessageFns<SmallEmoji> = {
  encode(message: SmallEmoji, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.packIdSum !== undefined && message.packIdSum !== 0) {
      writer.uint32(8).uint32(message.packIdSum);
    }
    if (message.imageType !== undefined && message.imageType !== 0) {
      writer.uint32(16).uint32(message.imageType);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SmallEmoji {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSmallEmoji();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.packIdSum = reader.uint32();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.imageType = reader.uint32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SmallEmoji {
    return {
      packIdSum: isSet(object.packIdSum) ? globalThis.Number(object.packIdSum) : 0,
      imageType: isSet(object.imageType) ? globalThis.Number(object.imageType) : 0,
    };
  },

  toJSON(message: SmallEmoji): unknown {
    const obj: any = {};
    if (message.packIdSum !== undefined && message.packIdSum !== 0) {
      obj.packIdSum = Math.round(message.packIdSum);
    }
    if (message.imageType !== undefined && message.imageType !== 0) {
      obj.imageType = Math.round(message.imageType);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<SmallEmoji>, I>>(base?: I): SmallEmoji {
    return SmallEmoji.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SmallEmoji>, I>>(object: I): SmallEmoji {
    const message = createBaseSmallEmoji();
    message.packIdSum = object.packIdSum ?? 0;
    message.imageType = object.imageType ?? 0;
    return message;
  },
};

function createBaseFSJMessageElem(): FSJMessageElem {
  return { uint32MsgType: 0 };
}

export const FSJMessageElem: MessageFns<FSJMessageElem> = {
  encode(message: FSJMessageElem, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.uint32MsgType !== undefined && message.uint32MsgType !== 0) {
      writer.uint32(8).uint32(message.uint32MsgType);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): FSJMessageElem {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseFSJMessageElem();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.uint32MsgType = reader.uint32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): FSJMessageElem {
    return { uint32MsgType: isSet(object.uint32MsgType) ? globalThis.Number(object.uint32MsgType) : 0 };
  },

  toJSON(message: FSJMessageElem): unknown {
    const obj: any = {};
    if (message.uint32MsgType !== undefined && message.uint32MsgType !== 0) {
      obj.uint32MsgType = Math.round(message.uint32MsgType);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<FSJMessageElem>, I>>(base?: I): FSJMessageElem {
    return FSJMessageElem.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<FSJMessageElem>, I>>(object: I): FSJMessageElem {
    const message = createBaseFSJMessageElem();
    message.uint32MsgType = object.uint32MsgType ?? 0;
    return message;
  },
};

function createBaseArkAppElem(): ArkAppElem {
  return { appName: "", minVersion: "", xmlTemplate: "", bytesData: new Uint8Array(0) };
}

export const ArkAppElem: MessageFns<ArkAppElem> = {
  encode(message: ArkAppElem, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.appName !== undefined && message.appName !== "") {
      writer.uint32(10).string(message.appName);
    }
    if (message.minVersion !== undefined && message.minVersion !== "") {
      writer.uint32(18).string(message.minVersion);
    }
    if (message.xmlTemplate !== undefined && message.xmlTemplate !== "") {
      writer.uint32(26).string(message.xmlTemplate);
    }
    if (message.bytesData !== undefined && message.bytesData.length !== 0) {
      writer.uint32(34).bytes(message.bytesData);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ArkAppElem {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseArkAppElem();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.appName = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.minVersion = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.xmlTemplate = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.bytesData = reader.bytes();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ArkAppElem {
    return {
      appName: isSet(object.appName) ? globalThis.String(object.appName) : "",
      minVersion: isSet(object.minVersion) ? globalThis.String(object.minVersion) : "",
      xmlTemplate: isSet(object.xmlTemplate) ? globalThis.String(object.xmlTemplate) : "",
      bytesData: isSet(object.bytesData) ? bytesFromBase64(object.bytesData) : new Uint8Array(0),
    };
  },

  toJSON(message: ArkAppElem): unknown {
    const obj: any = {};
    if (message.appName !== undefined && message.appName !== "") {
      obj.appName = message.appName;
    }
    if (message.minVersion !== undefined && message.minVersion !== "") {
      obj.minVersion = message.minVersion;
    }
    if (message.xmlTemplate !== undefined && message.xmlTemplate !== "") {
      obj.xmlTemplate = message.xmlTemplate;
    }
    if (message.bytesData !== undefined && message.bytesData.length !== 0) {
      obj.bytesData = base64FromBytes(message.bytesData);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ArkAppElem>, I>>(base?: I): ArkAppElem {
    return ArkAppElem.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ArkAppElem>, I>>(object: I): ArkAppElem {
    const message = createBaseArkAppElem();
    message.appName = object.appName ?? "";
    message.minVersion = object.minVersion ?? "";
    message.xmlTemplate = object.xmlTemplate ?? "";
    message.bytesData = object.bytesData ?? new Uint8Array(0);
    return message;
  },
};

function createBaseLightAppElem(): LightAppElem {
  return { bytesData: new Uint8Array(0), bytesMsgResid: new Uint8Array(0) };
}

export const LightAppElem: MessageFns<LightAppElem> = {
  encode(message: LightAppElem, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.bytesData !== undefined && message.bytesData.length !== 0) {
      writer.uint32(10).bytes(message.bytesData);
    }
    if (message.bytesMsgResid !== undefined && message.bytesMsgResid.length !== 0) {
      writer.uint32(18).bytes(message.bytesMsgResid);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): LightAppElem {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseLightAppElem();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.bytesData = reader.bytes();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.bytesMsgResid = reader.bytes();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): LightAppElem {
    return {
      bytesData: isSet(object.bytesData) ? bytesFromBase64(object.bytesData) : new Uint8Array(0),
      bytesMsgResid: isSet(object.bytesMsgResid) ? bytesFromBase64(object.bytesMsgResid) : new Uint8Array(0),
    };
  },

  toJSON(message: LightAppElem): unknown {
    const obj: any = {};
    if (message.bytesData !== undefined && message.bytesData.length !== 0) {
      obj.bytesData = base64FromBytes(message.bytesData);
    }
    if (message.bytesMsgResid !== undefined && message.bytesMsgResid.length !== 0) {
      obj.bytesMsgResid = base64FromBytes(message.bytesMsgResid);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<LightAppElem>, I>>(base?: I): LightAppElem {
    return LightAppElem.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<LightAppElem>, I>>(object: I): LightAppElem {
    const message = createBaseLightAppElem();
    message.bytesData = object.bytesData ?? new Uint8Array(0);
    message.bytesMsgResid = object.bytesMsgResid ?? new Uint8Array(0);
    return message;
  },
};

function createBaseGeneralFlags(): GeneralFlags {
  return {
    uint32BubbleDiyTextId: 0,
    uint32GroupFlagNew: 0,
    uint64Uin: 0,
    bytesRpId: new Uint8Array(0),
    uint32PrpFold: 0,
    longTextFlag: 0,
    longTextResid: new Uint8Array(0),
    uint32GroupType: 0,
    uint32ToUinFlag: 0,
    uint32GlamourLevel: 0,
    uint32MemberLevel: 0,
    uint64GroupRankSeq: 0,
    uint32OlympicTorch: 0,
    babyqGuideMsgCookie: new Uint8Array(0),
    uin32ExpertFlag: 0,
    uint32BubbleSubId: 0,
    uint64PendantId: 0,
    bytesRpIndex: new Uint8Array(0),
    bytesPbReserve: new Uint8Array(0),
  };
}

export const GeneralFlags: MessageFns<GeneralFlags> = {
  encode(message: GeneralFlags, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.uint32BubbleDiyTextId !== undefined && message.uint32BubbleDiyTextId !== 0) {
      writer.uint32(8).uint32(message.uint32BubbleDiyTextId);
    }
    if (message.uint32GroupFlagNew !== undefined && message.uint32GroupFlagNew !== 0) {
      writer.uint32(16).uint32(message.uint32GroupFlagNew);
    }
    if (message.uint64Uin !== undefined && message.uint64Uin !== 0) {
      writer.uint32(24).uint64(message.uint64Uin);
    }
    if (message.bytesRpId !== undefined && message.bytesRpId.length !== 0) {
      writer.uint32(34).bytes(message.bytesRpId);
    }
    if (message.uint32PrpFold !== undefined && message.uint32PrpFold !== 0) {
      writer.uint32(40).uint32(message.uint32PrpFold);
    }
    if (message.longTextFlag !== undefined && message.longTextFlag !== 0) {
      writer.uint32(48).uint32(message.longTextFlag);
    }
    if (message.longTextResid !== undefined && message.longTextResid.length !== 0) {
      writer.uint32(58).bytes(message.longTextResid);
    }
    if (message.uint32GroupType !== undefined && message.uint32GroupType !== 0) {
      writer.uint32(64).uint32(message.uint32GroupType);
    }
    if (message.uint32ToUinFlag !== undefined && message.uint32ToUinFlag !== 0) {
      writer.uint32(72).uint32(message.uint32ToUinFlag);
    }
    if (message.uint32GlamourLevel !== undefined && message.uint32GlamourLevel !== 0) {
      writer.uint32(80).uint32(message.uint32GlamourLevel);
    }
    if (message.uint32MemberLevel !== undefined && message.uint32MemberLevel !== 0) {
      writer.uint32(88).uint32(message.uint32MemberLevel);
    }
    if (message.uint64GroupRankSeq !== undefined && message.uint64GroupRankSeq !== 0) {
      writer.uint32(96).uint64(message.uint64GroupRankSeq);
    }
    if (message.uint32OlympicTorch !== undefined && message.uint32OlympicTorch !== 0) {
      writer.uint32(104).uint32(message.uint32OlympicTorch);
    }
    if (message.babyqGuideMsgCookie !== undefined && message.babyqGuideMsgCookie.length !== 0) {
      writer.uint32(114).bytes(message.babyqGuideMsgCookie);
    }
    if (message.uin32ExpertFlag !== undefined && message.uin32ExpertFlag !== 0) {
      writer.uint32(120).uint32(message.uin32ExpertFlag);
    }
    if (message.uint32BubbleSubId !== undefined && message.uint32BubbleSubId !== 0) {
      writer.uint32(128).uint32(message.uint32BubbleSubId);
    }
    if (message.uint64PendantId !== undefined && message.uint64PendantId !== 0) {
      writer.uint32(136).uint64(message.uint64PendantId);
    }
    if (message.bytesRpIndex !== undefined && message.bytesRpIndex.length !== 0) {
      writer.uint32(146).bytes(message.bytesRpIndex);
    }
    if (message.bytesPbReserve !== undefined && message.bytesPbReserve.length !== 0) {
      writer.uint32(154).bytes(message.bytesPbReserve);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GeneralFlags {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGeneralFlags();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.uint32BubbleDiyTextId = reader.uint32();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.uint32GroupFlagNew = reader.uint32();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.uint64Uin = longToNumber(reader.uint64());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.bytesRpId = reader.bytes();
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.uint32PrpFold = reader.uint32();
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.longTextFlag = reader.uint32();
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.longTextResid = reader.bytes();
          continue;
        }
        case 8: {
          if (tag !== 64) {
            break;
          }

          message.uint32GroupType = reader.uint32();
          continue;
        }
        case 9: {
          if (tag !== 72) {
            break;
          }

          message.uint32ToUinFlag = reader.uint32();
          continue;
        }
        case 10: {
          if (tag !== 80) {
            break;
          }

          message.uint32GlamourLevel = reader.uint32();
          continue;
        }
        case 11: {
          if (tag !== 88) {
            break;
          }

          message.uint32MemberLevel = reader.uint32();
          continue;
        }
        case 12: {
          if (tag !== 96) {
            break;
          }

          message.uint64GroupRankSeq = longToNumber(reader.uint64());
          continue;
        }
        case 13: {
          if (tag !== 104) {
            break;
          }

          message.uint32OlympicTorch = reader.uint32();
          continue;
        }
        case 14: {
          if (tag !== 114) {
            break;
          }

          message.babyqGuideMsgCookie = reader.bytes();
          continue;
        }
        case 15: {
          if (tag !== 120) {
            break;
          }

          message.uin32ExpertFlag = reader.uint32();
          continue;
        }
        case 16: {
          if (tag !== 128) {
            break;
          }

          message.uint32BubbleSubId = reader.uint32();
          continue;
        }
        case 17: {
          if (tag !== 136) {
            break;
          }

          message.uint64PendantId = longToNumber(reader.uint64());
          continue;
        }
        case 18: {
          if (tag !== 146) {
            break;
          }

          message.bytesRpIndex = reader.bytes();
          continue;
        }
        case 19: {
          if (tag !== 154) {
            break;
          }

          message.bytesPbReserve = reader.bytes();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GeneralFlags {
    return {
      uint32BubbleDiyTextId: isSet(object.uint32BubbleDiyTextId) ? globalThis.Number(object.uint32BubbleDiyTextId) : 0,
      uint32GroupFlagNew: isSet(object.uint32GroupFlagNew) ? globalThis.Number(object.uint32GroupFlagNew) : 0,
      uint64Uin: isSet(object.uint64Uin) ? globalThis.Number(object.uint64Uin) : 0,
      bytesRpId: isSet(object.bytesRpId) ? bytesFromBase64(object.bytesRpId) : new Uint8Array(0),
      uint32PrpFold: isSet(object.uint32PrpFold) ? globalThis.Number(object.uint32PrpFold) : 0,
      longTextFlag: isSet(object.longTextFlag) ? globalThis.Number(object.longTextFlag) : 0,
      longTextResid: isSet(object.longTextResid) ? bytesFromBase64(object.longTextResid) : new Uint8Array(0),
      uint32GroupType: isSet(object.uint32GroupType) ? globalThis.Number(object.uint32GroupType) : 0,
      uint32ToUinFlag: isSet(object.uint32ToUinFlag) ? globalThis.Number(object.uint32ToUinFlag) : 0,
      uint32GlamourLevel: isSet(object.uint32GlamourLevel) ? globalThis.Number(object.uint32GlamourLevel) : 0,
      uint32MemberLevel: isSet(object.uint32MemberLevel) ? globalThis.Number(object.uint32MemberLevel) : 0,
      uint64GroupRankSeq: isSet(object.uint64GroupRankSeq) ? globalThis.Number(object.uint64GroupRankSeq) : 0,
      uint32OlympicTorch: isSet(object.uint32OlympicTorch) ? globalThis.Number(object.uint32OlympicTorch) : 0,
      babyqGuideMsgCookie: isSet(object.babyqGuideMsgCookie)
        ? bytesFromBase64(object.babyqGuideMsgCookie)
        : new Uint8Array(0),
      uin32ExpertFlag: isSet(object.uin32ExpertFlag) ? globalThis.Number(object.uin32ExpertFlag) : 0,
      uint32BubbleSubId: isSet(object.uint32BubbleSubId) ? globalThis.Number(object.uint32BubbleSubId) : 0,
      uint64PendantId: isSet(object.uint64PendantId) ? globalThis.Number(object.uint64PendantId) : 0,
      bytesRpIndex: isSet(object.bytesRpIndex) ? bytesFromBase64(object.bytesRpIndex) : new Uint8Array(0),
      bytesPbReserve: isSet(object.bytesPbReserve) ? bytesFromBase64(object.bytesPbReserve) : new Uint8Array(0),
    };
  },

  toJSON(message: GeneralFlags): unknown {
    const obj: any = {};
    if (message.uint32BubbleDiyTextId !== undefined && message.uint32BubbleDiyTextId !== 0) {
      obj.uint32BubbleDiyTextId = Math.round(message.uint32BubbleDiyTextId);
    }
    if (message.uint32GroupFlagNew !== undefined && message.uint32GroupFlagNew !== 0) {
      obj.uint32GroupFlagNew = Math.round(message.uint32GroupFlagNew);
    }
    if (message.uint64Uin !== undefined && message.uint64Uin !== 0) {
      obj.uint64Uin = Math.round(message.uint64Uin);
    }
    if (message.bytesRpId !== undefined && message.bytesRpId.length !== 0) {
      obj.bytesRpId = base64FromBytes(message.bytesRpId);
    }
    if (message.uint32PrpFold !== undefined && message.uint32PrpFold !== 0) {
      obj.uint32PrpFold = Math.round(message.uint32PrpFold);
    }
    if (message.longTextFlag !== undefined && message.longTextFlag !== 0) {
      obj.longTextFlag = Math.round(message.longTextFlag);
    }
    if (message.longTextResid !== undefined && message.longTextResid.length !== 0) {
      obj.longTextResid = base64FromBytes(message.longTextResid);
    }
    if (message.uint32GroupType !== undefined && message.uint32GroupType !== 0) {
      obj.uint32GroupType = Math.round(message.uint32GroupType);
    }
    if (message.uint32ToUinFlag !== undefined && message.uint32ToUinFlag !== 0) {
      obj.uint32ToUinFlag = Math.round(message.uint32ToUinFlag);
    }
    if (message.uint32GlamourLevel !== undefined && message.uint32GlamourLevel !== 0) {
      obj.uint32GlamourLevel = Math.round(message.uint32GlamourLevel);
    }
    if (message.uint32MemberLevel !== undefined && message.uint32MemberLevel !== 0) {
      obj.uint32MemberLevel = Math.round(message.uint32MemberLevel);
    }
    if (message.uint64GroupRankSeq !== undefined && message.uint64GroupRankSeq !== 0) {
      obj.uint64GroupRankSeq = Math.round(message.uint64GroupRankSeq);
    }
    if (message.uint32OlympicTorch !== undefined && message.uint32OlympicTorch !== 0) {
      obj.uint32OlympicTorch = Math.round(message.uint32OlympicTorch);
    }
    if (message.babyqGuideMsgCookie !== undefined && message.babyqGuideMsgCookie.length !== 0) {
      obj.babyqGuideMsgCookie = base64FromBytes(message.babyqGuideMsgCookie);
    }
    if (message.uin32ExpertFlag !== undefined && message.uin32ExpertFlag !== 0) {
      obj.uin32ExpertFlag = Math.round(message.uin32ExpertFlag);
    }
    if (message.uint32BubbleSubId !== undefined && message.uint32BubbleSubId !== 0) {
      obj.uint32BubbleSubId = Math.round(message.uint32BubbleSubId);
    }
    if (message.uint64PendantId !== undefined && message.uint64PendantId !== 0) {
      obj.uint64PendantId = Math.round(message.uint64PendantId);
    }
    if (message.bytesRpIndex !== undefined && message.bytesRpIndex.length !== 0) {
      obj.bytesRpIndex = base64FromBytes(message.bytesRpIndex);
    }
    if (message.bytesPbReserve !== undefined && message.bytesPbReserve.length !== 0) {
      obj.bytesPbReserve = base64FromBytes(message.bytesPbReserve);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GeneralFlags>, I>>(base?: I): GeneralFlags {
    return GeneralFlags.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GeneralFlags>, I>>(object: I): GeneralFlags {
    const message = createBaseGeneralFlags();
    message.uint32BubbleDiyTextId = object.uint32BubbleDiyTextId ?? 0;
    message.uint32GroupFlagNew = object.uint32GroupFlagNew ?? 0;
    message.uint64Uin = object.uint64Uin ?? 0;
    message.bytesRpId = object.bytesRpId ?? new Uint8Array(0);
    message.uint32PrpFold = object.uint32PrpFold ?? 0;
    message.longTextFlag = object.longTextFlag ?? 0;
    message.longTextResid = object.longTextResid ?? new Uint8Array(0);
    message.uint32GroupType = object.uint32GroupType ?? 0;
    message.uint32ToUinFlag = object.uint32ToUinFlag ?? 0;
    message.uint32GlamourLevel = object.uint32GlamourLevel ?? 0;
    message.uint32MemberLevel = object.uint32MemberLevel ?? 0;
    message.uint64GroupRankSeq = object.uint64GroupRankSeq ?? 0;
    message.uint32OlympicTorch = object.uint32OlympicTorch ?? 0;
    message.babyqGuideMsgCookie = object.babyqGuideMsgCookie ?? new Uint8Array(0);
    message.uin32ExpertFlag = object.uin32ExpertFlag ?? 0;
    message.uint32BubbleSubId = object.uint32BubbleSubId ?? 0;
    message.uint64PendantId = object.uint64PendantId ?? 0;
    message.bytesRpIndex = object.bytesRpIndex ?? new Uint8Array(0);
    message.bytesPbReserve = object.bytesPbReserve ?? new Uint8Array(0);
    return message;
  },
};

function createBaseDeliverGiftMsg(): DeliverGiftMsg {
  return {
    bytesGrayTipContent: new Uint8Array(0),
    uint32AnimationPackageId: 0,
    bytesAnimationPackageUrlA: new Uint8Array(0),
    bytesAnimationPackageUrlI: new Uint8Array(0),
    bytesRemindBrief: new Uint8Array(0),
    uint32GiftId: 0,
    uint32GiftCount: 0,
    bytesAnimationBrief: new Uint8Array(0),
    uint64SenderUin: 0,
    uint64ReceiverUin: 0,
    bytesStmessageTitle: new Uint8Array(0),
    bytesStmessageSubtitle: new Uint8Array(0),
    bytesStmessageMessage: new Uint8Array(0),
    uint32StmessageGiftpicid: 0,
    bytesStmessageComefrom: new Uint8Array(0),
    uint32StmessageExflag: 0,
    bytesToAllGiftId: new Uint8Array(0),
    bytesComefromLink: new Uint8Array(0),
    bytesPbReserve: new Uint8Array(0),
    bytesReceiverName: new Uint8Array(0),
    bytesReceiverPic: new Uint8Array(0),
    bytesStmessageGifturl: new Uint8Array(0),
  };
}

export const DeliverGiftMsg: MessageFns<DeliverGiftMsg> = {
  encode(message: DeliverGiftMsg, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.bytesGrayTipContent !== undefined && message.bytesGrayTipContent.length !== 0) {
      writer.uint32(10).bytes(message.bytesGrayTipContent);
    }
    if (message.uint32AnimationPackageId !== undefined && message.uint32AnimationPackageId !== 0) {
      writer.uint32(16).uint32(message.uint32AnimationPackageId);
    }
    if (message.bytesAnimationPackageUrlA !== undefined && message.bytesAnimationPackageUrlA.length !== 0) {
      writer.uint32(26).bytes(message.bytesAnimationPackageUrlA);
    }
    if (message.bytesAnimationPackageUrlI !== undefined && message.bytesAnimationPackageUrlI.length !== 0) {
      writer.uint32(34).bytes(message.bytesAnimationPackageUrlI);
    }
    if (message.bytesRemindBrief !== undefined && message.bytesRemindBrief.length !== 0) {
      writer.uint32(42).bytes(message.bytesRemindBrief);
    }
    if (message.uint32GiftId !== undefined && message.uint32GiftId !== 0) {
      writer.uint32(48).uint32(message.uint32GiftId);
    }
    if (message.uint32GiftCount !== undefined && message.uint32GiftCount !== 0) {
      writer.uint32(56).uint32(message.uint32GiftCount);
    }
    if (message.bytesAnimationBrief !== undefined && message.bytesAnimationBrief.length !== 0) {
      writer.uint32(66).bytes(message.bytesAnimationBrief);
    }
    if (message.uint64SenderUin !== undefined && message.uint64SenderUin !== 0) {
      writer.uint32(72).uint64(message.uint64SenderUin);
    }
    if (message.uint64ReceiverUin !== undefined && message.uint64ReceiverUin !== 0) {
      writer.uint32(80).uint64(message.uint64ReceiverUin);
    }
    if (message.bytesStmessageTitle !== undefined && message.bytesStmessageTitle.length !== 0) {
      writer.uint32(90).bytes(message.bytesStmessageTitle);
    }
    if (message.bytesStmessageSubtitle !== undefined && message.bytesStmessageSubtitle.length !== 0) {
      writer.uint32(98).bytes(message.bytesStmessageSubtitle);
    }
    if (message.bytesStmessageMessage !== undefined && message.bytesStmessageMessage.length !== 0) {
      writer.uint32(106).bytes(message.bytesStmessageMessage);
    }
    if (message.uint32StmessageGiftpicid !== undefined && message.uint32StmessageGiftpicid !== 0) {
      writer.uint32(112).uint32(message.uint32StmessageGiftpicid);
    }
    if (message.bytesStmessageComefrom !== undefined && message.bytesStmessageComefrom.length !== 0) {
      writer.uint32(122).bytes(message.bytesStmessageComefrom);
    }
    if (message.uint32StmessageExflag !== undefined && message.uint32StmessageExflag !== 0) {
      writer.uint32(128).uint32(message.uint32StmessageExflag);
    }
    if (message.bytesToAllGiftId !== undefined && message.bytesToAllGiftId.length !== 0) {
      writer.uint32(138).bytes(message.bytesToAllGiftId);
    }
    if (message.bytesComefromLink !== undefined && message.bytesComefromLink.length !== 0) {
      writer.uint32(146).bytes(message.bytesComefromLink);
    }
    if (message.bytesPbReserve !== undefined && message.bytesPbReserve.length !== 0) {
      writer.uint32(154).bytes(message.bytesPbReserve);
    }
    if (message.bytesReceiverName !== undefined && message.bytesReceiverName.length !== 0) {
      writer.uint32(162).bytes(message.bytesReceiverName);
    }
    if (message.bytesReceiverPic !== undefined && message.bytesReceiverPic.length !== 0) {
      writer.uint32(170).bytes(message.bytesReceiverPic);
    }
    if (message.bytesStmessageGifturl !== undefined && message.bytesStmessageGifturl.length !== 0) {
      writer.uint32(178).bytes(message.bytesStmessageGifturl);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DeliverGiftMsg {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDeliverGiftMsg();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.bytesGrayTipContent = reader.bytes();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.uint32AnimationPackageId = reader.uint32();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.bytesAnimationPackageUrlA = reader.bytes();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.bytesAnimationPackageUrlI = reader.bytes();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.bytesRemindBrief = reader.bytes();
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.uint32GiftId = reader.uint32();
          continue;
        }
        case 7: {
          if (tag !== 56) {
            break;
          }

          message.uint32GiftCount = reader.uint32();
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.bytesAnimationBrief = reader.bytes();
          continue;
        }
        case 9: {
          if (tag !== 72) {
            break;
          }

          message.uint64SenderUin = longToNumber(reader.uint64());
          continue;
        }
        case 10: {
          if (tag !== 80) {
            break;
          }

          message.uint64ReceiverUin = longToNumber(reader.uint64());
          continue;
        }
        case 11: {
          if (tag !== 90) {
            break;
          }

          message.bytesStmessageTitle = reader.bytes();
          continue;
        }
        case 12: {
          if (tag !== 98) {
            break;
          }

          message.bytesStmessageSubtitle = reader.bytes();
          continue;
        }
        case 13: {
          if (tag !== 106) {
            break;
          }

          message.bytesStmessageMessage = reader.bytes();
          continue;
        }
        case 14: {
          if (tag !== 112) {
            break;
          }

          message.uint32StmessageGiftpicid = reader.uint32();
          continue;
        }
        case 15: {
          if (tag !== 122) {
            break;
          }

          message.bytesStmessageComefrom = reader.bytes();
          continue;
        }
        case 16: {
          if (tag !== 128) {
            break;
          }

          message.uint32StmessageExflag = reader.uint32();
          continue;
        }
        case 17: {
          if (tag !== 138) {
            break;
          }

          message.bytesToAllGiftId = reader.bytes();
          continue;
        }
        case 18: {
          if (tag !== 146) {
            break;
          }

          message.bytesComefromLink = reader.bytes();
          continue;
        }
        case 19: {
          if (tag !== 154) {
            break;
          }

          message.bytesPbReserve = reader.bytes();
          continue;
        }
        case 20: {
          if (tag !== 162) {
            break;
          }

          message.bytesReceiverName = reader.bytes();
          continue;
        }
        case 21: {
          if (tag !== 170) {
            break;
          }

          message.bytesReceiverPic = reader.bytes();
          continue;
        }
        case 22: {
          if (tag !== 178) {
            break;
          }

          message.bytesStmessageGifturl = reader.bytes();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DeliverGiftMsg {
    return {
      bytesGrayTipContent: isSet(object.bytesGrayTipContent)
        ? bytesFromBase64(object.bytesGrayTipContent)
        : new Uint8Array(0),
      uint32AnimationPackageId: isSet(object.uint32AnimationPackageId)
        ? globalThis.Number(object.uint32AnimationPackageId)
        : 0,
      bytesAnimationPackageUrlA: isSet(object.bytesAnimationPackageUrlA)
        ? bytesFromBase64(object.bytesAnimationPackageUrlA)
        : new Uint8Array(0),
      bytesAnimationPackageUrlI: isSet(object.bytesAnimationPackageUrlI)
        ? bytesFromBase64(object.bytesAnimationPackageUrlI)
        : new Uint8Array(0),
      bytesRemindBrief: isSet(object.bytesRemindBrief) ? bytesFromBase64(object.bytesRemindBrief) : new Uint8Array(0),
      uint32GiftId: isSet(object.uint32GiftId) ? globalThis.Number(object.uint32GiftId) : 0,
      uint32GiftCount: isSet(object.uint32GiftCount) ? globalThis.Number(object.uint32GiftCount) : 0,
      bytesAnimationBrief: isSet(object.bytesAnimationBrief)
        ? bytesFromBase64(object.bytesAnimationBrief)
        : new Uint8Array(0),
      uint64SenderUin: isSet(object.uint64SenderUin) ? globalThis.Number(object.uint64SenderUin) : 0,
      uint64ReceiverUin: isSet(object.uint64ReceiverUin) ? globalThis.Number(object.uint64ReceiverUin) : 0,
      bytesStmessageTitle: isSet(object.bytesStmessageTitle)
        ? bytesFromBase64(object.bytesStmessageTitle)
        : new Uint8Array(0),
      bytesStmessageSubtitle: isSet(object.bytesStmessageSubtitle)
        ? bytesFromBase64(object.bytesStmessageSubtitle)
        : new Uint8Array(0),
      bytesStmessageMessage: isSet(object.bytesStmessageMessage)
        ? bytesFromBase64(object.bytesStmessageMessage)
        : new Uint8Array(0),
      uint32StmessageGiftpicid: isSet(object.uint32StmessageGiftpicid)
        ? globalThis.Number(object.uint32StmessageGiftpicid)
        : 0,
      bytesStmessageComefrom: isSet(object.bytesStmessageComefrom)
        ? bytesFromBase64(object.bytesStmessageComefrom)
        : new Uint8Array(0),
      uint32StmessageExflag: isSet(object.uint32StmessageExflag) ? globalThis.Number(object.uint32StmessageExflag) : 0,
      bytesToAllGiftId: isSet(object.bytesToAllGiftId) ? bytesFromBase64(object.bytesToAllGiftId) : new Uint8Array(0),
      bytesComefromLink: isSet(object.bytesComefromLink)
        ? bytesFromBase64(object.bytesComefromLink)
        : new Uint8Array(0),
      bytesPbReserve: isSet(object.bytesPbReserve) ? bytesFromBase64(object.bytesPbReserve) : new Uint8Array(0),
      bytesReceiverName: isSet(object.bytesReceiverName)
        ? bytesFromBase64(object.bytesReceiverName)
        : new Uint8Array(0),
      bytesReceiverPic: isSet(object.bytesReceiverPic) ? bytesFromBase64(object.bytesReceiverPic) : new Uint8Array(0),
      bytesStmessageGifturl: isSet(object.bytesStmessageGifturl)
        ? bytesFromBase64(object.bytesStmessageGifturl)
        : new Uint8Array(0),
    };
  },

  toJSON(message: DeliverGiftMsg): unknown {
    const obj: any = {};
    if (message.bytesGrayTipContent !== undefined && message.bytesGrayTipContent.length !== 0) {
      obj.bytesGrayTipContent = base64FromBytes(message.bytesGrayTipContent);
    }
    if (message.uint32AnimationPackageId !== undefined && message.uint32AnimationPackageId !== 0) {
      obj.uint32AnimationPackageId = Math.round(message.uint32AnimationPackageId);
    }
    if (message.bytesAnimationPackageUrlA !== undefined && message.bytesAnimationPackageUrlA.length !== 0) {
      obj.bytesAnimationPackageUrlA = base64FromBytes(message.bytesAnimationPackageUrlA);
    }
    if (message.bytesAnimationPackageUrlI !== undefined && message.bytesAnimationPackageUrlI.length !== 0) {
      obj.bytesAnimationPackageUrlI = base64FromBytes(message.bytesAnimationPackageUrlI);
    }
    if (message.bytesRemindBrief !== undefined && message.bytesRemindBrief.length !== 0) {
      obj.bytesRemindBrief = base64FromBytes(message.bytesRemindBrief);
    }
    if (message.uint32GiftId !== undefined && message.uint32GiftId !== 0) {
      obj.uint32GiftId = Math.round(message.uint32GiftId);
    }
    if (message.uint32GiftCount !== undefined && message.uint32GiftCount !== 0) {
      obj.uint32GiftCount = Math.round(message.uint32GiftCount);
    }
    if (message.bytesAnimationBrief !== undefined && message.bytesAnimationBrief.length !== 0) {
      obj.bytesAnimationBrief = base64FromBytes(message.bytesAnimationBrief);
    }
    if (message.uint64SenderUin !== undefined && message.uint64SenderUin !== 0) {
      obj.uint64SenderUin = Math.round(message.uint64SenderUin);
    }
    if (message.uint64ReceiverUin !== undefined && message.uint64ReceiverUin !== 0) {
      obj.uint64ReceiverUin = Math.round(message.uint64ReceiverUin);
    }
    if (message.bytesStmessageTitle !== undefined && message.bytesStmessageTitle.length !== 0) {
      obj.bytesStmessageTitle = base64FromBytes(message.bytesStmessageTitle);
    }
    if (message.bytesStmessageSubtitle !== undefined && message.bytesStmessageSubtitle.length !== 0) {
      obj.bytesStmessageSubtitle = base64FromBytes(message.bytesStmessageSubtitle);
    }
    if (message.bytesStmessageMessage !== undefined && message.bytesStmessageMessage.length !== 0) {
      obj.bytesStmessageMessage = base64FromBytes(message.bytesStmessageMessage);
    }
    if (message.uint32StmessageGiftpicid !== undefined && message.uint32StmessageGiftpicid !== 0) {
      obj.uint32StmessageGiftpicid = Math.round(message.uint32StmessageGiftpicid);
    }
    if (message.bytesStmessageComefrom !== undefined && message.bytesStmessageComefrom.length !== 0) {
      obj.bytesStmessageComefrom = base64FromBytes(message.bytesStmessageComefrom);
    }
    if (message.uint32StmessageExflag !== undefined && message.uint32StmessageExflag !== 0) {
      obj.uint32StmessageExflag = Math.round(message.uint32StmessageExflag);
    }
    if (message.bytesToAllGiftId !== undefined && message.bytesToAllGiftId.length !== 0) {
      obj.bytesToAllGiftId = base64FromBytes(message.bytesToAllGiftId);
    }
    if (message.bytesComefromLink !== undefined && message.bytesComefromLink.length !== 0) {
      obj.bytesComefromLink = base64FromBytes(message.bytesComefromLink);
    }
    if (message.bytesPbReserve !== undefined && message.bytesPbReserve.length !== 0) {
      obj.bytesPbReserve = base64FromBytes(message.bytesPbReserve);
    }
    if (message.bytesReceiverName !== undefined && message.bytesReceiverName.length !== 0) {
      obj.bytesReceiverName = base64FromBytes(message.bytesReceiverName);
    }
    if (message.bytesReceiverPic !== undefined && message.bytesReceiverPic.length !== 0) {
      obj.bytesReceiverPic = base64FromBytes(message.bytesReceiverPic);
    }
    if (message.bytesStmessageGifturl !== undefined && message.bytesStmessageGifturl.length !== 0) {
      obj.bytesStmessageGifturl = base64FromBytes(message.bytesStmessageGifturl);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<DeliverGiftMsg>, I>>(base?: I): DeliverGiftMsg {
    return DeliverGiftMsg.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<DeliverGiftMsg>, I>>(object: I): DeliverGiftMsg {
    const message = createBaseDeliverGiftMsg();
    message.bytesGrayTipContent = object.bytesGrayTipContent ?? new Uint8Array(0);
    message.uint32AnimationPackageId = object.uint32AnimationPackageId ?? 0;
    message.bytesAnimationPackageUrlA = object.bytesAnimationPackageUrlA ?? new Uint8Array(0);
    message.bytesAnimationPackageUrlI = object.bytesAnimationPackageUrlI ?? new Uint8Array(0);
    message.bytesRemindBrief = object.bytesRemindBrief ?? new Uint8Array(0);
    message.uint32GiftId = object.uint32GiftId ?? 0;
    message.uint32GiftCount = object.uint32GiftCount ?? 0;
    message.bytesAnimationBrief = object.bytesAnimationBrief ?? new Uint8Array(0);
    message.uint64SenderUin = object.uint64SenderUin ?? 0;
    message.uint64ReceiverUin = object.uint64ReceiverUin ?? 0;
    message.bytesStmessageTitle = object.bytesStmessageTitle ?? new Uint8Array(0);
    message.bytesStmessageSubtitle = object.bytesStmessageSubtitle ?? new Uint8Array(0);
    message.bytesStmessageMessage = object.bytesStmessageMessage ?? new Uint8Array(0);
    message.uint32StmessageGiftpicid = object.uint32StmessageGiftpicid ?? 0;
    message.bytesStmessageComefrom = object.bytesStmessageComefrom ?? new Uint8Array(0);
    message.uint32StmessageExflag = object.uint32StmessageExflag ?? 0;
    message.bytesToAllGiftId = object.bytesToAllGiftId ?? new Uint8Array(0);
    message.bytesComefromLink = object.bytesComefromLink ?? new Uint8Array(0);
    message.bytesPbReserve = object.bytesPbReserve ?? new Uint8Array(0);
    message.bytesReceiverName = object.bytesReceiverName ?? new Uint8Array(0);
    message.bytesReceiverPic = object.bytesReceiverPic ?? new Uint8Array(0);
    message.bytesStmessageGifturl = object.bytesStmessageGifturl ?? new Uint8Array(0);
    return message;
  },
};

function createBaseBitAppMsg(): BitAppMsg {
  return { bytesBuf: new Uint8Array(0) };
}

export const BitAppMsg: MessageFns<BitAppMsg> = {
  encode(message: BitAppMsg, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.bytesBuf !== undefined && message.bytesBuf.length !== 0) {
      writer.uint32(10).bytes(message.bytesBuf);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): BitAppMsg {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBitAppMsg();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.bytesBuf = reader.bytes();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): BitAppMsg {
    return { bytesBuf: isSet(object.bytesBuf) ? bytesFromBase64(object.bytesBuf) : new Uint8Array(0) };
  },

  toJSON(message: BitAppMsg): unknown {
    const obj: any = {};
    if (message.bytesBuf !== undefined && message.bytesBuf.length !== 0) {
      obj.bytesBuf = base64FromBytes(message.bytesBuf);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<BitAppMsg>, I>>(base?: I): BitAppMsg {
    return BitAppMsg.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<BitAppMsg>, I>>(object: I): BitAppMsg {
    const message = createBaseBitAppMsg();
    message.bytesBuf = object.bytesBuf ?? new Uint8Array(0);
    return message;
  },
};

function createBaseOpenQQData(): OpenQQData {
  return { bytesCarQqData: new Uint8Array(0) };
}

export const OpenQQData: MessageFns<OpenQQData> = {
  encode(message: OpenQQData, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.bytesCarQqData !== undefined && message.bytesCarQqData.length !== 0) {
      writer.uint32(10).bytes(message.bytesCarQqData);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): OpenQQData {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseOpenQQData();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.bytesCarQqData = reader.bytes();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): OpenQQData {
    return {
      bytesCarQqData: isSet(object.bytesCarQqData) ? bytesFromBase64(object.bytesCarQqData) : new Uint8Array(0),
    };
  },

  toJSON(message: OpenQQData): unknown {
    const obj: any = {};
    if (message.bytesCarQqData !== undefined && message.bytesCarQqData.length !== 0) {
      obj.bytesCarQqData = base64FromBytes(message.bytesCarQqData);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<OpenQQData>, I>>(base?: I): OpenQQData {
    return OpenQQData.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<OpenQQData>, I>>(object: I): OpenQQData {
    const message = createBaseOpenQQData();
    message.bytesCarQqData = object.bytesCarQqData ?? new Uint8Array(0);
    return message;
  },
};

function createBaseBlessingMessage(): BlessingMessage {
  return { uint32MsgType: 0, uint32ExFlag: 0 };
}

export const BlessingMessage: MessageFns<BlessingMessage> = {
  encode(message: BlessingMessage, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.uint32MsgType !== undefined && message.uint32MsgType !== 0) {
      writer.uint32(8).uint32(message.uint32MsgType);
    }
    if (message.uint32ExFlag !== undefined && message.uint32ExFlag !== 0) {
      writer.uint32(16).uint32(message.uint32ExFlag);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): BlessingMessage {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBlessingMessage();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.uint32MsgType = reader.uint32();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.uint32ExFlag = reader.uint32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): BlessingMessage {
    return {
      uint32MsgType: isSet(object.uint32MsgType) ? globalThis.Number(object.uint32MsgType) : 0,
      uint32ExFlag: isSet(object.uint32ExFlag) ? globalThis.Number(object.uint32ExFlag) : 0,
    };
  },

  toJSON(message: BlessingMessage): unknown {
    const obj: any = {};
    if (message.uint32MsgType !== undefined && message.uint32MsgType !== 0) {
      obj.uint32MsgType = Math.round(message.uint32MsgType);
    }
    if (message.uint32ExFlag !== undefined && message.uint32ExFlag !== 0) {
      obj.uint32ExFlag = Math.round(message.uint32ExFlag);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<BlessingMessage>, I>>(base?: I): BlessingMessage {
    return BlessingMessage.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<BlessingMessage>, I>>(object: I): BlessingMessage {
    const message = createBaseBlessingMessage();
    message.uint32MsgType = object.uint32MsgType ?? 0;
    message.uint32ExFlag = object.uint32ExFlag ?? 0;
    return message;
  },
};

function createBaseSourceMsg(): SourceMsg {
  return {
    uint32OrigSeqs: [],
    uint64SenderUin: 0,
    uint32Time: 0,
    uint32Flag: 0,
    elems: [],
    uint32Type: 0,
    bytesRichMsg: new Uint8Array(0),
    bytesPbReserve: new Uint8Array(0),
    bytesSrcMsg: new Uint8Array(0),
    uint64ToUin: 0,
    bytesTroopName: new Uint8Array(0),
  };
}

export const SourceMsg: MessageFns<SourceMsg> = {
  encode(message: SourceMsg, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    writer.uint32(10).fork();
    for (const v of message.uint32OrigSeqs) {
      writer.uint32(v);
    }
    writer.join();
    if (message.uint64SenderUin !== undefined && message.uint64SenderUin !== 0) {
      writer.uint32(16).uint64(message.uint64SenderUin);
    }
    if (message.uint32Time !== undefined && message.uint32Time !== 0) {
      writer.uint32(24).uint32(message.uint32Time);
    }
    if (message.uint32Flag !== undefined && message.uint32Flag !== 0) {
      writer.uint32(32).uint32(message.uint32Flag);
    }
    for (const v of message.elems) {
      Elem.encode(v!, writer.uint32(42).fork()).join();
    }
    if (message.uint32Type !== undefined && message.uint32Type !== 0) {
      writer.uint32(48).uint32(message.uint32Type);
    }
    if (message.bytesRichMsg !== undefined && message.bytesRichMsg.length !== 0) {
      writer.uint32(58).bytes(message.bytesRichMsg);
    }
    if (message.bytesPbReserve !== undefined && message.bytesPbReserve.length !== 0) {
      writer.uint32(66).bytes(message.bytesPbReserve);
    }
    if (message.bytesSrcMsg !== undefined && message.bytesSrcMsg.length !== 0) {
      writer.uint32(74).bytes(message.bytesSrcMsg);
    }
    if (message.uint64ToUin !== undefined && message.uint64ToUin !== 0) {
      writer.uint32(80).uint64(message.uint64ToUin);
    }
    if (message.bytesTroopName !== undefined && message.bytesTroopName.length !== 0) {
      writer.uint32(90).bytes(message.bytesTroopName);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SourceMsg {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSourceMsg();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag === 8) {
            message.uint32OrigSeqs.push(reader.uint32());

            continue;
          }

          if (tag === 10) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.uint32OrigSeqs.push(reader.uint32());
            }

            continue;
          }

          break;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.uint64SenderUin = longToNumber(reader.uint64());
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.uint32Time = reader.uint32();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.uint32Flag = reader.uint32();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.elems.push(Elem.decode(reader, reader.uint32()));
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.uint32Type = reader.uint32();
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.bytesRichMsg = reader.bytes();
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.bytesPbReserve = reader.bytes();
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.bytesSrcMsg = reader.bytes();
          continue;
        }
        case 10: {
          if (tag !== 80) {
            break;
          }

          message.uint64ToUin = longToNumber(reader.uint64());
          continue;
        }
        case 11: {
          if (tag !== 90) {
            break;
          }

          message.bytesTroopName = reader.bytes();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SourceMsg {
    return {
      uint32OrigSeqs: globalThis.Array.isArray(object?.uint32OrigSeqs)
        ? object.uint32OrigSeqs.map((e: any) => globalThis.Number(e))
        : [],
      uint64SenderUin: isSet(object.uint64SenderUin) ? globalThis.Number(object.uint64SenderUin) : 0,
      uint32Time: isSet(object.uint32Time) ? globalThis.Number(object.uint32Time) : 0,
      uint32Flag: isSet(object.uint32Flag) ? globalThis.Number(object.uint32Flag) : 0,
      elems: globalThis.Array.isArray(object?.elems) ? object.elems.map((e: any) => Elem.fromJSON(e)) : [],
      uint32Type: isSet(object.uint32Type) ? globalThis.Number(object.uint32Type) : 0,
      bytesRichMsg: isSet(object.bytesRichMsg) ? bytesFromBase64(object.bytesRichMsg) : new Uint8Array(0),
      bytesPbReserve: isSet(object.bytesPbReserve) ? bytesFromBase64(object.bytesPbReserve) : new Uint8Array(0),
      bytesSrcMsg: isSet(object.bytesSrcMsg) ? bytesFromBase64(object.bytesSrcMsg) : new Uint8Array(0),
      uint64ToUin: isSet(object.uint64ToUin) ? globalThis.Number(object.uint64ToUin) : 0,
      bytesTroopName: isSet(object.bytesTroopName) ? bytesFromBase64(object.bytesTroopName) : new Uint8Array(0),
    };
  },

  toJSON(message: SourceMsg): unknown {
    const obj: any = {};
    if (message.uint32OrigSeqs?.length) {
      obj.uint32OrigSeqs = message.uint32OrigSeqs.map((e) => Math.round(e));
    }
    if (message.uint64SenderUin !== undefined && message.uint64SenderUin !== 0) {
      obj.uint64SenderUin = Math.round(message.uint64SenderUin);
    }
    if (message.uint32Time !== undefined && message.uint32Time !== 0) {
      obj.uint32Time = Math.round(message.uint32Time);
    }
    if (message.uint32Flag !== undefined && message.uint32Flag !== 0) {
      obj.uint32Flag = Math.round(message.uint32Flag);
    }
    if (message.elems?.length) {
      obj.elems = message.elems.map((e) => Elem.toJSON(e));
    }
    if (message.uint32Type !== undefined && message.uint32Type !== 0) {
      obj.uint32Type = Math.round(message.uint32Type);
    }
    if (message.bytesRichMsg !== undefined && message.bytesRichMsg.length !== 0) {
      obj.bytesRichMsg = base64FromBytes(message.bytesRichMsg);
    }
    if (message.bytesPbReserve !== undefined && message.bytesPbReserve.length !== 0) {
      obj.bytesPbReserve = base64FromBytes(message.bytesPbReserve);
    }
    if (message.bytesSrcMsg !== undefined && message.bytesSrcMsg.length !== 0) {
      obj.bytesSrcMsg = base64FromBytes(message.bytesSrcMsg);
    }
    if (message.uint64ToUin !== undefined && message.uint64ToUin !== 0) {
      obj.uint64ToUin = Math.round(message.uint64ToUin);
    }
    if (message.bytesTroopName !== undefined && message.bytesTroopName.length !== 0) {
      obj.bytesTroopName = base64FromBytes(message.bytesTroopName);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<SourceMsg>, I>>(base?: I): SourceMsg {
    return SourceMsg.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SourceMsg>, I>>(object: I): SourceMsg {
    const message = createBaseSourceMsg();
    message.uint32OrigSeqs = object.uint32OrigSeqs?.map((e) => e) || [];
    message.uint64SenderUin = object.uint64SenderUin ?? 0;
    message.uint32Time = object.uint32Time ?? 0;
    message.uint32Flag = object.uint32Flag ?? 0;
    message.elems = object.elems?.map((e) => Elem.fromPartial(e)) || [];
    message.uint32Type = object.uint32Type ?? 0;
    message.bytesRichMsg = object.bytesRichMsg ?? new Uint8Array(0);
    message.bytesPbReserve = object.bytesPbReserve ?? new Uint8Array(0);
    message.bytesSrcMsg = object.bytesSrcMsg ?? new Uint8Array(0);
    message.uint64ToUin = object.uint64ToUin ?? 0;
    message.bytesTroopName = object.bytesTroopName ?? new Uint8Array(0);
    return message;
  },
};

function createBaseWorkflowNotifyMsg(): WorkflowNotifyMsg {
  return { bytesExtMsg: new Uint8Array(0), uint64CreateUin: 0 };
}

export const WorkflowNotifyMsg: MessageFns<WorkflowNotifyMsg> = {
  encode(message: WorkflowNotifyMsg, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.bytesExtMsg !== undefined && message.bytesExtMsg.length !== 0) {
      writer.uint32(10).bytes(message.bytesExtMsg);
    }
    if (message.uint64CreateUin !== undefined && message.uint64CreateUin !== 0) {
      writer.uint32(16).uint64(message.uint64CreateUin);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): WorkflowNotifyMsg {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseWorkflowNotifyMsg();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.bytesExtMsg = reader.bytes();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.uint64CreateUin = longToNumber(reader.uint64());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): WorkflowNotifyMsg {
    return {
      bytesExtMsg: isSet(object.bytesExtMsg) ? bytesFromBase64(object.bytesExtMsg) : new Uint8Array(0),
      uint64CreateUin: isSet(object.uint64CreateUin) ? globalThis.Number(object.uint64CreateUin) : 0,
    };
  },

  toJSON(message: WorkflowNotifyMsg): unknown {
    const obj: any = {};
    if (message.bytesExtMsg !== undefined && message.bytesExtMsg.length !== 0) {
      obj.bytesExtMsg = base64FromBytes(message.bytesExtMsg);
    }
    if (message.uint64CreateUin !== undefined && message.uint64CreateUin !== 0) {
      obj.uint64CreateUin = Math.round(message.uint64CreateUin);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<WorkflowNotifyMsg>, I>>(base?: I): WorkflowNotifyMsg {
    return WorkflowNotifyMsg.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<WorkflowNotifyMsg>, I>>(object: I): WorkflowNotifyMsg {
    const message = createBaseWorkflowNotifyMsg();
    message.bytesExtMsg = object.bytesExtMsg ?? new Uint8Array(0);
    message.uint64CreateUin = object.uint64CreateUin ?? 0;
    return message;
  },
};

function createBasePatsElem(): PatsElem {
  return { uint32PatType: 0, uint32PatCount: 0 };
}

export const PatsElem: MessageFns<PatsElem> = {
  encode(message: PatsElem, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.uint32PatType !== undefined && message.uint32PatType !== 0) {
      writer.uint32(8).uint32(message.uint32PatType);
    }
    if (message.uint32PatCount !== undefined && message.uint32PatCount !== 0) {
      writer.uint32(16).uint32(message.uint32PatCount);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PatsElem {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePatsElem();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.uint32PatType = reader.uint32();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.uint32PatCount = reader.uint32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PatsElem {
    return {
      uint32PatType: isSet(object.uint32PatType) ? globalThis.Number(object.uint32PatType) : 0,
      uint32PatCount: isSet(object.uint32PatCount) ? globalThis.Number(object.uint32PatCount) : 0,
    };
  },

  toJSON(message: PatsElem): unknown {
    const obj: any = {};
    if (message.uint32PatType !== undefined && message.uint32PatType !== 0) {
      obj.uint32PatType = Math.round(message.uint32PatType);
    }
    if (message.uint32PatCount !== undefined && message.uint32PatCount !== 0) {
      obj.uint32PatCount = Math.round(message.uint32PatCount);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<PatsElem>, I>>(base?: I): PatsElem {
    return PatsElem.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<PatsElem>, I>>(object: I): PatsElem {
    const message = createBasePatsElem();
    message.uint32PatType = object.uint32PatType ?? 0;
    message.uint32PatCount = object.uint32PatCount ?? 0;
    return message;
  },
};

function createBaseGroupPostElem(): GroupPostElem {
  return { uint32TransType: 0, bytesTransMsg: new Uint8Array(0) };
}

export const GroupPostElem: MessageFns<GroupPostElem> = {
  encode(message: GroupPostElem, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.uint32TransType !== undefined && message.uint32TransType !== 0) {
      writer.uint32(8).uint32(message.uint32TransType);
    }
    if (message.bytesTransMsg !== undefined && message.bytesTransMsg.length !== 0) {
      writer.uint32(18).bytes(message.bytesTransMsg);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GroupPostElem {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGroupPostElem();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.uint32TransType = reader.uint32();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.bytesTransMsg = reader.bytes();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GroupPostElem {
    return {
      uint32TransType: isSet(object.uint32TransType) ? globalThis.Number(object.uint32TransType) : 0,
      bytesTransMsg: isSet(object.bytesTransMsg) ? bytesFromBase64(object.bytesTransMsg) : new Uint8Array(0),
    };
  },

  toJSON(message: GroupPostElem): unknown {
    const obj: any = {};
    if (message.uint32TransType !== undefined && message.uint32TransType !== 0) {
      obj.uint32TransType = Math.round(message.uint32TransType);
    }
    if (message.bytesTransMsg !== undefined && message.bytesTransMsg.length !== 0) {
      obj.bytesTransMsg = base64FromBytes(message.bytesTransMsg);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GroupPostElem>, I>>(base?: I): GroupPostElem {
    return GroupPostElem.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GroupPostElem>, I>>(object: I): GroupPostElem {
    const message = createBaseGroupPostElem();
    message.uint32TransType = object.uint32TransType ?? 0;
    message.bytesTransMsg = object.bytesTransMsg ?? new Uint8Array(0);
    return message;
  },
};

function createBaseEIMInfo(): EIMInfo {
  return { uint64RootId: 0, uint32Flag: 0 };
}

export const EIMInfo: MessageFns<EIMInfo> = {
  encode(message: EIMInfo, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.uint64RootId !== undefined && message.uint64RootId !== 0) {
      writer.uint32(8).uint64(message.uint64RootId);
    }
    if (message.uint32Flag !== undefined && message.uint32Flag !== 0) {
      writer.uint32(16).uint32(message.uint32Flag);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): EIMInfo {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEIMInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.uint64RootId = longToNumber(reader.uint64());
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.uint32Flag = reader.uint32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): EIMInfo {
    return {
      uint64RootId: isSet(object.uint64RootId) ? globalThis.Number(object.uint64RootId) : 0,
      uint32Flag: isSet(object.uint32Flag) ? globalThis.Number(object.uint32Flag) : 0,
    };
  },

  toJSON(message: EIMInfo): unknown {
    const obj: any = {};
    if (message.uint64RootId !== undefined && message.uint64RootId !== 0) {
      obj.uint64RootId = Math.round(message.uint64RootId);
    }
    if (message.uint32Flag !== undefined && message.uint32Flag !== 0) {
      obj.uint32Flag = Math.round(message.uint32Flag);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<EIMInfo>, I>>(base?: I): EIMInfo {
    return EIMInfo.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<EIMInfo>, I>>(object: I): EIMInfo {
    const message = createBaseEIMInfo();
    message.uint64RootId = object.uint64RootId ?? 0;
    message.uint32Flag = object.uint32Flag ?? 0;
    return message;
  },
};

function bytesFromBase64(b64: string): Uint8Array {
  if ((globalThis as any).Buffer) {
    return Uint8Array.from(globalThis.Buffer.from(b64, "base64"));
  } else {
    const bin = globalThis.atob(b64);
    const arr = new Uint8Array(bin.length);
    for (let i = 0; i < bin.length; ++i) {
      arr[i] = bin.charCodeAt(i);
    }
    return arr;
  }
}

function base64FromBytes(arr: Uint8Array): string {
  if ((globalThis as any).Buffer) {
    return globalThis.Buffer.from(arr).toString("base64");
  } else {
    const bin: string[] = [];
    arr.forEach((byte) => {
      bin.push(globalThis.String.fromCharCode(byte));
    });
    return globalThis.btoa(bin.join(""));
  }
}

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

type KeysOfUnion<T> = T extends T ? keyof T : never;
export type Exact<P, I extends P> = P extends Builtin ? P
  : P & { [K in keyof P]: Exact<P[K], I[K]> } & { [K in Exclude<keyof I, KeysOfUnion<P>>]: never };

function longToNumber(int64: { toString(): string }): number {
  const num = globalThis.Number(int64.toString());
  if (num > globalThis.Number.MAX_SAFE_INTEGER) {
    throw new globalThis.Error("Value is larger than Number.MAX_SAFE_INTEGER");
  }
  if (num < globalThis.Number.MIN_SAFE_INTEGER) {
    throw new globalThis.Error("Value is smaller than Number.MIN_SAFE_INTEGER");
  }
  return num;
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create<I extends Exact<DeepPartial<T>, I>>(base?: I): T;
  fromPartial<I extends Exact<DeepPartial<T>, I>>(object: I): T;
}
