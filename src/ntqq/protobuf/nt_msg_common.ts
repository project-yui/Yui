// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.2.5
//   protoc               v6.32.1
// source: nt_msg_common.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import { MsgBody } from "./im_msg_body";

export const protobufPackage = "trpc.msg.common";

/** 群消息 */
export interface Group {
  groupCode?:
    | number
    | undefined;
  /** 0x7f表示空消息，客户端不展示消息体 */
  groupType?: number | undefined;
  groupInfoSeq?:
    | number
    | undefined;
  /** 名片信息 */
  groupCard?:
    | Uint8Array
    | undefined;
  /** group_card类型, 1:群名片; 2:昵称 3:智能备注 */
  groupCardType?:
    | number
    | undefined;
  /** 群成员等级 */
  groupLevel?:
    | number
    | undefined;
  /** 群名 */
  groupName?:
    | Uint8Array
    | undefined;
  /** 扩展的群关键信息, 透传 */
  extGroupKeyInfo?:
    | Uint8Array
    | undefined;
  /** 消息标识: 第0位(mask:0x1)表示特别关注的人所发的消息 */
  msgFlag?: number | undefined;
}

/** c2c消息，系统消息，扩展信息 */
export interface C2c {
}

export interface RoutingHead {
  /** 发送方uin */
  fromUin?:
    | number
    | undefined;
  /** 发送方uid */
  fromUid?: Uint8Array | undefined;
  fromAppid?: number | undefined;
  fromInstid?:
    | number
    | undefined;
  /** 接收方 */
  toUin?:
    | number
    | undefined;
  /** 接收方uid */
  toUid?:
    | Uint8Array
    | undefined;
  /** c2c消息相关属性，c2c消息非必填字段，不能根据这个字段是否存在来判断c2c消息 */
  c2c?:
    | C2c
    | undefined;
  /** 群消息相关属性，群消息必填 */
  group?: Group | undefined;
}

export interface ContentHead {
  /** 消息类型 */
  msgType?:
    | number
    | undefined;
  /** 消息子类型（0x211\0x2dc\0x210等系统消息的子类型,取值同c2c_cmd） */
  subType?:
    | number
    | undefined;
  /** c2c消息子类型 */
  c2cCmd?: number | undefined;
  random?:
    | number
    | undefined;
  /** 消息seq */
  msgSeq?: number | undefined;
  msgTime?:
    | number
    | undefined;
  /** 分包数目，消息需要分包发送时该值不为1 */
  pkgNum?:
    | number
    | undefined;
  /** 当前分包索引，从 0开始 */
  pkgIndex?:
    | number
    | undefined;
  /** 消息分包的序列号，同一条消息的各个分包的 div_seq 相同 */
  divSeq?: number | undefined;
  autoReply?:
    | number
    | undefined;
  /** 两个uin之间c2c消息唯一递增seq */
  ntMsgSeq?: number | undefined;
  msgUid?: number | undefined;
}

export interface Msg {
  routingHead?: RoutingHead | undefined;
  contentHead?:
    | ContentHead
    | undefined;
  /** 消息体 */
  body?: MsgBody | undefined;
}

function createBaseGroup(): Group {
  return {
    groupCode: 0,
    groupType: 0,
    groupInfoSeq: 0,
    groupCard: new Uint8Array(0),
    groupCardType: 0,
    groupLevel: 0,
    groupName: new Uint8Array(0),
    extGroupKeyInfo: new Uint8Array(0),
    msgFlag: 0,
  };
}

export const Group: MessageFns<Group> = {
  encode(message: Group, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.groupCode !== undefined && message.groupCode !== 0) {
      writer.uint32(8).uint64(message.groupCode);
    }
    if (message.groupType !== undefined && message.groupType !== 0) {
      writer.uint32(16).uint32(message.groupType);
    }
    if (message.groupInfoSeq !== undefined && message.groupInfoSeq !== 0) {
      writer.uint32(24).uint64(message.groupInfoSeq);
    }
    if (message.groupCard !== undefined && message.groupCard.length !== 0) {
      writer.uint32(34).bytes(message.groupCard);
    }
    if (message.groupCardType !== undefined && message.groupCardType !== 0) {
      writer.uint32(40).uint32(message.groupCardType);
    }
    if (message.groupLevel !== undefined && message.groupLevel !== 0) {
      writer.uint32(48).uint32(message.groupLevel);
    }
    if (message.groupName !== undefined && message.groupName.length !== 0) {
      writer.uint32(58).bytes(message.groupName);
    }
    if (message.extGroupKeyInfo !== undefined && message.extGroupKeyInfo.length !== 0) {
      writer.uint32(66).bytes(message.extGroupKeyInfo);
    }
    if (message.msgFlag !== undefined && message.msgFlag !== 0) {
      writer.uint32(72).uint32(message.msgFlag);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Group {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGroup();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.groupCode = longToNumber(reader.uint64());
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.groupType = reader.uint32();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.groupInfoSeq = longToNumber(reader.uint64());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.groupCard = reader.bytes();
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.groupCardType = reader.uint32();
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.groupLevel = reader.uint32();
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.groupName = reader.bytes();
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.extGroupKeyInfo = reader.bytes();
          continue;
        }
        case 9: {
          if (tag !== 72) {
            break;
          }

          message.msgFlag = reader.uint32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Group {
    return {
      groupCode: isSet(object.groupCode) ? globalThis.Number(object.groupCode) : 0,
      groupType: isSet(object.groupType) ? globalThis.Number(object.groupType) : 0,
      groupInfoSeq: isSet(object.groupInfoSeq) ? globalThis.Number(object.groupInfoSeq) : 0,
      groupCard: isSet(object.groupCard) ? bytesFromBase64(object.groupCard) : new Uint8Array(0),
      groupCardType: isSet(object.groupCardType) ? globalThis.Number(object.groupCardType) : 0,
      groupLevel: isSet(object.groupLevel) ? globalThis.Number(object.groupLevel) : 0,
      groupName: isSet(object.groupName) ? bytesFromBase64(object.groupName) : new Uint8Array(0),
      extGroupKeyInfo: isSet(object.extGroupKeyInfo) ? bytesFromBase64(object.extGroupKeyInfo) : new Uint8Array(0),
      msgFlag: isSet(object.msgFlag) ? globalThis.Number(object.msgFlag) : 0,
    };
  },

  toJSON(message: Group): unknown {
    const obj: any = {};
    if (message.groupCode !== undefined && message.groupCode !== 0) {
      obj.groupCode = Math.round(message.groupCode);
    }
    if (message.groupType !== undefined && message.groupType !== 0) {
      obj.groupType = Math.round(message.groupType);
    }
    if (message.groupInfoSeq !== undefined && message.groupInfoSeq !== 0) {
      obj.groupInfoSeq = Math.round(message.groupInfoSeq);
    }
    if (message.groupCard !== undefined && message.groupCard.length !== 0) {
      obj.groupCard = base64FromBytes(message.groupCard);
    }
    if (message.groupCardType !== undefined && message.groupCardType !== 0) {
      obj.groupCardType = Math.round(message.groupCardType);
    }
    if (message.groupLevel !== undefined && message.groupLevel !== 0) {
      obj.groupLevel = Math.round(message.groupLevel);
    }
    if (message.groupName !== undefined && message.groupName.length !== 0) {
      obj.groupName = base64FromBytes(message.groupName);
    }
    if (message.extGroupKeyInfo !== undefined && message.extGroupKeyInfo.length !== 0) {
      obj.extGroupKeyInfo = base64FromBytes(message.extGroupKeyInfo);
    }
    if (message.msgFlag !== undefined && message.msgFlag !== 0) {
      obj.msgFlag = Math.round(message.msgFlag);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Group>, I>>(base?: I): Group {
    return Group.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Group>, I>>(object: I): Group {
    const message = createBaseGroup();
    message.groupCode = object.groupCode ?? 0;
    message.groupType = object.groupType ?? 0;
    message.groupInfoSeq = object.groupInfoSeq ?? 0;
    message.groupCard = object.groupCard ?? new Uint8Array(0);
    message.groupCardType = object.groupCardType ?? 0;
    message.groupLevel = object.groupLevel ?? 0;
    message.groupName = object.groupName ?? new Uint8Array(0);
    message.extGroupKeyInfo = object.extGroupKeyInfo ?? new Uint8Array(0);
    message.msgFlag = object.msgFlag ?? 0;
    return message;
  },
};

function createBaseC2c(): C2c {
  return {};
}

export const C2c: MessageFns<C2c> = {
  encode(_: C2c, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): C2c {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseC2c();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): C2c {
    return {};
  },

  toJSON(_: C2c): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<C2c>, I>>(base?: I): C2c {
    return C2c.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<C2c>, I>>(_: I): C2c {
    const message = createBaseC2c();
    return message;
  },
};

function createBaseRoutingHead(): RoutingHead {
  return {
    fromUin: 0,
    fromUid: new Uint8Array(0),
    fromAppid: 0,
    fromInstid: 0,
    toUin: 0,
    toUid: new Uint8Array(0),
    c2c: undefined,
    group: undefined,
  };
}

export const RoutingHead: MessageFns<RoutingHead> = {
  encode(message: RoutingHead, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.fromUin !== undefined && message.fromUin !== 0) {
      writer.uint32(8).uint64(message.fromUin);
    }
    if (message.fromUid !== undefined && message.fromUid.length !== 0) {
      writer.uint32(18).bytes(message.fromUid);
    }
    if (message.fromAppid !== undefined && message.fromAppid !== 0) {
      writer.uint32(24).uint32(message.fromAppid);
    }
    if (message.fromInstid !== undefined && message.fromInstid !== 0) {
      writer.uint32(32).uint32(message.fromInstid);
    }
    if (message.toUin !== undefined && message.toUin !== 0) {
      writer.uint32(40).uint64(message.toUin);
    }
    if (message.toUid !== undefined && message.toUid.length !== 0) {
      writer.uint32(50).bytes(message.toUid);
    }
    if (message.c2c !== undefined) {
      C2c.encode(message.c2c, writer.uint32(58).fork()).join();
    }
    if (message.group !== undefined) {
      Group.encode(message.group, writer.uint32(66).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RoutingHead {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRoutingHead();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.fromUin = longToNumber(reader.uint64());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.fromUid = reader.bytes();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.fromAppid = reader.uint32();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.fromInstid = reader.uint32();
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.toUin = longToNumber(reader.uint64());
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.toUid = reader.bytes();
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.c2c = C2c.decode(reader, reader.uint32());
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.group = Group.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RoutingHead {
    return {
      fromUin: isSet(object.fromUin) ? globalThis.Number(object.fromUin) : 0,
      fromUid: isSet(object.fromUid) ? bytesFromBase64(object.fromUid) : new Uint8Array(0),
      fromAppid: isSet(object.fromAppid) ? globalThis.Number(object.fromAppid) : 0,
      fromInstid: isSet(object.fromInstid) ? globalThis.Number(object.fromInstid) : 0,
      toUin: isSet(object.toUin) ? globalThis.Number(object.toUin) : 0,
      toUid: isSet(object.toUid) ? bytesFromBase64(object.toUid) : new Uint8Array(0),
      c2c: isSet(object.c2c) ? C2c.fromJSON(object.c2c) : undefined,
      group: isSet(object.group) ? Group.fromJSON(object.group) : undefined,
    };
  },

  toJSON(message: RoutingHead): unknown {
    const obj: any = {};
    if (message.fromUin !== undefined && message.fromUin !== 0) {
      obj.fromUin = Math.round(message.fromUin);
    }
    if (message.fromUid !== undefined && message.fromUid.length !== 0) {
      obj.fromUid = base64FromBytes(message.fromUid);
    }
    if (message.fromAppid !== undefined && message.fromAppid !== 0) {
      obj.fromAppid = Math.round(message.fromAppid);
    }
    if (message.fromInstid !== undefined && message.fromInstid !== 0) {
      obj.fromInstid = Math.round(message.fromInstid);
    }
    if (message.toUin !== undefined && message.toUin !== 0) {
      obj.toUin = Math.round(message.toUin);
    }
    if (message.toUid !== undefined && message.toUid.length !== 0) {
      obj.toUid = base64FromBytes(message.toUid);
    }
    if (message.c2c !== undefined) {
      obj.c2c = C2c.toJSON(message.c2c);
    }
    if (message.group !== undefined) {
      obj.group = Group.toJSON(message.group);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<RoutingHead>, I>>(base?: I): RoutingHead {
    return RoutingHead.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<RoutingHead>, I>>(object: I): RoutingHead {
    const message = createBaseRoutingHead();
    message.fromUin = object.fromUin ?? 0;
    message.fromUid = object.fromUid ?? new Uint8Array(0);
    message.fromAppid = object.fromAppid ?? 0;
    message.fromInstid = object.fromInstid ?? 0;
    message.toUin = object.toUin ?? 0;
    message.toUid = object.toUid ?? new Uint8Array(0);
    message.c2c = (object.c2c !== undefined && object.c2c !== null) ? C2c.fromPartial(object.c2c) : undefined;
    message.group = (object.group !== undefined && object.group !== null) ? Group.fromPartial(object.group) : undefined;
    return message;
  },
};

function createBaseContentHead(): ContentHead {
  return {
    msgType: 0,
    subType: 0,
    c2cCmd: 0,
    random: 0,
    msgSeq: 0,
    msgTime: 0,
    pkgNum: 0,
    pkgIndex: 0,
    divSeq: 0,
    autoReply: 0,
    ntMsgSeq: 0,
    msgUid: 0,
  };
}

export const ContentHead: MessageFns<ContentHead> = {
  encode(message: ContentHead, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.msgType !== undefined && message.msgType !== 0) {
      writer.uint32(8).uint64(message.msgType);
    }
    if (message.subType !== undefined && message.subType !== 0) {
      writer.uint32(16).uint64(message.subType);
    }
    if (message.c2cCmd !== undefined && message.c2cCmd !== 0) {
      writer.uint32(24).uint32(message.c2cCmd);
    }
    if (message.random !== undefined && message.random !== 0) {
      writer.uint32(32).uint64(message.random);
    }
    if (message.msgSeq !== undefined && message.msgSeq !== 0) {
      writer.uint32(40).uint64(message.msgSeq);
    }
    if (message.msgTime !== undefined && message.msgTime !== 0) {
      writer.uint32(48).uint64(message.msgTime);
    }
    if (message.pkgNum !== undefined && message.pkgNum !== 0) {
      writer.uint32(56).uint32(message.pkgNum);
    }
    if (message.pkgIndex !== undefined && message.pkgIndex !== 0) {
      writer.uint32(64).uint32(message.pkgIndex);
    }
    if (message.divSeq !== undefined && message.divSeq !== 0) {
      writer.uint32(72).uint32(message.divSeq);
    }
    if (message.autoReply !== undefined && message.autoReply !== 0) {
      writer.uint32(80).uint32(message.autoReply);
    }
    if (message.ntMsgSeq !== undefined && message.ntMsgSeq !== 0) {
      writer.uint32(88).uint64(message.ntMsgSeq);
    }
    if (message.msgUid !== undefined && message.msgUid !== 0) {
      writer.uint32(96).uint64(message.msgUid);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ContentHead {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseContentHead();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.msgType = longToNumber(reader.uint64());
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.subType = longToNumber(reader.uint64());
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.c2cCmd = reader.uint32();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.random = longToNumber(reader.uint64());
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.msgSeq = longToNumber(reader.uint64());
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.msgTime = longToNumber(reader.uint64());
          continue;
        }
        case 7: {
          if (tag !== 56) {
            break;
          }

          message.pkgNum = reader.uint32();
          continue;
        }
        case 8: {
          if (tag !== 64) {
            break;
          }

          message.pkgIndex = reader.uint32();
          continue;
        }
        case 9: {
          if (tag !== 72) {
            break;
          }

          message.divSeq = reader.uint32();
          continue;
        }
        case 10: {
          if (tag !== 80) {
            break;
          }

          message.autoReply = reader.uint32();
          continue;
        }
        case 11: {
          if (tag !== 88) {
            break;
          }

          message.ntMsgSeq = longToNumber(reader.uint64());
          continue;
        }
        case 12: {
          if (tag !== 96) {
            break;
          }

          message.msgUid = longToNumber(reader.uint64());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ContentHead {
    return {
      msgType: isSet(object.msgType) ? globalThis.Number(object.msgType) : 0,
      subType: isSet(object.subType) ? globalThis.Number(object.subType) : 0,
      c2cCmd: isSet(object.c2cCmd) ? globalThis.Number(object.c2cCmd) : 0,
      random: isSet(object.random) ? globalThis.Number(object.random) : 0,
      msgSeq: isSet(object.msgSeq) ? globalThis.Number(object.msgSeq) : 0,
      msgTime: isSet(object.msgTime) ? globalThis.Number(object.msgTime) : 0,
      pkgNum: isSet(object.pkgNum) ? globalThis.Number(object.pkgNum) : 0,
      pkgIndex: isSet(object.pkgIndex) ? globalThis.Number(object.pkgIndex) : 0,
      divSeq: isSet(object.divSeq) ? globalThis.Number(object.divSeq) : 0,
      autoReply: isSet(object.autoReply) ? globalThis.Number(object.autoReply) : 0,
      ntMsgSeq: isSet(object.ntMsgSeq) ? globalThis.Number(object.ntMsgSeq) : 0,
      msgUid: isSet(object.msgUid) ? globalThis.Number(object.msgUid) : 0,
    };
  },

  toJSON(message: ContentHead): unknown {
    const obj: any = {};
    if (message.msgType !== undefined && message.msgType !== 0) {
      obj.msgType = Math.round(message.msgType);
    }
    if (message.subType !== undefined && message.subType !== 0) {
      obj.subType = Math.round(message.subType);
    }
    if (message.c2cCmd !== undefined && message.c2cCmd !== 0) {
      obj.c2cCmd = Math.round(message.c2cCmd);
    }
    if (message.random !== undefined && message.random !== 0) {
      obj.random = Math.round(message.random);
    }
    if (message.msgSeq !== undefined && message.msgSeq !== 0) {
      obj.msgSeq = Math.round(message.msgSeq);
    }
    if (message.msgTime !== undefined && message.msgTime !== 0) {
      obj.msgTime = Math.round(message.msgTime);
    }
    if (message.pkgNum !== undefined && message.pkgNum !== 0) {
      obj.pkgNum = Math.round(message.pkgNum);
    }
    if (message.pkgIndex !== undefined && message.pkgIndex !== 0) {
      obj.pkgIndex = Math.round(message.pkgIndex);
    }
    if (message.divSeq !== undefined && message.divSeq !== 0) {
      obj.divSeq = Math.round(message.divSeq);
    }
    if (message.autoReply !== undefined && message.autoReply !== 0) {
      obj.autoReply = Math.round(message.autoReply);
    }
    if (message.ntMsgSeq !== undefined && message.ntMsgSeq !== 0) {
      obj.ntMsgSeq = Math.round(message.ntMsgSeq);
    }
    if (message.msgUid !== undefined && message.msgUid !== 0) {
      obj.msgUid = Math.round(message.msgUid);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ContentHead>, I>>(base?: I): ContentHead {
    return ContentHead.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ContentHead>, I>>(object: I): ContentHead {
    const message = createBaseContentHead();
    message.msgType = object.msgType ?? 0;
    message.subType = object.subType ?? 0;
    message.c2cCmd = object.c2cCmd ?? 0;
    message.random = object.random ?? 0;
    message.msgSeq = object.msgSeq ?? 0;
    message.msgTime = object.msgTime ?? 0;
    message.pkgNum = object.pkgNum ?? 0;
    message.pkgIndex = object.pkgIndex ?? 0;
    message.divSeq = object.divSeq ?? 0;
    message.autoReply = object.autoReply ?? 0;
    message.ntMsgSeq = object.ntMsgSeq ?? 0;
    message.msgUid = object.msgUid ?? 0;
    return message;
  },
};

function createBaseMsg(): Msg {
  return { routingHead: undefined, contentHead: undefined, body: undefined };
}

export const Msg: MessageFns<Msg> = {
  encode(message: Msg, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.routingHead !== undefined) {
      RoutingHead.encode(message.routingHead, writer.uint32(10).fork()).join();
    }
    if (message.contentHead !== undefined) {
      ContentHead.encode(message.contentHead, writer.uint32(18).fork()).join();
    }
    if (message.body !== undefined) {
      MsgBody.encode(message.body, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Msg {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsg();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.routingHead = RoutingHead.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.contentHead = ContentHead.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.body = MsgBody.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Msg {
    return {
      routingHead: isSet(object.routingHead) ? RoutingHead.fromJSON(object.routingHead) : undefined,
      contentHead: isSet(object.contentHead) ? ContentHead.fromJSON(object.contentHead) : undefined,
      body: isSet(object.body) ? MsgBody.fromJSON(object.body) : undefined,
    };
  },

  toJSON(message: Msg): unknown {
    const obj: any = {};
    if (message.routingHead !== undefined) {
      obj.routingHead = RoutingHead.toJSON(message.routingHead);
    }
    if (message.contentHead !== undefined) {
      obj.contentHead = ContentHead.toJSON(message.contentHead);
    }
    if (message.body !== undefined) {
      obj.body = MsgBody.toJSON(message.body);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Msg>, I>>(base?: I): Msg {
    return Msg.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Msg>, I>>(object: I): Msg {
    const message = createBaseMsg();
    message.routingHead = (object.routingHead !== undefined && object.routingHead !== null)
      ? RoutingHead.fromPartial(object.routingHead)
      : undefined;
    message.contentHead = (object.contentHead !== undefined && object.contentHead !== null)
      ? ContentHead.fromPartial(object.contentHead)
      : undefined;
    message.body = (object.body !== undefined && object.body !== null) ? MsgBody.fromPartial(object.body) : undefined;
    return message;
  },
};

function bytesFromBase64(b64: string): Uint8Array {
  if ((globalThis as any).Buffer) {
    return Uint8Array.from(globalThis.Buffer.from(b64, "base64"));
  } else {
    const bin = globalThis.atob(b64);
    const arr = new Uint8Array(bin.length);
    for (let i = 0; i < bin.length; ++i) {
      arr[i] = bin.charCodeAt(i);
    }
    return arr;
  }
}

function base64FromBytes(arr: Uint8Array): string {
  if ((globalThis as any).Buffer) {
    return globalThis.Buffer.from(arr).toString("base64");
  } else {
    const bin: string[] = [];
    arr.forEach((byte) => {
      bin.push(globalThis.String.fromCharCode(byte));
    });
    return globalThis.btoa(bin.join(""));
  }
}

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

type KeysOfUnion<T> = T extends T ? keyof T : never;
export type Exact<P, I extends P> = P extends Builtin ? P
  : P & { [K in keyof P]: Exact<P[K], I[K]> } & { [K in Exclude<keyof I, KeysOfUnion<P>>]: never };

function longToNumber(int64: { toString(): string }): number {
  const num = globalThis.Number(int64.toString());
  if (num > globalThis.Number.MAX_SAFE_INTEGER) {
    throw new globalThis.Error("Value is larger than Number.MAX_SAFE_INTEGER");
  }
  if (num < globalThis.Number.MIN_SAFE_INTEGER) {
    throw new globalThis.Error("Value is smaller than Number.MIN_SAFE_INTEGER");
  }
  return num;
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create<I extends Exact<DeepPartial<T>, I>>(base?: I): T;
  fromPartial<I extends Exact<DeepPartial<T>, I>>(object: I): T;
}
