// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.2.5
//   protoc               v6.32.1
// source: CSDataHighwayHead.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";

export const protobufPackage = "CSDataHighwayHead";

export interface C2CCommonExtendinfo {
  uint32InfoId?: number | undefined;
  msgFilterExtendinfo?: FilterExtendinfo | undefined;
}

export interface DataHighwayHead {
  uint32Version?: number | undefined;
  bytesUin?: string | undefined;
  bytesCommand?: string | undefined;
  uint32Seq?: number | undefined;
  uint32RetryTimes?: number | undefined;
  uint32Appid?: number | undefined;
  uint32Dataflag?: number | undefined;
  uint32CommandId?: number | undefined;
  bytesBuildVer?: Uint8Array | undefined;
  localeId?: number | undefined;
  envId?: number | undefined;
}

export interface DataHole {
  uint64Begin?: number | undefined;
  uint64End?: number | undefined;
}

export interface FilterExtendinfo {
  uint32FilterFlag?: number | undefined;
  msgImageFilterRequest?: ImageFilterRequest | undefined;
}

export interface FilterStyle {
  styleId?: number | undefined;
  styleName?: Uint8Array | undefined;
}

export interface ImageFilterRequest {
  sessionId?: Uint8Array | undefined;
  clientIp?: number | undefined;
  uin?: number | undefined;
  style?: FilterStyle | undefined;
  width?: number | undefined;
  height?: number | undefined;
  imageData?: Uint8Array | undefined;
}

export interface ImageFilterResponse {
  retCode?: number | undefined;
  imageData?: Uint8Array | undefined;
  costTime?: number | undefined;
}

export interface LoginSigHead {
  uint32LoginsigType?: number | undefined;
  bytesLoginsig?: Uint8Array | undefined;
  appid?: number | undefined;
}

export interface NewServiceTicket {
  bytesSignature?: Uint8Array | undefined;
  bytesUkey?: Uint8Array | undefined;
}

export interface PicInfoExt {
  uint32PicWidth?: number | undefined;
  uint32PicHeight?: number | undefined;
  uint32PicFlag?: number | undefined;
  uint32BusiType?: number | undefined;
  uint32SrcTerm?: number | undefined;
  uint32PlatType?: number | undefined;
  uint32NetType?: number | undefined;
  uint32ImgType?: number | undefined;
  uint32AppPicType?: number | undefined;
  bytesEchoCreatedByServer?: Uint8Array | undefined;
  uint64QqmeetGuildId?: number | undefined;
  uint64QqmeetChannelId?: number | undefined;
}

export interface PicRspExtInfo {
  bytesSkey?: Uint8Array | undefined;
  uint32ClientIp?: number | undefined;
  uint64UpOffset?: number | undefined;
  uint64BlockSize?: number | undefined;
}

export interface QueryHoleRsp {
  uint32Result?: number | undefined;
  rptDataHole: DataHole[];
  boolCompFlag?: boolean | undefined;
}

export interface ReqDataHighwayHead {
  msgBasehead?: DataHighwayHead | undefined;
  msgSeghead?: SegHead | undefined;
  bytesReqExtendinfo?: Uint8Array | undefined;
  uint64Timestamp?: number | undefined;
  msgLoginSigHead?: LoginSigHead | undefined;
}

export interface RspBody {
  msgQueryHoleRsp?: QueryHoleRsp | undefined;
}

export interface RspDataHighwayHead {
  msgBasehead?: DataHighwayHead | undefined;
  msgSeghead?: SegHead | undefined;
  uint32ErrorCode?: number | undefined;
  uint32AllowRetry?: number | undefined;
  uint32Cachecost?: number | undefined;
  uint32Htcost?: number | undefined;
  bytesRspExtendinfo?: Uint8Array | undefined;
  uint64Timestamp?: number | undefined;
  uint64Range?: number | undefined;
  uint32IsReset?: number | undefined;
}

export interface SegHead {
  uint32Serviceid?: number | undefined;
  uint64Filesize?: number | undefined;
  uint64Dataoffset?: number | undefined;
  uint32Datalength?: number | undefined;
  uint32Rtcode?: number | undefined;
  bytesServiceticket?: Uint8Array | undefined;
  uint32Flag?: number | undefined;
  bytesMd5?: Uint8Array | undefined;
  bytesFileMd5?: Uint8Array | undefined;
  uint32CacheAddr?: number | undefined;
  uint32QueryTimes?: number | undefined;
  uint32UpdateCacheip?: number | undefined;
  uint32CachePort?: number | undefined;
}

function createBaseC2CCommonExtendinfo(): C2CCommonExtendinfo {
  return { uint32InfoId: undefined, msgFilterExtendinfo: undefined };
}

export const C2CCommonExtendinfo: MessageFns<C2CCommonExtendinfo> = {
  encode(message: C2CCommonExtendinfo, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.uint32InfoId !== undefined) {
      writer.uint32(8).uint32(message.uint32InfoId);
    }
    if (message.msgFilterExtendinfo !== undefined) {
      FilterExtendinfo.encode(message.msgFilterExtendinfo, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): C2CCommonExtendinfo {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseC2CCommonExtendinfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.uint32InfoId = reader.uint32();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.msgFilterExtendinfo = FilterExtendinfo.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): C2CCommonExtendinfo {
    return {
      uint32InfoId: isSet(object.uint32InfoId) ? globalThis.Number(object.uint32InfoId) : undefined,
      msgFilterExtendinfo: isSet(object.msgFilterExtendinfo)
        ? FilterExtendinfo.fromJSON(object.msgFilterExtendinfo)
        : undefined,
    };
  },

  toJSON(message: C2CCommonExtendinfo): unknown {
    const obj: any = {};
    if (message.uint32InfoId !== undefined) {
      obj.uint32InfoId = Math.round(message.uint32InfoId);
    }
    if (message.msgFilterExtendinfo !== undefined) {
      obj.msgFilterExtendinfo = FilterExtendinfo.toJSON(message.msgFilterExtendinfo);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<C2CCommonExtendinfo>, I>>(base?: I): C2CCommonExtendinfo {
    return C2CCommonExtendinfo.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<C2CCommonExtendinfo>, I>>(object: I): C2CCommonExtendinfo {
    const message = createBaseC2CCommonExtendinfo();
    message.uint32InfoId = object.uint32InfoId ?? undefined;
    message.msgFilterExtendinfo = (object.msgFilterExtendinfo !== undefined && object.msgFilterExtendinfo !== null)
      ? FilterExtendinfo.fromPartial(object.msgFilterExtendinfo)
      : undefined;
    return message;
  },
};

function createBaseDataHighwayHead(): DataHighwayHead {
  return {
    uint32Version: undefined,
    bytesUin: undefined,
    bytesCommand: undefined,
    uint32Seq: undefined,
    uint32RetryTimes: undefined,
    uint32Appid: undefined,
    uint32Dataflag: undefined,
    uint32CommandId: undefined,
    bytesBuildVer: undefined,
    localeId: undefined,
    envId: undefined,
  };
}

export const DataHighwayHead: MessageFns<DataHighwayHead> = {
  encode(message: DataHighwayHead, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.uint32Version !== undefined) {
      writer.uint32(8).uint32(message.uint32Version);
    }
    if (message.bytesUin !== undefined) {
      writer.uint32(18).string(message.bytesUin);
    }
    if (message.bytesCommand !== undefined) {
      writer.uint32(26).string(message.bytesCommand);
    }
    if (message.uint32Seq !== undefined) {
      writer.uint32(32).uint32(message.uint32Seq);
    }
    if (message.uint32RetryTimes !== undefined) {
      writer.uint32(40).uint32(message.uint32RetryTimes);
    }
    if (message.uint32Appid !== undefined) {
      writer.uint32(48).uint32(message.uint32Appid);
    }
    if (message.uint32Dataflag !== undefined) {
      writer.uint32(56).uint32(message.uint32Dataflag);
    }
    if (message.uint32CommandId !== undefined) {
      writer.uint32(64).uint32(message.uint32CommandId);
    }
    if (message.bytesBuildVer !== undefined) {
      writer.uint32(74).bytes(message.bytesBuildVer);
    }
    if (message.localeId !== undefined) {
      writer.uint32(80).uint32(message.localeId);
    }
    if (message.envId !== undefined) {
      writer.uint32(88).uint32(message.envId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DataHighwayHead {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDataHighwayHead();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.uint32Version = reader.uint32();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.bytesUin = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.bytesCommand = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.uint32Seq = reader.uint32();
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.uint32RetryTimes = reader.uint32();
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.uint32Appid = reader.uint32();
          continue;
        }
        case 7: {
          if (tag !== 56) {
            break;
          }

          message.uint32Dataflag = reader.uint32();
          continue;
        }
        case 8: {
          if (tag !== 64) {
            break;
          }

          message.uint32CommandId = reader.uint32();
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.bytesBuildVer = reader.bytes();
          continue;
        }
        case 10: {
          if (tag !== 80) {
            break;
          }

          message.localeId = reader.uint32();
          continue;
        }
        case 11: {
          if (tag !== 88) {
            break;
          }

          message.envId = reader.uint32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DataHighwayHead {
    return {
      uint32Version: isSet(object.uint32Version) ? globalThis.Number(object.uint32Version) : undefined,
      bytesUin: isSet(object.bytesUin) ? globalThis.String(object.bytesUin) : undefined,
      bytesCommand: isSet(object.bytesCommand) ? globalThis.String(object.bytesCommand) : undefined,
      uint32Seq: isSet(object.uint32Seq) ? globalThis.Number(object.uint32Seq) : undefined,
      uint32RetryTimes: isSet(object.uint32RetryTimes) ? globalThis.Number(object.uint32RetryTimes) : undefined,
      uint32Appid: isSet(object.uint32Appid) ? globalThis.Number(object.uint32Appid) : undefined,
      uint32Dataflag: isSet(object.uint32Dataflag) ? globalThis.Number(object.uint32Dataflag) : undefined,
      uint32CommandId: isSet(object.uint32CommandId) ? globalThis.Number(object.uint32CommandId) : undefined,
      bytesBuildVer: isSet(object.bytesBuildVer) ? bytesFromBase64(object.bytesBuildVer) : undefined,
      localeId: isSet(object.localeId) ? globalThis.Number(object.localeId) : undefined,
      envId: isSet(object.envId) ? globalThis.Number(object.envId) : undefined,
    };
  },

  toJSON(message: DataHighwayHead): unknown {
    const obj: any = {};
    if (message.uint32Version !== undefined) {
      obj.uint32Version = Math.round(message.uint32Version);
    }
    if (message.bytesUin !== undefined) {
      obj.bytesUin = message.bytesUin;
    }
    if (message.bytesCommand !== undefined) {
      obj.bytesCommand = message.bytesCommand;
    }
    if (message.uint32Seq !== undefined) {
      obj.uint32Seq = Math.round(message.uint32Seq);
    }
    if (message.uint32RetryTimes !== undefined) {
      obj.uint32RetryTimes = Math.round(message.uint32RetryTimes);
    }
    if (message.uint32Appid !== undefined) {
      obj.uint32Appid = Math.round(message.uint32Appid);
    }
    if (message.uint32Dataflag !== undefined) {
      obj.uint32Dataflag = Math.round(message.uint32Dataflag);
    }
    if (message.uint32CommandId !== undefined) {
      obj.uint32CommandId = Math.round(message.uint32CommandId);
    }
    if (message.bytesBuildVer !== undefined) {
      obj.bytesBuildVer = base64FromBytes(message.bytesBuildVer);
    }
    if (message.localeId !== undefined) {
      obj.localeId = Math.round(message.localeId);
    }
    if (message.envId !== undefined) {
      obj.envId = Math.round(message.envId);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<DataHighwayHead>, I>>(base?: I): DataHighwayHead {
    return DataHighwayHead.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<DataHighwayHead>, I>>(object: I): DataHighwayHead {
    const message = createBaseDataHighwayHead();
    message.uint32Version = object.uint32Version ?? undefined;
    message.bytesUin = object.bytesUin ?? undefined;
    message.bytesCommand = object.bytesCommand ?? undefined;
    message.uint32Seq = object.uint32Seq ?? undefined;
    message.uint32RetryTimes = object.uint32RetryTimes ?? undefined;
    message.uint32Appid = object.uint32Appid ?? undefined;
    message.uint32Dataflag = object.uint32Dataflag ?? undefined;
    message.uint32CommandId = object.uint32CommandId ?? undefined;
    message.bytesBuildVer = object.bytesBuildVer ?? undefined;
    message.localeId = object.localeId ?? undefined;
    message.envId = object.envId ?? undefined;
    return message;
  },
};

function createBaseDataHole(): DataHole {
  return { uint64Begin: undefined, uint64End: undefined };
}

export const DataHole: MessageFns<DataHole> = {
  encode(message: DataHole, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.uint64Begin !== undefined) {
      writer.uint32(8).uint64(message.uint64Begin);
    }
    if (message.uint64End !== undefined) {
      writer.uint32(16).uint64(message.uint64End);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DataHole {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDataHole();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.uint64Begin = longToNumber(reader.uint64());
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.uint64End = longToNumber(reader.uint64());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DataHole {
    return {
      uint64Begin: isSet(object.uint64Begin) ? globalThis.Number(object.uint64Begin) : undefined,
      uint64End: isSet(object.uint64End) ? globalThis.Number(object.uint64End) : undefined,
    };
  },

  toJSON(message: DataHole): unknown {
    const obj: any = {};
    if (message.uint64Begin !== undefined) {
      obj.uint64Begin = Math.round(message.uint64Begin);
    }
    if (message.uint64End !== undefined) {
      obj.uint64End = Math.round(message.uint64End);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<DataHole>, I>>(base?: I): DataHole {
    return DataHole.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<DataHole>, I>>(object: I): DataHole {
    const message = createBaseDataHole();
    message.uint64Begin = object.uint64Begin ?? undefined;
    message.uint64End = object.uint64End ?? undefined;
    return message;
  },
};

function createBaseFilterExtendinfo(): FilterExtendinfo {
  return { uint32FilterFlag: undefined, msgImageFilterRequest: undefined };
}

export const FilterExtendinfo: MessageFns<FilterExtendinfo> = {
  encode(message: FilterExtendinfo, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.uint32FilterFlag !== undefined) {
      writer.uint32(8).uint32(message.uint32FilterFlag);
    }
    if (message.msgImageFilterRequest !== undefined) {
      ImageFilterRequest.encode(message.msgImageFilterRequest, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): FilterExtendinfo {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseFilterExtendinfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.uint32FilterFlag = reader.uint32();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.msgImageFilterRequest = ImageFilterRequest.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): FilterExtendinfo {
    return {
      uint32FilterFlag: isSet(object.uint32FilterFlag) ? globalThis.Number(object.uint32FilterFlag) : undefined,
      msgImageFilterRequest: isSet(object.msgImageFilterRequest)
        ? ImageFilterRequest.fromJSON(object.msgImageFilterRequest)
        : undefined,
    };
  },

  toJSON(message: FilterExtendinfo): unknown {
    const obj: any = {};
    if (message.uint32FilterFlag !== undefined) {
      obj.uint32FilterFlag = Math.round(message.uint32FilterFlag);
    }
    if (message.msgImageFilterRequest !== undefined) {
      obj.msgImageFilterRequest = ImageFilterRequest.toJSON(message.msgImageFilterRequest);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<FilterExtendinfo>, I>>(base?: I): FilterExtendinfo {
    return FilterExtendinfo.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<FilterExtendinfo>, I>>(object: I): FilterExtendinfo {
    const message = createBaseFilterExtendinfo();
    message.uint32FilterFlag = object.uint32FilterFlag ?? undefined;
    message.msgImageFilterRequest =
      (object.msgImageFilterRequest !== undefined && object.msgImageFilterRequest !== null)
        ? ImageFilterRequest.fromPartial(object.msgImageFilterRequest)
        : undefined;
    return message;
  },
};

function createBaseFilterStyle(): FilterStyle {
  return { styleId: undefined, styleName: undefined };
}

export const FilterStyle: MessageFns<FilterStyle> = {
  encode(message: FilterStyle, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.styleId !== undefined) {
      writer.uint32(8).uint32(message.styleId);
    }
    if (message.styleName !== undefined) {
      writer.uint32(18).bytes(message.styleName);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): FilterStyle {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseFilterStyle();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.styleId = reader.uint32();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.styleName = reader.bytes();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): FilterStyle {
    return {
      styleId: isSet(object.styleId) ? globalThis.Number(object.styleId) : undefined,
      styleName: isSet(object.styleName) ? bytesFromBase64(object.styleName) : undefined,
    };
  },

  toJSON(message: FilterStyle): unknown {
    const obj: any = {};
    if (message.styleId !== undefined) {
      obj.styleId = Math.round(message.styleId);
    }
    if (message.styleName !== undefined) {
      obj.styleName = base64FromBytes(message.styleName);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<FilterStyle>, I>>(base?: I): FilterStyle {
    return FilterStyle.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<FilterStyle>, I>>(object: I): FilterStyle {
    const message = createBaseFilterStyle();
    message.styleId = object.styleId ?? undefined;
    message.styleName = object.styleName ?? undefined;
    return message;
  },
};

function createBaseImageFilterRequest(): ImageFilterRequest {
  return {
    sessionId: undefined,
    clientIp: undefined,
    uin: undefined,
    style: undefined,
    width: undefined,
    height: undefined,
    imageData: undefined,
  };
}

export const ImageFilterRequest: MessageFns<ImageFilterRequest> = {
  encode(message: ImageFilterRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.sessionId !== undefined) {
      writer.uint32(10).bytes(message.sessionId);
    }
    if (message.clientIp !== undefined) {
      writer.uint32(16).uint32(message.clientIp);
    }
    if (message.uin !== undefined) {
      writer.uint32(24).uint64(message.uin);
    }
    if (message.style !== undefined) {
      FilterStyle.encode(message.style, writer.uint32(34).fork()).join();
    }
    if (message.width !== undefined) {
      writer.uint32(40).uint32(message.width);
    }
    if (message.height !== undefined) {
      writer.uint32(48).uint32(message.height);
    }
    if (message.imageData !== undefined) {
      writer.uint32(58).bytes(message.imageData);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ImageFilterRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseImageFilterRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.sessionId = reader.bytes();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.clientIp = reader.uint32();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.uin = longToNumber(reader.uint64());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.style = FilterStyle.decode(reader, reader.uint32());
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.width = reader.uint32();
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.height = reader.uint32();
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.imageData = reader.bytes();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ImageFilterRequest {
    return {
      sessionId: isSet(object.sessionId) ? bytesFromBase64(object.sessionId) : undefined,
      clientIp: isSet(object.clientIp) ? globalThis.Number(object.clientIp) : undefined,
      uin: isSet(object.uin) ? globalThis.Number(object.uin) : undefined,
      style: isSet(object.style) ? FilterStyle.fromJSON(object.style) : undefined,
      width: isSet(object.width) ? globalThis.Number(object.width) : undefined,
      height: isSet(object.height) ? globalThis.Number(object.height) : undefined,
      imageData: isSet(object.imageData) ? bytesFromBase64(object.imageData) : undefined,
    };
  },

  toJSON(message: ImageFilterRequest): unknown {
    const obj: any = {};
    if (message.sessionId !== undefined) {
      obj.sessionId = base64FromBytes(message.sessionId);
    }
    if (message.clientIp !== undefined) {
      obj.clientIp = Math.round(message.clientIp);
    }
    if (message.uin !== undefined) {
      obj.uin = Math.round(message.uin);
    }
    if (message.style !== undefined) {
      obj.style = FilterStyle.toJSON(message.style);
    }
    if (message.width !== undefined) {
      obj.width = Math.round(message.width);
    }
    if (message.height !== undefined) {
      obj.height = Math.round(message.height);
    }
    if (message.imageData !== undefined) {
      obj.imageData = base64FromBytes(message.imageData);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ImageFilterRequest>, I>>(base?: I): ImageFilterRequest {
    return ImageFilterRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ImageFilterRequest>, I>>(object: I): ImageFilterRequest {
    const message = createBaseImageFilterRequest();
    message.sessionId = object.sessionId ?? undefined;
    message.clientIp = object.clientIp ?? undefined;
    message.uin = object.uin ?? undefined;
    message.style = (object.style !== undefined && object.style !== null)
      ? FilterStyle.fromPartial(object.style)
      : undefined;
    message.width = object.width ?? undefined;
    message.height = object.height ?? undefined;
    message.imageData = object.imageData ?? undefined;
    return message;
  },
};

function createBaseImageFilterResponse(): ImageFilterResponse {
  return { retCode: undefined, imageData: undefined, costTime: undefined };
}

export const ImageFilterResponse: MessageFns<ImageFilterResponse> = {
  encode(message: ImageFilterResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.retCode !== undefined) {
      writer.uint32(8).int32(message.retCode);
    }
    if (message.imageData !== undefined) {
      writer.uint32(18).bytes(message.imageData);
    }
    if (message.costTime !== undefined) {
      writer.uint32(24).uint32(message.costTime);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ImageFilterResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseImageFilterResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.retCode = reader.int32();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.imageData = reader.bytes();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.costTime = reader.uint32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ImageFilterResponse {
    return {
      retCode: isSet(object.retCode) ? globalThis.Number(object.retCode) : undefined,
      imageData: isSet(object.imageData) ? bytesFromBase64(object.imageData) : undefined,
      costTime: isSet(object.costTime) ? globalThis.Number(object.costTime) : undefined,
    };
  },

  toJSON(message: ImageFilterResponse): unknown {
    const obj: any = {};
    if (message.retCode !== undefined) {
      obj.retCode = Math.round(message.retCode);
    }
    if (message.imageData !== undefined) {
      obj.imageData = base64FromBytes(message.imageData);
    }
    if (message.costTime !== undefined) {
      obj.costTime = Math.round(message.costTime);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ImageFilterResponse>, I>>(base?: I): ImageFilterResponse {
    return ImageFilterResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ImageFilterResponse>, I>>(object: I): ImageFilterResponse {
    const message = createBaseImageFilterResponse();
    message.retCode = object.retCode ?? undefined;
    message.imageData = object.imageData ?? undefined;
    message.costTime = object.costTime ?? undefined;
    return message;
  },
};

function createBaseLoginSigHead(): LoginSigHead {
  return { uint32LoginsigType: undefined, bytesLoginsig: undefined, appid: undefined };
}

export const LoginSigHead: MessageFns<LoginSigHead> = {
  encode(message: LoginSigHead, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.uint32LoginsigType !== undefined) {
      writer.uint32(8).uint32(message.uint32LoginsigType);
    }
    if (message.bytesLoginsig !== undefined) {
      writer.uint32(18).bytes(message.bytesLoginsig);
    }
    if (message.appid !== undefined) {
      writer.uint32(24).uint32(message.appid);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): LoginSigHead {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseLoginSigHead();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.uint32LoginsigType = reader.uint32();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.bytesLoginsig = reader.bytes();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.appid = reader.uint32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): LoginSigHead {
    return {
      uint32LoginsigType: isSet(object.uint32LoginsigType) ? globalThis.Number(object.uint32LoginsigType) : undefined,
      bytesLoginsig: isSet(object.bytesLoginsig) ? bytesFromBase64(object.bytesLoginsig) : undefined,
      appid: isSet(object.appid) ? globalThis.Number(object.appid) : undefined,
    };
  },

  toJSON(message: LoginSigHead): unknown {
    const obj: any = {};
    if (message.uint32LoginsigType !== undefined) {
      obj.uint32LoginsigType = Math.round(message.uint32LoginsigType);
    }
    if (message.bytesLoginsig !== undefined) {
      obj.bytesLoginsig = base64FromBytes(message.bytesLoginsig);
    }
    if (message.appid !== undefined) {
      obj.appid = Math.round(message.appid);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<LoginSigHead>, I>>(base?: I): LoginSigHead {
    return LoginSigHead.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<LoginSigHead>, I>>(object: I): LoginSigHead {
    const message = createBaseLoginSigHead();
    message.uint32LoginsigType = object.uint32LoginsigType ?? undefined;
    message.bytesLoginsig = object.bytesLoginsig ?? undefined;
    message.appid = object.appid ?? undefined;
    return message;
  },
};

function createBaseNewServiceTicket(): NewServiceTicket {
  return { bytesSignature: undefined, bytesUkey: undefined };
}

export const NewServiceTicket: MessageFns<NewServiceTicket> = {
  encode(message: NewServiceTicket, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.bytesSignature !== undefined) {
      writer.uint32(10).bytes(message.bytesSignature);
    }
    if (message.bytesUkey !== undefined) {
      writer.uint32(18).bytes(message.bytesUkey);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): NewServiceTicket {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseNewServiceTicket();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.bytesSignature = reader.bytes();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.bytesUkey = reader.bytes();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): NewServiceTicket {
    return {
      bytesSignature: isSet(object.bytesSignature) ? bytesFromBase64(object.bytesSignature) : undefined,
      bytesUkey: isSet(object.bytesUkey) ? bytesFromBase64(object.bytesUkey) : undefined,
    };
  },

  toJSON(message: NewServiceTicket): unknown {
    const obj: any = {};
    if (message.bytesSignature !== undefined) {
      obj.bytesSignature = base64FromBytes(message.bytesSignature);
    }
    if (message.bytesUkey !== undefined) {
      obj.bytesUkey = base64FromBytes(message.bytesUkey);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<NewServiceTicket>, I>>(base?: I): NewServiceTicket {
    return NewServiceTicket.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<NewServiceTicket>, I>>(object: I): NewServiceTicket {
    const message = createBaseNewServiceTicket();
    message.bytesSignature = object.bytesSignature ?? undefined;
    message.bytesUkey = object.bytesUkey ?? undefined;
    return message;
  },
};

function createBasePicInfoExt(): PicInfoExt {
  return {
    uint32PicWidth: undefined,
    uint32PicHeight: undefined,
    uint32PicFlag: undefined,
    uint32BusiType: undefined,
    uint32SrcTerm: undefined,
    uint32PlatType: undefined,
    uint32NetType: undefined,
    uint32ImgType: undefined,
    uint32AppPicType: undefined,
    bytesEchoCreatedByServer: undefined,
    uint64QqmeetGuildId: undefined,
    uint64QqmeetChannelId: undefined,
  };
}

export const PicInfoExt: MessageFns<PicInfoExt> = {
  encode(message: PicInfoExt, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.uint32PicWidth !== undefined) {
      writer.uint32(8).uint32(message.uint32PicWidth);
    }
    if (message.uint32PicHeight !== undefined) {
      writer.uint32(16).uint32(message.uint32PicHeight);
    }
    if (message.uint32PicFlag !== undefined) {
      writer.uint32(24).uint32(message.uint32PicFlag);
    }
    if (message.uint32BusiType !== undefined) {
      writer.uint32(32).uint32(message.uint32BusiType);
    }
    if (message.uint32SrcTerm !== undefined) {
      writer.uint32(40).uint32(message.uint32SrcTerm);
    }
    if (message.uint32PlatType !== undefined) {
      writer.uint32(48).uint32(message.uint32PlatType);
    }
    if (message.uint32NetType !== undefined) {
      writer.uint32(56).uint32(message.uint32NetType);
    }
    if (message.uint32ImgType !== undefined) {
      writer.uint32(64).uint32(message.uint32ImgType);
    }
    if (message.uint32AppPicType !== undefined) {
      writer.uint32(72).uint32(message.uint32AppPicType);
    }
    if (message.bytesEchoCreatedByServer !== undefined) {
      writer.uint32(82).bytes(message.bytesEchoCreatedByServer);
    }
    if (message.uint64QqmeetGuildId !== undefined) {
      writer.uint32(88).uint64(message.uint64QqmeetGuildId);
    }
    if (message.uint64QqmeetChannelId !== undefined) {
      writer.uint32(96).uint64(message.uint64QqmeetChannelId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PicInfoExt {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePicInfoExt();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.uint32PicWidth = reader.uint32();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.uint32PicHeight = reader.uint32();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.uint32PicFlag = reader.uint32();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.uint32BusiType = reader.uint32();
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.uint32SrcTerm = reader.uint32();
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.uint32PlatType = reader.uint32();
          continue;
        }
        case 7: {
          if (tag !== 56) {
            break;
          }

          message.uint32NetType = reader.uint32();
          continue;
        }
        case 8: {
          if (tag !== 64) {
            break;
          }

          message.uint32ImgType = reader.uint32();
          continue;
        }
        case 9: {
          if (tag !== 72) {
            break;
          }

          message.uint32AppPicType = reader.uint32();
          continue;
        }
        case 10: {
          if (tag !== 82) {
            break;
          }

          message.bytesEchoCreatedByServer = reader.bytes();
          continue;
        }
        case 11: {
          if (tag !== 88) {
            break;
          }

          message.uint64QqmeetGuildId = longToNumber(reader.uint64());
          continue;
        }
        case 12: {
          if (tag !== 96) {
            break;
          }

          message.uint64QqmeetChannelId = longToNumber(reader.uint64());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PicInfoExt {
    return {
      uint32PicWidth: isSet(object.uint32PicWidth) ? globalThis.Number(object.uint32PicWidth) : undefined,
      uint32PicHeight: isSet(object.uint32PicHeight) ? globalThis.Number(object.uint32PicHeight) : undefined,
      uint32PicFlag: isSet(object.uint32PicFlag) ? globalThis.Number(object.uint32PicFlag) : undefined,
      uint32BusiType: isSet(object.uint32BusiType) ? globalThis.Number(object.uint32BusiType) : undefined,
      uint32SrcTerm: isSet(object.uint32SrcTerm) ? globalThis.Number(object.uint32SrcTerm) : undefined,
      uint32PlatType: isSet(object.uint32PlatType) ? globalThis.Number(object.uint32PlatType) : undefined,
      uint32NetType: isSet(object.uint32NetType) ? globalThis.Number(object.uint32NetType) : undefined,
      uint32ImgType: isSet(object.uint32ImgType) ? globalThis.Number(object.uint32ImgType) : undefined,
      uint32AppPicType: isSet(object.uint32AppPicType) ? globalThis.Number(object.uint32AppPicType) : undefined,
      bytesEchoCreatedByServer: isSet(object.bytesEchoCreatedByServer)
        ? bytesFromBase64(object.bytesEchoCreatedByServer)
        : undefined,
      uint64QqmeetGuildId: isSet(object.uint64QqmeetGuildId)
        ? globalThis.Number(object.uint64QqmeetGuildId)
        : undefined,
      uint64QqmeetChannelId: isSet(object.uint64QqmeetChannelId)
        ? globalThis.Number(object.uint64QqmeetChannelId)
        : undefined,
    };
  },

  toJSON(message: PicInfoExt): unknown {
    const obj: any = {};
    if (message.uint32PicWidth !== undefined) {
      obj.uint32PicWidth = Math.round(message.uint32PicWidth);
    }
    if (message.uint32PicHeight !== undefined) {
      obj.uint32PicHeight = Math.round(message.uint32PicHeight);
    }
    if (message.uint32PicFlag !== undefined) {
      obj.uint32PicFlag = Math.round(message.uint32PicFlag);
    }
    if (message.uint32BusiType !== undefined) {
      obj.uint32BusiType = Math.round(message.uint32BusiType);
    }
    if (message.uint32SrcTerm !== undefined) {
      obj.uint32SrcTerm = Math.round(message.uint32SrcTerm);
    }
    if (message.uint32PlatType !== undefined) {
      obj.uint32PlatType = Math.round(message.uint32PlatType);
    }
    if (message.uint32NetType !== undefined) {
      obj.uint32NetType = Math.round(message.uint32NetType);
    }
    if (message.uint32ImgType !== undefined) {
      obj.uint32ImgType = Math.round(message.uint32ImgType);
    }
    if (message.uint32AppPicType !== undefined) {
      obj.uint32AppPicType = Math.round(message.uint32AppPicType);
    }
    if (message.bytesEchoCreatedByServer !== undefined) {
      obj.bytesEchoCreatedByServer = base64FromBytes(message.bytesEchoCreatedByServer);
    }
    if (message.uint64QqmeetGuildId !== undefined) {
      obj.uint64QqmeetGuildId = Math.round(message.uint64QqmeetGuildId);
    }
    if (message.uint64QqmeetChannelId !== undefined) {
      obj.uint64QqmeetChannelId = Math.round(message.uint64QqmeetChannelId);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<PicInfoExt>, I>>(base?: I): PicInfoExt {
    return PicInfoExt.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<PicInfoExt>, I>>(object: I): PicInfoExt {
    const message = createBasePicInfoExt();
    message.uint32PicWidth = object.uint32PicWidth ?? undefined;
    message.uint32PicHeight = object.uint32PicHeight ?? undefined;
    message.uint32PicFlag = object.uint32PicFlag ?? undefined;
    message.uint32BusiType = object.uint32BusiType ?? undefined;
    message.uint32SrcTerm = object.uint32SrcTerm ?? undefined;
    message.uint32PlatType = object.uint32PlatType ?? undefined;
    message.uint32NetType = object.uint32NetType ?? undefined;
    message.uint32ImgType = object.uint32ImgType ?? undefined;
    message.uint32AppPicType = object.uint32AppPicType ?? undefined;
    message.bytesEchoCreatedByServer = object.bytesEchoCreatedByServer ?? undefined;
    message.uint64QqmeetGuildId = object.uint64QqmeetGuildId ?? undefined;
    message.uint64QqmeetChannelId = object.uint64QqmeetChannelId ?? undefined;
    return message;
  },
};

function createBasePicRspExtInfo(): PicRspExtInfo {
  return { bytesSkey: undefined, uint32ClientIp: undefined, uint64UpOffset: undefined, uint64BlockSize: undefined };
}

export const PicRspExtInfo: MessageFns<PicRspExtInfo> = {
  encode(message: PicRspExtInfo, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.bytesSkey !== undefined) {
      writer.uint32(10).bytes(message.bytesSkey);
    }
    if (message.uint32ClientIp !== undefined) {
      writer.uint32(16).uint32(message.uint32ClientIp);
    }
    if (message.uint64UpOffset !== undefined) {
      writer.uint32(24).uint64(message.uint64UpOffset);
    }
    if (message.uint64BlockSize !== undefined) {
      writer.uint32(32).uint64(message.uint64BlockSize);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PicRspExtInfo {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePicRspExtInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.bytesSkey = reader.bytes();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.uint32ClientIp = reader.uint32();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.uint64UpOffset = longToNumber(reader.uint64());
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.uint64BlockSize = longToNumber(reader.uint64());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PicRspExtInfo {
    return {
      bytesSkey: isSet(object.bytesSkey) ? bytesFromBase64(object.bytesSkey) : undefined,
      uint32ClientIp: isSet(object.uint32ClientIp) ? globalThis.Number(object.uint32ClientIp) : undefined,
      uint64UpOffset: isSet(object.uint64UpOffset) ? globalThis.Number(object.uint64UpOffset) : undefined,
      uint64BlockSize: isSet(object.uint64BlockSize) ? globalThis.Number(object.uint64BlockSize) : undefined,
    };
  },

  toJSON(message: PicRspExtInfo): unknown {
    const obj: any = {};
    if (message.bytesSkey !== undefined) {
      obj.bytesSkey = base64FromBytes(message.bytesSkey);
    }
    if (message.uint32ClientIp !== undefined) {
      obj.uint32ClientIp = Math.round(message.uint32ClientIp);
    }
    if (message.uint64UpOffset !== undefined) {
      obj.uint64UpOffset = Math.round(message.uint64UpOffset);
    }
    if (message.uint64BlockSize !== undefined) {
      obj.uint64BlockSize = Math.round(message.uint64BlockSize);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<PicRspExtInfo>, I>>(base?: I): PicRspExtInfo {
    return PicRspExtInfo.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<PicRspExtInfo>, I>>(object: I): PicRspExtInfo {
    const message = createBasePicRspExtInfo();
    message.bytesSkey = object.bytesSkey ?? undefined;
    message.uint32ClientIp = object.uint32ClientIp ?? undefined;
    message.uint64UpOffset = object.uint64UpOffset ?? undefined;
    message.uint64BlockSize = object.uint64BlockSize ?? undefined;
    return message;
  },
};

function createBaseQueryHoleRsp(): QueryHoleRsp {
  return { uint32Result: undefined, rptDataHole: [], boolCompFlag: undefined };
}

export const QueryHoleRsp: MessageFns<QueryHoleRsp> = {
  encode(message: QueryHoleRsp, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.uint32Result !== undefined) {
      writer.uint32(8).uint32(message.uint32Result);
    }
    for (const v of message.rptDataHole) {
      DataHole.encode(v!, writer.uint32(18).fork()).join();
    }
    if (message.boolCompFlag !== undefined) {
      writer.uint32(24).bool(message.boolCompFlag);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): QueryHoleRsp {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryHoleRsp();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.uint32Result = reader.uint32();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.rptDataHole.push(DataHole.decode(reader, reader.uint32()));
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.boolCompFlag = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): QueryHoleRsp {
    return {
      uint32Result: isSet(object.uint32Result) ? globalThis.Number(object.uint32Result) : undefined,
      rptDataHole: globalThis.Array.isArray(object?.rptDataHole)
        ? object.rptDataHole.map((e: any) => DataHole.fromJSON(e))
        : [],
      boolCompFlag: isSet(object.boolCompFlag) ? globalThis.Boolean(object.boolCompFlag) : undefined,
    };
  },

  toJSON(message: QueryHoleRsp): unknown {
    const obj: any = {};
    if (message.uint32Result !== undefined) {
      obj.uint32Result = Math.round(message.uint32Result);
    }
    if (message.rptDataHole?.length) {
      obj.rptDataHole = message.rptDataHole.map((e) => DataHole.toJSON(e));
    }
    if (message.boolCompFlag !== undefined) {
      obj.boolCompFlag = message.boolCompFlag;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<QueryHoleRsp>, I>>(base?: I): QueryHoleRsp {
    return QueryHoleRsp.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<QueryHoleRsp>, I>>(object: I): QueryHoleRsp {
    const message = createBaseQueryHoleRsp();
    message.uint32Result = object.uint32Result ?? undefined;
    message.rptDataHole = object.rptDataHole?.map((e) => DataHole.fromPartial(e)) || [];
    message.boolCompFlag = object.boolCompFlag ?? undefined;
    return message;
  },
};

function createBaseReqDataHighwayHead(): ReqDataHighwayHead {
  return {
    msgBasehead: undefined,
    msgSeghead: undefined,
    bytesReqExtendinfo: undefined,
    uint64Timestamp: undefined,
    msgLoginSigHead: undefined,
  };
}

export const ReqDataHighwayHead: MessageFns<ReqDataHighwayHead> = {
  encode(message: ReqDataHighwayHead, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.msgBasehead !== undefined) {
      DataHighwayHead.encode(message.msgBasehead, writer.uint32(10).fork()).join();
    }
    if (message.msgSeghead !== undefined) {
      SegHead.encode(message.msgSeghead, writer.uint32(18).fork()).join();
    }
    if (message.bytesReqExtendinfo !== undefined) {
      writer.uint32(26).bytes(message.bytesReqExtendinfo);
    }
    if (message.uint64Timestamp !== undefined) {
      writer.uint32(32).uint64(message.uint64Timestamp);
    }
    if (message.msgLoginSigHead !== undefined) {
      LoginSigHead.encode(message.msgLoginSigHead, writer.uint32(42).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ReqDataHighwayHead {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseReqDataHighwayHead();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.msgBasehead = DataHighwayHead.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.msgSeghead = SegHead.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.bytesReqExtendinfo = reader.bytes();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.uint64Timestamp = longToNumber(reader.uint64());
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.msgLoginSigHead = LoginSigHead.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ReqDataHighwayHead {
    return {
      msgBasehead: isSet(object.msgBasehead) ? DataHighwayHead.fromJSON(object.msgBasehead) : undefined,
      msgSeghead: isSet(object.msgSeghead) ? SegHead.fromJSON(object.msgSeghead) : undefined,
      bytesReqExtendinfo: isSet(object.bytesReqExtendinfo) ? bytesFromBase64(object.bytesReqExtendinfo) : undefined,
      uint64Timestamp: isSet(object.uint64Timestamp) ? globalThis.Number(object.uint64Timestamp) : undefined,
      msgLoginSigHead: isSet(object.msgLoginSigHead) ? LoginSigHead.fromJSON(object.msgLoginSigHead) : undefined,
    };
  },

  toJSON(message: ReqDataHighwayHead): unknown {
    const obj: any = {};
    if (message.msgBasehead !== undefined) {
      obj.msgBasehead = DataHighwayHead.toJSON(message.msgBasehead);
    }
    if (message.msgSeghead !== undefined) {
      obj.msgSeghead = SegHead.toJSON(message.msgSeghead);
    }
    if (message.bytesReqExtendinfo !== undefined) {
      obj.bytesReqExtendinfo = base64FromBytes(message.bytesReqExtendinfo);
    }
    if (message.uint64Timestamp !== undefined) {
      obj.uint64Timestamp = Math.round(message.uint64Timestamp);
    }
    if (message.msgLoginSigHead !== undefined) {
      obj.msgLoginSigHead = LoginSigHead.toJSON(message.msgLoginSigHead);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ReqDataHighwayHead>, I>>(base?: I): ReqDataHighwayHead {
    return ReqDataHighwayHead.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ReqDataHighwayHead>, I>>(object: I): ReqDataHighwayHead {
    const message = createBaseReqDataHighwayHead();
    message.msgBasehead = (object.msgBasehead !== undefined && object.msgBasehead !== null)
      ? DataHighwayHead.fromPartial(object.msgBasehead)
      : undefined;
    message.msgSeghead = (object.msgSeghead !== undefined && object.msgSeghead !== null)
      ? SegHead.fromPartial(object.msgSeghead)
      : undefined;
    message.bytesReqExtendinfo = object.bytesReqExtendinfo ?? undefined;
    message.uint64Timestamp = object.uint64Timestamp ?? undefined;
    message.msgLoginSigHead = (object.msgLoginSigHead !== undefined && object.msgLoginSigHead !== null)
      ? LoginSigHead.fromPartial(object.msgLoginSigHead)
      : undefined;
    return message;
  },
};

function createBaseRspBody(): RspBody {
  return { msgQueryHoleRsp: undefined };
}

export const RspBody: MessageFns<RspBody> = {
  encode(message: RspBody, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.msgQueryHoleRsp !== undefined) {
      QueryHoleRsp.encode(message.msgQueryHoleRsp, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RspBody {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRspBody();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.msgQueryHoleRsp = QueryHoleRsp.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RspBody {
    return {
      msgQueryHoleRsp: isSet(object.msgQueryHoleRsp) ? QueryHoleRsp.fromJSON(object.msgQueryHoleRsp) : undefined,
    };
  },

  toJSON(message: RspBody): unknown {
    const obj: any = {};
    if (message.msgQueryHoleRsp !== undefined) {
      obj.msgQueryHoleRsp = QueryHoleRsp.toJSON(message.msgQueryHoleRsp);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<RspBody>, I>>(base?: I): RspBody {
    return RspBody.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<RspBody>, I>>(object: I): RspBody {
    const message = createBaseRspBody();
    message.msgQueryHoleRsp = (object.msgQueryHoleRsp !== undefined && object.msgQueryHoleRsp !== null)
      ? QueryHoleRsp.fromPartial(object.msgQueryHoleRsp)
      : undefined;
    return message;
  },
};

function createBaseRspDataHighwayHead(): RspDataHighwayHead {
  return {
    msgBasehead: undefined,
    msgSeghead: undefined,
    uint32ErrorCode: undefined,
    uint32AllowRetry: undefined,
    uint32Cachecost: undefined,
    uint32Htcost: undefined,
    bytesRspExtendinfo: undefined,
    uint64Timestamp: undefined,
    uint64Range: undefined,
    uint32IsReset: undefined,
  };
}

export const RspDataHighwayHead: MessageFns<RspDataHighwayHead> = {
  encode(message: RspDataHighwayHead, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.msgBasehead !== undefined) {
      DataHighwayHead.encode(message.msgBasehead, writer.uint32(10).fork()).join();
    }
    if (message.msgSeghead !== undefined) {
      SegHead.encode(message.msgSeghead, writer.uint32(18).fork()).join();
    }
    if (message.uint32ErrorCode !== undefined) {
      writer.uint32(24).uint32(message.uint32ErrorCode);
    }
    if (message.uint32AllowRetry !== undefined) {
      writer.uint32(32).uint32(message.uint32AllowRetry);
    }
    if (message.uint32Cachecost !== undefined) {
      writer.uint32(40).uint32(message.uint32Cachecost);
    }
    if (message.uint32Htcost !== undefined) {
      writer.uint32(48).uint32(message.uint32Htcost);
    }
    if (message.bytesRspExtendinfo !== undefined) {
      writer.uint32(58).bytes(message.bytesRspExtendinfo);
    }
    if (message.uint64Timestamp !== undefined) {
      writer.uint32(64).uint64(message.uint64Timestamp);
    }
    if (message.uint64Range !== undefined) {
      writer.uint32(72).uint64(message.uint64Range);
    }
    if (message.uint32IsReset !== undefined) {
      writer.uint32(80).uint32(message.uint32IsReset);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RspDataHighwayHead {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRspDataHighwayHead();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.msgBasehead = DataHighwayHead.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.msgSeghead = SegHead.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.uint32ErrorCode = reader.uint32();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.uint32AllowRetry = reader.uint32();
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.uint32Cachecost = reader.uint32();
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.uint32Htcost = reader.uint32();
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.bytesRspExtendinfo = reader.bytes();
          continue;
        }
        case 8: {
          if (tag !== 64) {
            break;
          }

          message.uint64Timestamp = longToNumber(reader.uint64());
          continue;
        }
        case 9: {
          if (tag !== 72) {
            break;
          }

          message.uint64Range = longToNumber(reader.uint64());
          continue;
        }
        case 10: {
          if (tag !== 80) {
            break;
          }

          message.uint32IsReset = reader.uint32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RspDataHighwayHead {
    return {
      msgBasehead: isSet(object.msgBasehead) ? DataHighwayHead.fromJSON(object.msgBasehead) : undefined,
      msgSeghead: isSet(object.msgSeghead) ? SegHead.fromJSON(object.msgSeghead) : undefined,
      uint32ErrorCode: isSet(object.uint32ErrorCode) ? globalThis.Number(object.uint32ErrorCode) : undefined,
      uint32AllowRetry: isSet(object.uint32AllowRetry) ? globalThis.Number(object.uint32AllowRetry) : undefined,
      uint32Cachecost: isSet(object.uint32Cachecost) ? globalThis.Number(object.uint32Cachecost) : undefined,
      uint32Htcost: isSet(object.uint32Htcost) ? globalThis.Number(object.uint32Htcost) : undefined,
      bytesRspExtendinfo: isSet(object.bytesRspExtendinfo) ? bytesFromBase64(object.bytesRspExtendinfo) : undefined,
      uint64Timestamp: isSet(object.uint64Timestamp) ? globalThis.Number(object.uint64Timestamp) : undefined,
      uint64Range: isSet(object.uint64Range) ? globalThis.Number(object.uint64Range) : undefined,
      uint32IsReset: isSet(object.uint32IsReset) ? globalThis.Number(object.uint32IsReset) : undefined,
    };
  },

  toJSON(message: RspDataHighwayHead): unknown {
    const obj: any = {};
    if (message.msgBasehead !== undefined) {
      obj.msgBasehead = DataHighwayHead.toJSON(message.msgBasehead);
    }
    if (message.msgSeghead !== undefined) {
      obj.msgSeghead = SegHead.toJSON(message.msgSeghead);
    }
    if (message.uint32ErrorCode !== undefined) {
      obj.uint32ErrorCode = Math.round(message.uint32ErrorCode);
    }
    if (message.uint32AllowRetry !== undefined) {
      obj.uint32AllowRetry = Math.round(message.uint32AllowRetry);
    }
    if (message.uint32Cachecost !== undefined) {
      obj.uint32Cachecost = Math.round(message.uint32Cachecost);
    }
    if (message.uint32Htcost !== undefined) {
      obj.uint32Htcost = Math.round(message.uint32Htcost);
    }
    if (message.bytesRspExtendinfo !== undefined) {
      obj.bytesRspExtendinfo = base64FromBytes(message.bytesRspExtendinfo);
    }
    if (message.uint64Timestamp !== undefined) {
      obj.uint64Timestamp = Math.round(message.uint64Timestamp);
    }
    if (message.uint64Range !== undefined) {
      obj.uint64Range = Math.round(message.uint64Range);
    }
    if (message.uint32IsReset !== undefined) {
      obj.uint32IsReset = Math.round(message.uint32IsReset);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<RspDataHighwayHead>, I>>(base?: I): RspDataHighwayHead {
    return RspDataHighwayHead.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<RspDataHighwayHead>, I>>(object: I): RspDataHighwayHead {
    const message = createBaseRspDataHighwayHead();
    message.msgBasehead = (object.msgBasehead !== undefined && object.msgBasehead !== null)
      ? DataHighwayHead.fromPartial(object.msgBasehead)
      : undefined;
    message.msgSeghead = (object.msgSeghead !== undefined && object.msgSeghead !== null)
      ? SegHead.fromPartial(object.msgSeghead)
      : undefined;
    message.uint32ErrorCode = object.uint32ErrorCode ?? undefined;
    message.uint32AllowRetry = object.uint32AllowRetry ?? undefined;
    message.uint32Cachecost = object.uint32Cachecost ?? undefined;
    message.uint32Htcost = object.uint32Htcost ?? undefined;
    message.bytesRspExtendinfo = object.bytesRspExtendinfo ?? undefined;
    message.uint64Timestamp = object.uint64Timestamp ?? undefined;
    message.uint64Range = object.uint64Range ?? undefined;
    message.uint32IsReset = object.uint32IsReset ?? undefined;
    return message;
  },
};

function createBaseSegHead(): SegHead {
  return {
    uint32Serviceid: undefined,
    uint64Filesize: undefined,
    uint64Dataoffset: undefined,
    uint32Datalength: undefined,
    uint32Rtcode: undefined,
    bytesServiceticket: undefined,
    uint32Flag: undefined,
    bytesMd5: undefined,
    bytesFileMd5: undefined,
    uint32CacheAddr: undefined,
    uint32QueryTimes: undefined,
    uint32UpdateCacheip: undefined,
    uint32CachePort: undefined,
  };
}

export const SegHead: MessageFns<SegHead> = {
  encode(message: SegHead, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.uint32Serviceid !== undefined) {
      writer.uint32(8).uint32(message.uint32Serviceid);
    }
    if (message.uint64Filesize !== undefined) {
      writer.uint32(16).uint64(message.uint64Filesize);
    }
    if (message.uint64Dataoffset !== undefined) {
      writer.uint32(24).uint64(message.uint64Dataoffset);
    }
    if (message.uint32Datalength !== undefined) {
      writer.uint32(32).uint32(message.uint32Datalength);
    }
    if (message.uint32Rtcode !== undefined) {
      writer.uint32(40).uint32(message.uint32Rtcode);
    }
    if (message.bytesServiceticket !== undefined) {
      writer.uint32(50).bytes(message.bytesServiceticket);
    }
    if (message.uint32Flag !== undefined) {
      writer.uint32(56).uint32(message.uint32Flag);
    }
    if (message.bytesMd5 !== undefined) {
      writer.uint32(66).bytes(message.bytesMd5);
    }
    if (message.bytesFileMd5 !== undefined) {
      writer.uint32(74).bytes(message.bytesFileMd5);
    }
    if (message.uint32CacheAddr !== undefined) {
      writer.uint32(80).uint32(message.uint32CacheAddr);
    }
    if (message.uint32QueryTimes !== undefined) {
      writer.uint32(88).uint32(message.uint32QueryTimes);
    }
    if (message.uint32UpdateCacheip !== undefined) {
      writer.uint32(96).uint32(message.uint32UpdateCacheip);
    }
    if (message.uint32CachePort !== undefined) {
      writer.uint32(104).uint32(message.uint32CachePort);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SegHead {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSegHead();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.uint32Serviceid = reader.uint32();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.uint64Filesize = longToNumber(reader.uint64());
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.uint64Dataoffset = longToNumber(reader.uint64());
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.uint32Datalength = reader.uint32();
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.uint32Rtcode = reader.uint32();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.bytesServiceticket = reader.bytes();
          continue;
        }
        case 7: {
          if (tag !== 56) {
            break;
          }

          message.uint32Flag = reader.uint32();
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.bytesMd5 = reader.bytes();
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.bytesFileMd5 = reader.bytes();
          continue;
        }
        case 10: {
          if (tag !== 80) {
            break;
          }

          message.uint32CacheAddr = reader.uint32();
          continue;
        }
        case 11: {
          if (tag !== 88) {
            break;
          }

          message.uint32QueryTimes = reader.uint32();
          continue;
        }
        case 12: {
          if (tag !== 96) {
            break;
          }

          message.uint32UpdateCacheip = reader.uint32();
          continue;
        }
        case 13: {
          if (tag !== 104) {
            break;
          }

          message.uint32CachePort = reader.uint32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SegHead {
    return {
      uint32Serviceid: isSet(object.uint32Serviceid) ? globalThis.Number(object.uint32Serviceid) : undefined,
      uint64Filesize: isSet(object.uint64Filesize) ? globalThis.Number(object.uint64Filesize) : undefined,
      uint64Dataoffset: isSet(object.uint64Dataoffset) ? globalThis.Number(object.uint64Dataoffset) : undefined,
      uint32Datalength: isSet(object.uint32Datalength) ? globalThis.Number(object.uint32Datalength) : undefined,
      uint32Rtcode: isSet(object.uint32Rtcode) ? globalThis.Number(object.uint32Rtcode) : undefined,
      bytesServiceticket: isSet(object.bytesServiceticket) ? bytesFromBase64(object.bytesServiceticket) : undefined,
      uint32Flag: isSet(object.uint32Flag) ? globalThis.Number(object.uint32Flag) : undefined,
      bytesMd5: isSet(object.bytesMd5) ? bytesFromBase64(object.bytesMd5) : undefined,
      bytesFileMd5: isSet(object.bytesFileMd5) ? bytesFromBase64(object.bytesFileMd5) : undefined,
      uint32CacheAddr: isSet(object.uint32CacheAddr) ? globalThis.Number(object.uint32CacheAddr) : undefined,
      uint32QueryTimes: isSet(object.uint32QueryTimes) ? globalThis.Number(object.uint32QueryTimes) : undefined,
      uint32UpdateCacheip: isSet(object.uint32UpdateCacheip)
        ? globalThis.Number(object.uint32UpdateCacheip)
        : undefined,
      uint32CachePort: isSet(object.uint32CachePort) ? globalThis.Number(object.uint32CachePort) : undefined,
    };
  },

  toJSON(message: SegHead): unknown {
    const obj: any = {};
    if (message.uint32Serviceid !== undefined) {
      obj.uint32Serviceid = Math.round(message.uint32Serviceid);
    }
    if (message.uint64Filesize !== undefined) {
      obj.uint64Filesize = Math.round(message.uint64Filesize);
    }
    if (message.uint64Dataoffset !== undefined) {
      obj.uint64Dataoffset = Math.round(message.uint64Dataoffset);
    }
    if (message.uint32Datalength !== undefined) {
      obj.uint32Datalength = Math.round(message.uint32Datalength);
    }
    if (message.uint32Rtcode !== undefined) {
      obj.uint32Rtcode = Math.round(message.uint32Rtcode);
    }
    if (message.bytesServiceticket !== undefined) {
      obj.bytesServiceticket = base64FromBytes(message.bytesServiceticket);
    }
    if (message.uint32Flag !== undefined) {
      obj.uint32Flag = Math.round(message.uint32Flag);
    }
    if (message.bytesMd5 !== undefined) {
      obj.bytesMd5 = base64FromBytes(message.bytesMd5);
    }
    if (message.bytesFileMd5 !== undefined) {
      obj.bytesFileMd5 = base64FromBytes(message.bytesFileMd5);
    }
    if (message.uint32CacheAddr !== undefined) {
      obj.uint32CacheAddr = Math.round(message.uint32CacheAddr);
    }
    if (message.uint32QueryTimes !== undefined) {
      obj.uint32QueryTimes = Math.round(message.uint32QueryTimes);
    }
    if (message.uint32UpdateCacheip !== undefined) {
      obj.uint32UpdateCacheip = Math.round(message.uint32UpdateCacheip);
    }
    if (message.uint32CachePort !== undefined) {
      obj.uint32CachePort = Math.round(message.uint32CachePort);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<SegHead>, I>>(base?: I): SegHead {
    return SegHead.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SegHead>, I>>(object: I): SegHead {
    const message = createBaseSegHead();
    message.uint32Serviceid = object.uint32Serviceid ?? undefined;
    message.uint64Filesize = object.uint64Filesize ?? undefined;
    message.uint64Dataoffset = object.uint64Dataoffset ?? undefined;
    message.uint32Datalength = object.uint32Datalength ?? undefined;
    message.uint32Rtcode = object.uint32Rtcode ?? undefined;
    message.bytesServiceticket = object.bytesServiceticket ?? undefined;
    message.uint32Flag = object.uint32Flag ?? undefined;
    message.bytesMd5 = object.bytesMd5 ?? undefined;
    message.bytesFileMd5 = object.bytesFileMd5 ?? undefined;
    message.uint32CacheAddr = object.uint32CacheAddr ?? undefined;
    message.uint32QueryTimes = object.uint32QueryTimes ?? undefined;
    message.uint32UpdateCacheip = object.uint32UpdateCacheip ?? undefined;
    message.uint32CachePort = object.uint32CachePort ?? undefined;
    return message;
  },
};

function bytesFromBase64(b64: string): Uint8Array {
  if ((globalThis as any).Buffer) {
    return Uint8Array.from(globalThis.Buffer.from(b64, "base64"));
  } else {
    const bin = globalThis.atob(b64);
    const arr = new Uint8Array(bin.length);
    for (let i = 0; i < bin.length; ++i) {
      arr[i] = bin.charCodeAt(i);
    }
    return arr;
  }
}

function base64FromBytes(arr: Uint8Array): string {
  if ((globalThis as any).Buffer) {
    return globalThis.Buffer.from(arr).toString("base64");
  } else {
    const bin: string[] = [];
    arr.forEach((byte) => {
      bin.push(globalThis.String.fromCharCode(byte));
    });
    return globalThis.btoa(bin.join(""));
  }
}

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

type KeysOfUnion<T> = T extends T ? keyof T : never;
export type Exact<P, I extends P> = P extends Builtin ? P
  : P & { [K in keyof P]: Exact<P[K], I[K]> } & { [K in Exclude<keyof I, KeysOfUnion<P>>]: never };

function longToNumber(int64: { toString(): string }): number {
  const num = globalThis.Number(int64.toString());
  if (num > globalThis.Number.MAX_SAFE_INTEGER) {
    throw new globalThis.Error("Value is larger than Number.MAX_SAFE_INTEGER");
  }
  if (num < globalThis.Number.MIN_SAFE_INTEGER) {
    throw new globalThis.Error("Value is smaller than Number.MIN_SAFE_INTEGER");
  }
  return num;
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create<I extends Exact<DeepPartial<T>, I>>(base?: I): T;
  fromPartial<I extends Exact<DeepPartial<T>, I>>(object: I): T;
}
