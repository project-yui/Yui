// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.2.5
//   protoc               v6.32.1
// source: src/ntqq/protobuf/multimsg.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";

export const protobufPackage = "nt.communication";

/** https://github.com/tsuzcx/qq_apk/blob/afe46ef5640d0ba6850cdefd3c11badbd725a3f6/com.tencent.mobileqq/classes.jar/tencent/im/longconn/multimsg/MultiMsg%24ReqBody.java#L11 */
export interface MultiMsgReqBody {
  /** 设置1 */
  uint32Subcmd: number;
  /** 设置5 */
  uint32TermType: number;
  /** 设置9 */
  uint32PlatformType: number;
  uint32NetType: number;
  bytesBuildVer: Uint8Array;
  rptMultimsgApplyupReq: MultiMsgApplyUpReq[];
  rptMultimsgApplydownReq: MultiMsgApplyDownReq[];
  uint32BuType: number;
  uint32ReqChannelType: number;
}

/** https://github.com/tsuzcx/qq_apk/blob/afe46ef5640d0ba6850cdefd3c11badbd725a3f6/com.tencent.mobileqq/classes.jar/com/tencent/mobileqq/transfile/protohandler/MultiMsgUpHandler.java#L38 */
export interface MultiMsgApplyUpReq {
  uint64DstUin: number;
  uint64MsgSize: number;
  bytesMsgMd5: Uint8Array;
  uint32MsgType: number;
  /** 设置0 */
  uint32ApplyId: number;
}

export interface MultiMsgApplyDownReq {
  bytesMsgResid: Uint8Array;
  uint32MsgType: number;
  uint64SrcUin: number;
  uint32ApplyId: number;
  bytesMsgKey: Uint8Array;
  bytesMsgSig: Uint8Array;
  rptIpV4Info: Ipv4Info[];
  rptIpV6Info: Ipv6Info[];
}

export interface Ipv4Info {
  uint32IpV4Addr: number;
  uint32IpV4Port: number;
  uint32IsHttpsAddr: number;
}

export interface Ipv6Info {
  bytesIpV6Addr: Uint8Array;
  uint32IpV6Port: number;
  uint32IsHttpsAddr: number;
}

/** /////////////////////////////////////////// */
export interface MultiMsgRsqBody {
  uint32Subcmd: number;
  rptMultimsgApplyupRsp: MultiMsgApplyUpRsq[];
  rptMultimsgApplydownRsp: MultiMsgApplyDownRsq[];
}

export interface MultiMsgApplyUpRsq {
  uint32Result: number;
  bytesMsgResid: Uint8Array;
  bytesMsgUkey: Uint8Array;
  rptUint32UpIp: number[];
  rptUint32UpPort: number[];
  uint64BlockSize: number;
  uint64UpOffset: number;
  uint32ApplyId: number;
  bytesMsgKey: Uint8Array;
  bytesMsgSig: Uint8Array;
  msgExternInfo: Uint8Array;
  rptBytesUpIpV6: Uint8Array[];
  rptUint32UpV6Port: number[];
}

export interface MultiMsgApplyDownRsq {
  uint32Result: number;
  bytesThumbDownPara: Uint8Array;
  bytesMsgKey: Uint8Array;
  rptUint32DownIp: number[];
  rptUint32DownPort: number[];
  bytesMsgResid: Uint8Array;
  msgExternInfo: MultiMsgExternMsg | undefined;
  rptBytesDownIpV6: Uint8Array[];
  rptUint32DownV6Port: number[];
  uint32ApplyId: number;
}

export interface MultiMsgExternMsg {
  uint32ChannelType: number;
}

function createBaseMultiMsgReqBody(): MultiMsgReqBody {
  return {
    uint32Subcmd: 0,
    uint32TermType: 0,
    uint32PlatformType: 0,
    uint32NetType: 0,
    bytesBuildVer: new Uint8Array(0),
    rptMultimsgApplyupReq: [],
    rptMultimsgApplydownReq: [],
    uint32BuType: 0,
    uint32ReqChannelType: 0,
  };
}

export const MultiMsgReqBody: MessageFns<MultiMsgReqBody> = {
  encode(message: MultiMsgReqBody, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.uint32Subcmd !== 0) {
      writer.uint32(8).uint32(message.uint32Subcmd);
    }
    if (message.uint32TermType !== 0) {
      writer.uint32(16).uint32(message.uint32TermType);
    }
    if (message.uint32PlatformType !== 0) {
      writer.uint32(24).uint32(message.uint32PlatformType);
    }
    if (message.uint32NetType !== 0) {
      writer.uint32(32).uint32(message.uint32NetType);
    }
    if (message.bytesBuildVer.length !== 0) {
      writer.uint32(42).bytes(message.bytesBuildVer);
    }
    for (const v of message.rptMultimsgApplyupReq) {
      MultiMsgApplyUpReq.encode(v!, writer.uint32(50).fork()).join();
    }
    for (const v of message.rptMultimsgApplydownReq) {
      MultiMsgApplyDownReq.encode(v!, writer.uint32(58).fork()).join();
    }
    if (message.uint32BuType !== 0) {
      writer.uint32(64).uint32(message.uint32BuType);
    }
    if (message.uint32ReqChannelType !== 0) {
      writer.uint32(72).uint32(message.uint32ReqChannelType);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MultiMsgReqBody {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMultiMsgReqBody();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.uint32Subcmd = reader.uint32();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.uint32TermType = reader.uint32();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.uint32PlatformType = reader.uint32();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.uint32NetType = reader.uint32();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.bytesBuildVer = reader.bytes();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.rptMultimsgApplyupReq.push(MultiMsgApplyUpReq.decode(reader, reader.uint32()));
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.rptMultimsgApplydownReq.push(MultiMsgApplyDownReq.decode(reader, reader.uint32()));
          continue;
        }
        case 8: {
          if (tag !== 64) {
            break;
          }

          message.uint32BuType = reader.uint32();
          continue;
        }
        case 9: {
          if (tag !== 72) {
            break;
          }

          message.uint32ReqChannelType = reader.uint32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MultiMsgReqBody {
    return {
      uint32Subcmd: isSet(object.uint32Subcmd) ? globalThis.Number(object.uint32Subcmd) : 0,
      uint32TermType: isSet(object.uint32TermType) ? globalThis.Number(object.uint32TermType) : 0,
      uint32PlatformType: isSet(object.uint32PlatformType) ? globalThis.Number(object.uint32PlatformType) : 0,
      uint32NetType: isSet(object.uint32NetType) ? globalThis.Number(object.uint32NetType) : 0,
      bytesBuildVer: isSet(object.bytesBuildVer) ? bytesFromBase64(object.bytesBuildVer) : new Uint8Array(0),
      rptMultimsgApplyupReq: globalThis.Array.isArray(object?.rptMultimsgApplyupReq)
        ? object.rptMultimsgApplyupReq.map((e: any) => MultiMsgApplyUpReq.fromJSON(e))
        : [],
      rptMultimsgApplydownReq: globalThis.Array.isArray(object?.rptMultimsgApplydownReq)
        ? object.rptMultimsgApplydownReq.map((e: any) => MultiMsgApplyDownReq.fromJSON(e))
        : [],
      uint32BuType: isSet(object.uint32BuType) ? globalThis.Number(object.uint32BuType) : 0,
      uint32ReqChannelType: isSet(object.uint32ReqChannelType) ? globalThis.Number(object.uint32ReqChannelType) : 0,
    };
  },

  toJSON(message: MultiMsgReqBody): unknown {
    const obj: any = {};
    if (message.uint32Subcmd !== 0) {
      obj.uint32Subcmd = Math.round(message.uint32Subcmd);
    }
    if (message.uint32TermType !== 0) {
      obj.uint32TermType = Math.round(message.uint32TermType);
    }
    if (message.uint32PlatformType !== 0) {
      obj.uint32PlatformType = Math.round(message.uint32PlatformType);
    }
    if (message.uint32NetType !== 0) {
      obj.uint32NetType = Math.round(message.uint32NetType);
    }
    if (message.bytesBuildVer.length !== 0) {
      obj.bytesBuildVer = base64FromBytes(message.bytesBuildVer);
    }
    if (message.rptMultimsgApplyupReq?.length) {
      obj.rptMultimsgApplyupReq = message.rptMultimsgApplyupReq.map((e) => MultiMsgApplyUpReq.toJSON(e));
    }
    if (message.rptMultimsgApplydownReq?.length) {
      obj.rptMultimsgApplydownReq = message.rptMultimsgApplydownReq.map((e) => MultiMsgApplyDownReq.toJSON(e));
    }
    if (message.uint32BuType !== 0) {
      obj.uint32BuType = Math.round(message.uint32BuType);
    }
    if (message.uint32ReqChannelType !== 0) {
      obj.uint32ReqChannelType = Math.round(message.uint32ReqChannelType);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MultiMsgReqBody>, I>>(base?: I): MultiMsgReqBody {
    return MultiMsgReqBody.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MultiMsgReqBody>, I>>(object: I): MultiMsgReqBody {
    const message = createBaseMultiMsgReqBody();
    message.uint32Subcmd = object.uint32Subcmd ?? 0;
    message.uint32TermType = object.uint32TermType ?? 0;
    message.uint32PlatformType = object.uint32PlatformType ?? 0;
    message.uint32NetType = object.uint32NetType ?? 0;
    message.bytesBuildVer = object.bytesBuildVer ?? new Uint8Array(0);
    message.rptMultimsgApplyupReq = object.rptMultimsgApplyupReq?.map((e) => MultiMsgApplyUpReq.fromPartial(e)) || [];
    message.rptMultimsgApplydownReq = object.rptMultimsgApplydownReq?.map((e) => MultiMsgApplyDownReq.fromPartial(e)) ||
      [];
    message.uint32BuType = object.uint32BuType ?? 0;
    message.uint32ReqChannelType = object.uint32ReqChannelType ?? 0;
    return message;
  },
};

function createBaseMultiMsgApplyUpReq(): MultiMsgApplyUpReq {
  return { uint64DstUin: 0, uint64MsgSize: 0, bytesMsgMd5: new Uint8Array(0), uint32MsgType: 0, uint32ApplyId: 0 };
}

export const MultiMsgApplyUpReq: MessageFns<MultiMsgApplyUpReq> = {
  encode(message: MultiMsgApplyUpReq, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.uint64DstUin !== 0) {
      writer.uint32(8).uint64(message.uint64DstUin);
    }
    if (message.uint64MsgSize !== 0) {
      writer.uint32(16).uint64(message.uint64MsgSize);
    }
    if (message.bytesMsgMd5.length !== 0) {
      writer.uint32(26).bytes(message.bytesMsgMd5);
    }
    if (message.uint32MsgType !== 0) {
      writer.uint32(32).uint32(message.uint32MsgType);
    }
    if (message.uint32ApplyId !== 0) {
      writer.uint32(40).uint32(message.uint32ApplyId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MultiMsgApplyUpReq {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMultiMsgApplyUpReq();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.uint64DstUin = longToNumber(reader.uint64());
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.uint64MsgSize = longToNumber(reader.uint64());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.bytesMsgMd5 = reader.bytes();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.uint32MsgType = reader.uint32();
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.uint32ApplyId = reader.uint32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MultiMsgApplyUpReq {
    return {
      uint64DstUin: isSet(object.uint64DstUin) ? globalThis.Number(object.uint64DstUin) : 0,
      uint64MsgSize: isSet(object.uint64MsgSize) ? globalThis.Number(object.uint64MsgSize) : 0,
      bytesMsgMd5: isSet(object.bytesMsgMd5) ? bytesFromBase64(object.bytesMsgMd5) : new Uint8Array(0),
      uint32MsgType: isSet(object.uint32MsgType) ? globalThis.Number(object.uint32MsgType) : 0,
      uint32ApplyId: isSet(object.uint32ApplyId) ? globalThis.Number(object.uint32ApplyId) : 0,
    };
  },

  toJSON(message: MultiMsgApplyUpReq): unknown {
    const obj: any = {};
    if (message.uint64DstUin !== 0) {
      obj.uint64DstUin = Math.round(message.uint64DstUin);
    }
    if (message.uint64MsgSize !== 0) {
      obj.uint64MsgSize = Math.round(message.uint64MsgSize);
    }
    if (message.bytesMsgMd5.length !== 0) {
      obj.bytesMsgMd5 = base64FromBytes(message.bytesMsgMd5);
    }
    if (message.uint32MsgType !== 0) {
      obj.uint32MsgType = Math.round(message.uint32MsgType);
    }
    if (message.uint32ApplyId !== 0) {
      obj.uint32ApplyId = Math.round(message.uint32ApplyId);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MultiMsgApplyUpReq>, I>>(base?: I): MultiMsgApplyUpReq {
    return MultiMsgApplyUpReq.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MultiMsgApplyUpReq>, I>>(object: I): MultiMsgApplyUpReq {
    const message = createBaseMultiMsgApplyUpReq();
    message.uint64DstUin = object.uint64DstUin ?? 0;
    message.uint64MsgSize = object.uint64MsgSize ?? 0;
    message.bytesMsgMd5 = object.bytesMsgMd5 ?? new Uint8Array(0);
    message.uint32MsgType = object.uint32MsgType ?? 0;
    message.uint32ApplyId = object.uint32ApplyId ?? 0;
    return message;
  },
};

function createBaseMultiMsgApplyDownReq(): MultiMsgApplyDownReq {
  return {
    bytesMsgResid: new Uint8Array(0),
    uint32MsgType: 0,
    uint64SrcUin: 0,
    uint32ApplyId: 0,
    bytesMsgKey: new Uint8Array(0),
    bytesMsgSig: new Uint8Array(0),
    rptIpV4Info: [],
    rptIpV6Info: [],
  };
}

export const MultiMsgApplyDownReq: MessageFns<MultiMsgApplyDownReq> = {
  encode(message: MultiMsgApplyDownReq, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.bytesMsgResid.length !== 0) {
      writer.uint32(10).bytes(message.bytesMsgResid);
    }
    if (message.uint32MsgType !== 0) {
      writer.uint32(16).uint32(message.uint32MsgType);
    }
    if (message.uint64SrcUin !== 0) {
      writer.uint32(24).uint64(message.uint64SrcUin);
    }
    if (message.uint32ApplyId !== 0) {
      writer.uint32(32).uint32(message.uint32ApplyId);
    }
    if (message.bytesMsgKey.length !== 0) {
      writer.uint32(42).bytes(message.bytesMsgKey);
    }
    if (message.bytesMsgSig.length !== 0) {
      writer.uint32(50).bytes(message.bytesMsgSig);
    }
    for (const v of message.rptIpV4Info) {
      Ipv4Info.encode(v!, writer.uint32(58).fork()).join();
    }
    for (const v of message.rptIpV6Info) {
      Ipv6Info.encode(v!, writer.uint32(66).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MultiMsgApplyDownReq {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMultiMsgApplyDownReq();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.bytesMsgResid = reader.bytes();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.uint32MsgType = reader.uint32();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.uint64SrcUin = longToNumber(reader.uint64());
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.uint32ApplyId = reader.uint32();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.bytesMsgKey = reader.bytes();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.bytesMsgSig = reader.bytes();
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.rptIpV4Info.push(Ipv4Info.decode(reader, reader.uint32()));
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.rptIpV6Info.push(Ipv6Info.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MultiMsgApplyDownReq {
    return {
      bytesMsgResid: isSet(object.bytesMsgResid) ? bytesFromBase64(object.bytesMsgResid) : new Uint8Array(0),
      uint32MsgType: isSet(object.uint32MsgType) ? globalThis.Number(object.uint32MsgType) : 0,
      uint64SrcUin: isSet(object.uint64SrcUin) ? globalThis.Number(object.uint64SrcUin) : 0,
      uint32ApplyId: isSet(object.uint32ApplyId) ? globalThis.Number(object.uint32ApplyId) : 0,
      bytesMsgKey: isSet(object.bytesMsgKey) ? bytesFromBase64(object.bytesMsgKey) : new Uint8Array(0),
      bytesMsgSig: isSet(object.bytesMsgSig) ? bytesFromBase64(object.bytesMsgSig) : new Uint8Array(0),
      rptIpV4Info: globalThis.Array.isArray(object?.rptIpV4Info)
        ? object.rptIpV4Info.map((e: any) => Ipv4Info.fromJSON(e))
        : [],
      rptIpV6Info: globalThis.Array.isArray(object?.rptIpV6Info)
        ? object.rptIpV6Info.map((e: any) => Ipv6Info.fromJSON(e))
        : [],
    };
  },

  toJSON(message: MultiMsgApplyDownReq): unknown {
    const obj: any = {};
    if (message.bytesMsgResid.length !== 0) {
      obj.bytesMsgResid = base64FromBytes(message.bytesMsgResid);
    }
    if (message.uint32MsgType !== 0) {
      obj.uint32MsgType = Math.round(message.uint32MsgType);
    }
    if (message.uint64SrcUin !== 0) {
      obj.uint64SrcUin = Math.round(message.uint64SrcUin);
    }
    if (message.uint32ApplyId !== 0) {
      obj.uint32ApplyId = Math.round(message.uint32ApplyId);
    }
    if (message.bytesMsgKey.length !== 0) {
      obj.bytesMsgKey = base64FromBytes(message.bytesMsgKey);
    }
    if (message.bytesMsgSig.length !== 0) {
      obj.bytesMsgSig = base64FromBytes(message.bytesMsgSig);
    }
    if (message.rptIpV4Info?.length) {
      obj.rptIpV4Info = message.rptIpV4Info.map((e) => Ipv4Info.toJSON(e));
    }
    if (message.rptIpV6Info?.length) {
      obj.rptIpV6Info = message.rptIpV6Info.map((e) => Ipv6Info.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MultiMsgApplyDownReq>, I>>(base?: I): MultiMsgApplyDownReq {
    return MultiMsgApplyDownReq.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MultiMsgApplyDownReq>, I>>(object: I): MultiMsgApplyDownReq {
    const message = createBaseMultiMsgApplyDownReq();
    message.bytesMsgResid = object.bytesMsgResid ?? new Uint8Array(0);
    message.uint32MsgType = object.uint32MsgType ?? 0;
    message.uint64SrcUin = object.uint64SrcUin ?? 0;
    message.uint32ApplyId = object.uint32ApplyId ?? 0;
    message.bytesMsgKey = object.bytesMsgKey ?? new Uint8Array(0);
    message.bytesMsgSig = object.bytesMsgSig ?? new Uint8Array(0);
    message.rptIpV4Info = object.rptIpV4Info?.map((e) => Ipv4Info.fromPartial(e)) || [];
    message.rptIpV6Info = object.rptIpV6Info?.map((e) => Ipv6Info.fromPartial(e)) || [];
    return message;
  },
};

function createBaseIpv4Info(): Ipv4Info {
  return { uint32IpV4Addr: 0, uint32IpV4Port: 0, uint32IsHttpsAddr: 0 };
}

export const Ipv4Info: MessageFns<Ipv4Info> = {
  encode(message: Ipv4Info, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.uint32IpV4Addr !== 0) {
      writer.uint32(8).uint32(message.uint32IpV4Addr);
    }
    if (message.uint32IpV4Port !== 0) {
      writer.uint32(16).uint32(message.uint32IpV4Port);
    }
    if (message.uint32IsHttpsAddr !== 0) {
      writer.uint32(24).uint32(message.uint32IsHttpsAddr);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Ipv4Info {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseIpv4Info();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.uint32IpV4Addr = reader.uint32();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.uint32IpV4Port = reader.uint32();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.uint32IsHttpsAddr = reader.uint32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Ipv4Info {
    return {
      uint32IpV4Addr: isSet(object.uint32IpV4Addr) ? globalThis.Number(object.uint32IpV4Addr) : 0,
      uint32IpV4Port: isSet(object.uint32IpV4Port) ? globalThis.Number(object.uint32IpV4Port) : 0,
      uint32IsHttpsAddr: isSet(object.uint32IsHttpsAddr) ? globalThis.Number(object.uint32IsHttpsAddr) : 0,
    };
  },

  toJSON(message: Ipv4Info): unknown {
    const obj: any = {};
    if (message.uint32IpV4Addr !== 0) {
      obj.uint32IpV4Addr = Math.round(message.uint32IpV4Addr);
    }
    if (message.uint32IpV4Port !== 0) {
      obj.uint32IpV4Port = Math.round(message.uint32IpV4Port);
    }
    if (message.uint32IsHttpsAddr !== 0) {
      obj.uint32IsHttpsAddr = Math.round(message.uint32IsHttpsAddr);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Ipv4Info>, I>>(base?: I): Ipv4Info {
    return Ipv4Info.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Ipv4Info>, I>>(object: I): Ipv4Info {
    const message = createBaseIpv4Info();
    message.uint32IpV4Addr = object.uint32IpV4Addr ?? 0;
    message.uint32IpV4Port = object.uint32IpV4Port ?? 0;
    message.uint32IsHttpsAddr = object.uint32IsHttpsAddr ?? 0;
    return message;
  },
};

function createBaseIpv6Info(): Ipv6Info {
  return { bytesIpV6Addr: new Uint8Array(0), uint32IpV6Port: 0, uint32IsHttpsAddr: 0 };
}

export const Ipv6Info: MessageFns<Ipv6Info> = {
  encode(message: Ipv6Info, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.bytesIpV6Addr.length !== 0) {
      writer.uint32(10).bytes(message.bytesIpV6Addr);
    }
    if (message.uint32IpV6Port !== 0) {
      writer.uint32(16).uint32(message.uint32IpV6Port);
    }
    if (message.uint32IsHttpsAddr !== 0) {
      writer.uint32(24).uint32(message.uint32IsHttpsAddr);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Ipv6Info {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseIpv6Info();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.bytesIpV6Addr = reader.bytes();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.uint32IpV6Port = reader.uint32();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.uint32IsHttpsAddr = reader.uint32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Ipv6Info {
    return {
      bytesIpV6Addr: isSet(object.bytesIpV6Addr) ? bytesFromBase64(object.bytesIpV6Addr) : new Uint8Array(0),
      uint32IpV6Port: isSet(object.uint32IpV6Port) ? globalThis.Number(object.uint32IpV6Port) : 0,
      uint32IsHttpsAddr: isSet(object.uint32IsHttpsAddr) ? globalThis.Number(object.uint32IsHttpsAddr) : 0,
    };
  },

  toJSON(message: Ipv6Info): unknown {
    const obj: any = {};
    if (message.bytesIpV6Addr.length !== 0) {
      obj.bytesIpV6Addr = base64FromBytes(message.bytesIpV6Addr);
    }
    if (message.uint32IpV6Port !== 0) {
      obj.uint32IpV6Port = Math.round(message.uint32IpV6Port);
    }
    if (message.uint32IsHttpsAddr !== 0) {
      obj.uint32IsHttpsAddr = Math.round(message.uint32IsHttpsAddr);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Ipv6Info>, I>>(base?: I): Ipv6Info {
    return Ipv6Info.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Ipv6Info>, I>>(object: I): Ipv6Info {
    const message = createBaseIpv6Info();
    message.bytesIpV6Addr = object.bytesIpV6Addr ?? new Uint8Array(0);
    message.uint32IpV6Port = object.uint32IpV6Port ?? 0;
    message.uint32IsHttpsAddr = object.uint32IsHttpsAddr ?? 0;
    return message;
  },
};

function createBaseMultiMsgRsqBody(): MultiMsgRsqBody {
  return { uint32Subcmd: 0, rptMultimsgApplyupRsp: [], rptMultimsgApplydownRsp: [] };
}

export const MultiMsgRsqBody: MessageFns<MultiMsgRsqBody> = {
  encode(message: MultiMsgRsqBody, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.uint32Subcmd !== 0) {
      writer.uint32(8).uint32(message.uint32Subcmd);
    }
    for (const v of message.rptMultimsgApplyupRsp) {
      MultiMsgApplyUpRsq.encode(v!, writer.uint32(18).fork()).join();
    }
    for (const v of message.rptMultimsgApplydownRsp) {
      MultiMsgApplyDownRsq.encode(v!, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MultiMsgRsqBody {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMultiMsgRsqBody();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.uint32Subcmd = reader.uint32();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.rptMultimsgApplyupRsp.push(MultiMsgApplyUpRsq.decode(reader, reader.uint32()));
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.rptMultimsgApplydownRsp.push(MultiMsgApplyDownRsq.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MultiMsgRsqBody {
    return {
      uint32Subcmd: isSet(object.uint32Subcmd) ? globalThis.Number(object.uint32Subcmd) : 0,
      rptMultimsgApplyupRsp: globalThis.Array.isArray(object?.rptMultimsgApplyupRsp)
        ? object.rptMultimsgApplyupRsp.map((e: any) => MultiMsgApplyUpRsq.fromJSON(e))
        : [],
      rptMultimsgApplydownRsp: globalThis.Array.isArray(object?.rptMultimsgApplydownRsp)
        ? object.rptMultimsgApplydownRsp.map((e: any) => MultiMsgApplyDownRsq.fromJSON(e))
        : [],
    };
  },

  toJSON(message: MultiMsgRsqBody): unknown {
    const obj: any = {};
    if (message.uint32Subcmd !== 0) {
      obj.uint32Subcmd = Math.round(message.uint32Subcmd);
    }
    if (message.rptMultimsgApplyupRsp?.length) {
      obj.rptMultimsgApplyupRsp = message.rptMultimsgApplyupRsp.map((e) => MultiMsgApplyUpRsq.toJSON(e));
    }
    if (message.rptMultimsgApplydownRsp?.length) {
      obj.rptMultimsgApplydownRsp = message.rptMultimsgApplydownRsp.map((e) => MultiMsgApplyDownRsq.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MultiMsgRsqBody>, I>>(base?: I): MultiMsgRsqBody {
    return MultiMsgRsqBody.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MultiMsgRsqBody>, I>>(object: I): MultiMsgRsqBody {
    const message = createBaseMultiMsgRsqBody();
    message.uint32Subcmd = object.uint32Subcmd ?? 0;
    message.rptMultimsgApplyupRsp = object.rptMultimsgApplyupRsp?.map((e) => MultiMsgApplyUpRsq.fromPartial(e)) || [];
    message.rptMultimsgApplydownRsp = object.rptMultimsgApplydownRsp?.map((e) => MultiMsgApplyDownRsq.fromPartial(e)) ||
      [];
    return message;
  },
};

function createBaseMultiMsgApplyUpRsq(): MultiMsgApplyUpRsq {
  return {
    uint32Result: 0,
    bytesMsgResid: new Uint8Array(0),
    bytesMsgUkey: new Uint8Array(0),
    rptUint32UpIp: [],
    rptUint32UpPort: [],
    uint64BlockSize: 0,
    uint64UpOffset: 0,
    uint32ApplyId: 0,
    bytesMsgKey: new Uint8Array(0),
    bytesMsgSig: new Uint8Array(0),
    msgExternInfo: new Uint8Array(0),
    rptBytesUpIpV6: [],
    rptUint32UpV6Port: [],
  };
}

export const MultiMsgApplyUpRsq: MessageFns<MultiMsgApplyUpRsq> = {
  encode(message: MultiMsgApplyUpRsq, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.uint32Result !== 0) {
      writer.uint32(8).uint32(message.uint32Result);
    }
    if (message.bytesMsgResid.length !== 0) {
      writer.uint32(18).bytes(message.bytesMsgResid);
    }
    if (message.bytesMsgUkey.length !== 0) {
      writer.uint32(26).bytes(message.bytesMsgUkey);
    }
    writer.uint32(34).fork();
    for (const v of message.rptUint32UpIp) {
      writer.uint32(v);
    }
    writer.join();
    writer.uint32(42).fork();
    for (const v of message.rptUint32UpPort) {
      writer.uint32(v);
    }
    writer.join();
    if (message.uint64BlockSize !== 0) {
      writer.uint32(48).uint64(message.uint64BlockSize);
    }
    if (message.uint64UpOffset !== 0) {
      writer.uint32(56).uint64(message.uint64UpOffset);
    }
    if (message.uint32ApplyId !== 0) {
      writer.uint32(64).uint32(message.uint32ApplyId);
    }
    if (message.bytesMsgKey.length !== 0) {
      writer.uint32(74).bytes(message.bytesMsgKey);
    }
    if (message.bytesMsgSig.length !== 0) {
      writer.uint32(82).bytes(message.bytesMsgSig);
    }
    if (message.msgExternInfo.length !== 0) {
      writer.uint32(90).bytes(message.msgExternInfo);
    }
    for (const v of message.rptBytesUpIpV6) {
      writer.uint32(98).bytes(v!);
    }
    writer.uint32(106).fork();
    for (const v of message.rptUint32UpV6Port) {
      writer.uint32(v);
    }
    writer.join();
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MultiMsgApplyUpRsq {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMultiMsgApplyUpRsq();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.uint32Result = reader.uint32();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.bytesMsgResid = reader.bytes();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.bytesMsgUkey = reader.bytes();
          continue;
        }
        case 4: {
          if (tag === 32) {
            message.rptUint32UpIp.push(reader.uint32());

            continue;
          }

          if (tag === 34) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.rptUint32UpIp.push(reader.uint32());
            }

            continue;
          }

          break;
        }
        case 5: {
          if (tag === 40) {
            message.rptUint32UpPort.push(reader.uint32());

            continue;
          }

          if (tag === 42) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.rptUint32UpPort.push(reader.uint32());
            }

            continue;
          }

          break;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.uint64BlockSize = longToNumber(reader.uint64());
          continue;
        }
        case 7: {
          if (tag !== 56) {
            break;
          }

          message.uint64UpOffset = longToNumber(reader.uint64());
          continue;
        }
        case 8: {
          if (tag !== 64) {
            break;
          }

          message.uint32ApplyId = reader.uint32();
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.bytesMsgKey = reader.bytes();
          continue;
        }
        case 10: {
          if (tag !== 82) {
            break;
          }

          message.bytesMsgSig = reader.bytes();
          continue;
        }
        case 11: {
          if (tag !== 90) {
            break;
          }

          message.msgExternInfo = reader.bytes();
          continue;
        }
        case 12: {
          if (tag !== 98) {
            break;
          }

          message.rptBytesUpIpV6.push(reader.bytes());
          continue;
        }
        case 13: {
          if (tag === 104) {
            message.rptUint32UpV6Port.push(reader.uint32());

            continue;
          }

          if (tag === 106) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.rptUint32UpV6Port.push(reader.uint32());
            }

            continue;
          }

          break;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MultiMsgApplyUpRsq {
    return {
      uint32Result: isSet(object.uint32Result) ? globalThis.Number(object.uint32Result) : 0,
      bytesMsgResid: isSet(object.bytesMsgResid) ? bytesFromBase64(object.bytesMsgResid) : new Uint8Array(0),
      bytesMsgUkey: isSet(object.bytesMsgUkey) ? bytesFromBase64(object.bytesMsgUkey) : new Uint8Array(0),
      rptUint32UpIp: globalThis.Array.isArray(object?.rptUint32UpIp)
        ? object.rptUint32UpIp.map((e: any) => globalThis.Number(e))
        : [],
      rptUint32UpPort: globalThis.Array.isArray(object?.rptUint32UpPort)
        ? object.rptUint32UpPort.map((e: any) => globalThis.Number(e))
        : [],
      uint64BlockSize: isSet(object.uint64BlockSize) ? globalThis.Number(object.uint64BlockSize) : 0,
      uint64UpOffset: isSet(object.uint64UpOffset) ? globalThis.Number(object.uint64UpOffset) : 0,
      uint32ApplyId: isSet(object.uint32ApplyId) ? globalThis.Number(object.uint32ApplyId) : 0,
      bytesMsgKey: isSet(object.bytesMsgKey) ? bytesFromBase64(object.bytesMsgKey) : new Uint8Array(0),
      bytesMsgSig: isSet(object.bytesMsgSig) ? bytesFromBase64(object.bytesMsgSig) : new Uint8Array(0),
      msgExternInfo: isSet(object.msgExternInfo) ? bytesFromBase64(object.msgExternInfo) : new Uint8Array(0),
      rptBytesUpIpV6: globalThis.Array.isArray(object?.rptBytesUpIpV6)
        ? object.rptBytesUpIpV6.map((e: any) => bytesFromBase64(e))
        : [],
      rptUint32UpV6Port: globalThis.Array.isArray(object?.rptUint32UpV6Port)
        ? object.rptUint32UpV6Port.map((e: any) => globalThis.Number(e))
        : [],
    };
  },

  toJSON(message: MultiMsgApplyUpRsq): unknown {
    const obj: any = {};
    if (message.uint32Result !== 0) {
      obj.uint32Result = Math.round(message.uint32Result);
    }
    if (message.bytesMsgResid.length !== 0) {
      obj.bytesMsgResid = base64FromBytes(message.bytesMsgResid);
    }
    if (message.bytesMsgUkey.length !== 0) {
      obj.bytesMsgUkey = base64FromBytes(message.bytesMsgUkey);
    }
    if (message.rptUint32UpIp?.length) {
      obj.rptUint32UpIp = message.rptUint32UpIp.map((e) => Math.round(e));
    }
    if (message.rptUint32UpPort?.length) {
      obj.rptUint32UpPort = message.rptUint32UpPort.map((e) => Math.round(e));
    }
    if (message.uint64BlockSize !== 0) {
      obj.uint64BlockSize = Math.round(message.uint64BlockSize);
    }
    if (message.uint64UpOffset !== 0) {
      obj.uint64UpOffset = Math.round(message.uint64UpOffset);
    }
    if (message.uint32ApplyId !== 0) {
      obj.uint32ApplyId = Math.round(message.uint32ApplyId);
    }
    if (message.bytesMsgKey.length !== 0) {
      obj.bytesMsgKey = base64FromBytes(message.bytesMsgKey);
    }
    if (message.bytesMsgSig.length !== 0) {
      obj.bytesMsgSig = base64FromBytes(message.bytesMsgSig);
    }
    if (message.msgExternInfo.length !== 0) {
      obj.msgExternInfo = base64FromBytes(message.msgExternInfo);
    }
    if (message.rptBytesUpIpV6?.length) {
      obj.rptBytesUpIpV6 = message.rptBytesUpIpV6.map((e) => base64FromBytes(e));
    }
    if (message.rptUint32UpV6Port?.length) {
      obj.rptUint32UpV6Port = message.rptUint32UpV6Port.map((e) => Math.round(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MultiMsgApplyUpRsq>, I>>(base?: I): MultiMsgApplyUpRsq {
    return MultiMsgApplyUpRsq.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MultiMsgApplyUpRsq>, I>>(object: I): MultiMsgApplyUpRsq {
    const message = createBaseMultiMsgApplyUpRsq();
    message.uint32Result = object.uint32Result ?? 0;
    message.bytesMsgResid = object.bytesMsgResid ?? new Uint8Array(0);
    message.bytesMsgUkey = object.bytesMsgUkey ?? new Uint8Array(0);
    message.rptUint32UpIp = object.rptUint32UpIp?.map((e) => e) || [];
    message.rptUint32UpPort = object.rptUint32UpPort?.map((e) => e) || [];
    message.uint64BlockSize = object.uint64BlockSize ?? 0;
    message.uint64UpOffset = object.uint64UpOffset ?? 0;
    message.uint32ApplyId = object.uint32ApplyId ?? 0;
    message.bytesMsgKey = object.bytesMsgKey ?? new Uint8Array(0);
    message.bytesMsgSig = object.bytesMsgSig ?? new Uint8Array(0);
    message.msgExternInfo = object.msgExternInfo ?? new Uint8Array(0);
    message.rptBytesUpIpV6 = object.rptBytesUpIpV6?.map((e) => e) || [];
    message.rptUint32UpV6Port = object.rptUint32UpV6Port?.map((e) => e) || [];
    return message;
  },
};

function createBaseMultiMsgApplyDownRsq(): MultiMsgApplyDownRsq {
  return {
    uint32Result: 0,
    bytesThumbDownPara: new Uint8Array(0),
    bytesMsgKey: new Uint8Array(0),
    rptUint32DownIp: [],
    rptUint32DownPort: [],
    bytesMsgResid: new Uint8Array(0),
    msgExternInfo: undefined,
    rptBytesDownIpV6: [],
    rptUint32DownV6Port: [],
    uint32ApplyId: 0,
  };
}

export const MultiMsgApplyDownRsq: MessageFns<MultiMsgApplyDownRsq> = {
  encode(message: MultiMsgApplyDownRsq, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.uint32Result !== 0) {
      writer.uint32(8).uint32(message.uint32Result);
    }
    if (message.bytesThumbDownPara.length !== 0) {
      writer.uint32(18).bytes(message.bytesThumbDownPara);
    }
    if (message.bytesMsgKey.length !== 0) {
      writer.uint32(26).bytes(message.bytesMsgKey);
    }
    writer.uint32(34).fork();
    for (const v of message.rptUint32DownIp) {
      writer.uint32(v);
    }
    writer.join();
    writer.uint32(42).fork();
    for (const v of message.rptUint32DownPort) {
      writer.uint32(v);
    }
    writer.join();
    if (message.bytesMsgResid.length !== 0) {
      writer.uint32(50).bytes(message.bytesMsgResid);
    }
    if (message.msgExternInfo !== undefined) {
      MultiMsgExternMsg.encode(message.msgExternInfo, writer.uint32(58).fork()).join();
    }
    for (const v of message.rptBytesDownIpV6) {
      writer.uint32(66).bytes(v!);
    }
    writer.uint32(74).fork();
    for (const v of message.rptUint32DownV6Port) {
      writer.uint32(v);
    }
    writer.join();
    if (message.uint32ApplyId !== 0) {
      writer.uint32(80).uint32(message.uint32ApplyId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MultiMsgApplyDownRsq {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMultiMsgApplyDownRsq();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.uint32Result = reader.uint32();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.bytesThumbDownPara = reader.bytes();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.bytesMsgKey = reader.bytes();
          continue;
        }
        case 4: {
          if (tag === 32) {
            message.rptUint32DownIp.push(reader.uint32());

            continue;
          }

          if (tag === 34) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.rptUint32DownIp.push(reader.uint32());
            }

            continue;
          }

          break;
        }
        case 5: {
          if (tag === 40) {
            message.rptUint32DownPort.push(reader.uint32());

            continue;
          }

          if (tag === 42) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.rptUint32DownPort.push(reader.uint32());
            }

            continue;
          }

          break;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.bytesMsgResid = reader.bytes();
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.msgExternInfo = MultiMsgExternMsg.decode(reader, reader.uint32());
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.rptBytesDownIpV6.push(reader.bytes());
          continue;
        }
        case 9: {
          if (tag === 72) {
            message.rptUint32DownV6Port.push(reader.uint32());

            continue;
          }

          if (tag === 74) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.rptUint32DownV6Port.push(reader.uint32());
            }

            continue;
          }

          break;
        }
        case 10: {
          if (tag !== 80) {
            break;
          }

          message.uint32ApplyId = reader.uint32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MultiMsgApplyDownRsq {
    return {
      uint32Result: isSet(object.uint32Result) ? globalThis.Number(object.uint32Result) : 0,
      bytesThumbDownPara: isSet(object.bytesThumbDownPara)
        ? bytesFromBase64(object.bytesThumbDownPara)
        : new Uint8Array(0),
      bytesMsgKey: isSet(object.bytesMsgKey) ? bytesFromBase64(object.bytesMsgKey) : new Uint8Array(0),
      rptUint32DownIp: globalThis.Array.isArray(object?.rptUint32DownIp)
        ? object.rptUint32DownIp.map((e: any) => globalThis.Number(e))
        : [],
      rptUint32DownPort: globalThis.Array.isArray(object?.rptUint32DownPort)
        ? object.rptUint32DownPort.map((e: any) => globalThis.Number(e))
        : [],
      bytesMsgResid: isSet(object.bytesMsgResid) ? bytesFromBase64(object.bytesMsgResid) : new Uint8Array(0),
      msgExternInfo: isSet(object.msgExternInfo) ? MultiMsgExternMsg.fromJSON(object.msgExternInfo) : undefined,
      rptBytesDownIpV6: globalThis.Array.isArray(object?.rptBytesDownIpV6)
        ? object.rptBytesDownIpV6.map((e: any) => bytesFromBase64(e))
        : [],
      rptUint32DownV6Port: globalThis.Array.isArray(object?.rptUint32DownV6Port)
        ? object.rptUint32DownV6Port.map((e: any) => globalThis.Number(e))
        : [],
      uint32ApplyId: isSet(object.uint32ApplyId) ? globalThis.Number(object.uint32ApplyId) : 0,
    };
  },

  toJSON(message: MultiMsgApplyDownRsq): unknown {
    const obj: any = {};
    if (message.uint32Result !== 0) {
      obj.uint32Result = Math.round(message.uint32Result);
    }
    if (message.bytesThumbDownPara.length !== 0) {
      obj.bytesThumbDownPara = base64FromBytes(message.bytesThumbDownPara);
    }
    if (message.bytesMsgKey.length !== 0) {
      obj.bytesMsgKey = base64FromBytes(message.bytesMsgKey);
    }
    if (message.rptUint32DownIp?.length) {
      obj.rptUint32DownIp = message.rptUint32DownIp.map((e) => Math.round(e));
    }
    if (message.rptUint32DownPort?.length) {
      obj.rptUint32DownPort = message.rptUint32DownPort.map((e) => Math.round(e));
    }
    if (message.bytesMsgResid.length !== 0) {
      obj.bytesMsgResid = base64FromBytes(message.bytesMsgResid);
    }
    if (message.msgExternInfo !== undefined) {
      obj.msgExternInfo = MultiMsgExternMsg.toJSON(message.msgExternInfo);
    }
    if (message.rptBytesDownIpV6?.length) {
      obj.rptBytesDownIpV6 = message.rptBytesDownIpV6.map((e) => base64FromBytes(e));
    }
    if (message.rptUint32DownV6Port?.length) {
      obj.rptUint32DownV6Port = message.rptUint32DownV6Port.map((e) => Math.round(e));
    }
    if (message.uint32ApplyId !== 0) {
      obj.uint32ApplyId = Math.round(message.uint32ApplyId);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MultiMsgApplyDownRsq>, I>>(base?: I): MultiMsgApplyDownRsq {
    return MultiMsgApplyDownRsq.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MultiMsgApplyDownRsq>, I>>(object: I): MultiMsgApplyDownRsq {
    const message = createBaseMultiMsgApplyDownRsq();
    message.uint32Result = object.uint32Result ?? 0;
    message.bytesThumbDownPara = object.bytesThumbDownPara ?? new Uint8Array(0);
    message.bytesMsgKey = object.bytesMsgKey ?? new Uint8Array(0);
    message.rptUint32DownIp = object.rptUint32DownIp?.map((e) => e) || [];
    message.rptUint32DownPort = object.rptUint32DownPort?.map((e) => e) || [];
    message.bytesMsgResid = object.bytesMsgResid ?? new Uint8Array(0);
    message.msgExternInfo = (object.msgExternInfo !== undefined && object.msgExternInfo !== null)
      ? MultiMsgExternMsg.fromPartial(object.msgExternInfo)
      : undefined;
    message.rptBytesDownIpV6 = object.rptBytesDownIpV6?.map((e) => e) || [];
    message.rptUint32DownV6Port = object.rptUint32DownV6Port?.map((e) => e) || [];
    message.uint32ApplyId = object.uint32ApplyId ?? 0;
    return message;
  },
};

function createBaseMultiMsgExternMsg(): MultiMsgExternMsg {
  return { uint32ChannelType: 0 };
}

export const MultiMsgExternMsg: MessageFns<MultiMsgExternMsg> = {
  encode(message: MultiMsgExternMsg, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.uint32ChannelType !== 0) {
      writer.uint32(8).uint32(message.uint32ChannelType);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MultiMsgExternMsg {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMultiMsgExternMsg();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.uint32ChannelType = reader.uint32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MultiMsgExternMsg {
    return { uint32ChannelType: isSet(object.uint32ChannelType) ? globalThis.Number(object.uint32ChannelType) : 0 };
  },

  toJSON(message: MultiMsgExternMsg): unknown {
    const obj: any = {};
    if (message.uint32ChannelType !== 0) {
      obj.uint32ChannelType = Math.round(message.uint32ChannelType);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MultiMsgExternMsg>, I>>(base?: I): MultiMsgExternMsg {
    return MultiMsgExternMsg.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MultiMsgExternMsg>, I>>(object: I): MultiMsgExternMsg {
    const message = createBaseMultiMsgExternMsg();
    message.uint32ChannelType = object.uint32ChannelType ?? 0;
    return message;
  },
};

function bytesFromBase64(b64: string): Uint8Array {
  if ((globalThis as any).Buffer) {
    return Uint8Array.from(globalThis.Buffer.from(b64, "base64"));
  } else {
    const bin = globalThis.atob(b64);
    const arr = new Uint8Array(bin.length);
    for (let i = 0; i < bin.length; ++i) {
      arr[i] = bin.charCodeAt(i);
    }
    return arr;
  }
}

function base64FromBytes(arr: Uint8Array): string {
  if ((globalThis as any).Buffer) {
    return globalThis.Buffer.from(arr).toString("base64");
  } else {
    const bin: string[] = [];
    arr.forEach((byte) => {
      bin.push(globalThis.String.fromCharCode(byte));
    });
    return globalThis.btoa(bin.join(""));
  }
}

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

type KeysOfUnion<T> = T extends T ? keyof T : never;
export type Exact<P, I extends P> = P extends Builtin ? P
  : P & { [K in keyof P]: Exact<P[K], I[K]> } & { [K in Exclude<keyof I, KeysOfUnion<P>>]: never };

function longToNumber(int64: { toString(): string }): number {
  const num = globalThis.Number(int64.toString());
  if (num > globalThis.Number.MAX_SAFE_INTEGER) {
    throw new globalThis.Error("Value is larger than Number.MAX_SAFE_INTEGER");
  }
  if (num < globalThis.Number.MIN_SAFE_INTEGER) {
    throw new globalThis.Error("Value is smaller than Number.MIN_SAFE_INTEGER");
  }
  return num;
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create<I extends Exact<DeepPartial<T>, I>>(base?: I): T;
  fromPartial<I extends Exact<DeepPartial<T>, I>>(object: I): T;
}
