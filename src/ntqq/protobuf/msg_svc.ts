// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.2.5
//   protoc               v6.32.1
// source: msg_svc.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import { MsgBody } from "./im_msg_body";
import { ReceiptReq, ReceiptResp } from "./im_receipt";
import { ContentHead } from "./msg_comm";

export const protobufPackage = "msg_svc";

export interface AccostTmp {
  toUin?: number | undefined;
  sig?: Uint8Array | undefined;
  reply?: boolean | undefined;
}

export interface AddressListTmp {
  fromPhone?: string | undefined;
  toPhone?: string | undefined;
  toUin?: number | undefined;
  sig?: Uint8Array | undefined;
  fromContactSize?: number | undefined;
}

export interface AuthTmp {
  toUin?: number | undefined;
  sig?: Uint8Array | undefined;
}

export interface BsnsTmp {
  toUin?: number | undefined;
  sig?: Uint8Array | undefined;
}

export interface BusinessWPATmp {
  toUin?: number | undefined;
  sig?: Uint8Array | undefined;
  sigt?: Uint8Array | undefined;
}

export interface C2C {
  toUin?: number | undefined;
}

export interface CommTmp {
  toUin?: number | undefined;
  c2cType?: number | undefined;
  svrType?: number | undefined;
  sig?: Uint8Array | undefined;
  reserved?: Uint8Array | undefined;
}

export interface Dis {
  disUin?: number | undefined;
}

export interface DisTmp {
  disUin?: number | undefined;
  toUin?: number | undefined;
}

export interface Grp {
  groupCode?: number | undefined;
}

export interface GrpTmp {
  groupUin?: number | undefined;
  toUin?: number | undefined;
}

export interface MsgSendInfo {
  receiver?: number | undefined;
}

export interface MultiMsgAssist {
  repeatedRouting: RoutingHead[];
  msgUse?: number | undefined;
  uint64TempId?: number | undefined;
  uint64VedioLen?: number | undefined;
  bytesRedbagId?: Uint8Array | undefined;
  uint64RedbagAmount?: number | undefined;
  uint32HasReadbag?: number | undefined;
  uint32HasVedio?: number | undefined;
}

export interface NearByAssistantTmp {
  toUin?: number | undefined;
  sig?: Uint8Array | undefined;
  reply?: boolean | undefined;
}

export interface NearByDatingTmp {
  toUin?: number | undefined;
  sig?: Uint8Array | undefined;
  reply?: boolean | undefined;
}

export interface PbBindUinGetMsgReq {
  bindUin?: number | undefined;
  bindUinSig?: Uint8Array | undefined;
  syncFlag?: number | undefined;
  syncCookie?: Uint8Array | undefined;
}

export interface PbBindUinMsgReadedConfirmReq {
  syncCookie?: Uint8Array | undefined;
  bindUin?: number | undefined;
}

export interface PbBindUinMsgReadedConfirmResp {
  result?: number | undefined;
  errmsg?: string | undefined;
  syncCookie?: Uint8Array | undefined;
  bindUin?: number | undefined;
}

export interface PbBindUinUnReadMsgNumReq {
  bindUin?: number | undefined;
  syncCookie?: Uint8Array | undefined;
}

export interface PbBindUinUnReadMsgNumResp {
  result?: number | undefined;
  errmsg?: string | undefined;
  bindUin?: number | undefined;
  msgNum?: number | undefined;
}

export interface PbC2CMsgWithDrawReqMsgInfo {
  uint64FromUin?: number | undefined;
  uint64ToUin?: number | undefined;
  uint32MsgSeq?: number | undefined;
  uint64MsgUid?: number | undefined;
  uint64MsgTime?: number | undefined;
  uint32MsgRandom?: number | undefined;
  uint32PkgNum?: number | undefined;
  uint32PkgIndex?: number | undefined;
  uint32DivSeq?: number | undefined;
  uint32MsgType?: number | undefined;
  routingHead?: RoutingHead | undefined;
}

export interface PbC2CMsgWithDrawReq {
  msgInfo: PbC2CMsgWithDrawReqMsgInfo[];
  uint32LongMessageFlag?: number | undefined;
  bytesReserved?: Uint8Array | undefined;
  uint32SubCmd?: number | undefined;
}

export interface PbC2CMsgWithDrawRespMsgStatus {
  msgInfo?: PbC2CMsgWithDrawReqMsgInfo | undefined;
  uint32Status?: number | undefined;
}

export interface PbC2CMsgWithDrawResp {
  result?: number | undefined;
  errmsg?: string | undefined;
  msgStatus: PbC2CMsgWithDrawRespMsgStatus[];
  uint32SubCmd?: number | undefined;
  msgWordingInfo?: WithDrawWordingInfo | undefined;
}

export interface PbC2CReadedReportReqUinPairReadInfo {
  peerUin?: number | undefined;
  lastReadTime?: number | undefined;
  crmSig?: Uint8Array | undefined;
  peerType?: number | undefined;
  chatType?: number | undefined;
  cpid?: number | undefined;
  aioType?: number | undefined;
  uint64ToTinyId?: number | undefined;
}

export interface PbC2CReadedReportReq {
  syncCookie?: Uint8Array | undefined;
  pairInfo: PbC2CReadedReportReqUinPairReadInfo[];
}

export interface PbC2CReadedReportResp {
  result?: number | undefined;
  errmsg?: string | undefined;
  syncCookie?: Uint8Array | undefined;
}

export interface PbC2CUnReadMsgNumReq {
}

export interface PbC2CUnReadMsgNumResp {
  result?: number | undefined;
  errmsg?: string | undefined;
  msgNum?: number | undefined;
}

export interface PbDeleteMsgReqMsgItem {
  fromUin?: number | undefined;
  toUin?: number | undefined;
  msgType?: number | undefined;
  msgSeq?: number | undefined;
  msgUid?: number | undefined;
  sig?: Uint8Array | undefined;
}

export interface PbDeleteMsgReq {
  msgItems: PbDeleteMsgReqMsgItem[];
}

export interface PbDeleteMsgResp {
  result?: number | undefined;
  errmsg?: string | undefined;
}

export interface PbDelRoamMsgReqC2CMsg {
  fromUin?: number | undefined;
  peerUin?: number | undefined;
  msgTime?: number | undefined;
  msgRandom?: number | undefined;
  msgSeq?: number | undefined;
}

export interface PbDelRoamMsgReqDisMsg {
  discussUin?: number | undefined;
  msgSeq?: number | undefined;
}

export interface PbDelRoamMsgReqGrpMsg {
  groupCode?: number | undefined;
  msgSeq?: number | undefined;
  uint32ResvFlag?: number | undefined;
}

export interface PbDelRoamMsgReq {
  c2cMsg?: PbDelRoamMsgReqC2CMsg | undefined;
  grpMsg?: PbDelRoamMsgReqGrpMsg | undefined;
  disMsg?: PbDelRoamMsgReqDisMsg | undefined;
}

export interface PbDelRoamMsgResp {
  result?: number | undefined;
  errmsg?: string | undefined;
}

export interface PbDiscussReadedReportReq {
  confUin?: number | undefined;
  lastReadSeq?: number | undefined;
}

export interface PbDiscussReadedReportResp {
  result?: number | undefined;
  errmsg?: string | undefined;
  confUin?: number | undefined;
  memberSeq?: number | undefined;
  confSeq?: number | undefined;
}

export interface PbGetDiscussMsgReq {
  discussUin?: number | undefined;
  endSeq?: number | undefined;
  beginSeq?: number | undefined;
  lastGetTime?: number | undefined;
  discussInfoSeq?: number | undefined;
  filter?: number | undefined;
  memberSeq?: number | undefined;
}

export interface PbGetGroupMsgReq {
  groupCode?: number | undefined;
  beginSeq?: number | undefined;
  endSeq?: number | undefined;
  filter?: number | undefined;
  memberSeq?: number | undefined;
  publicGroup?: boolean | undefined;
  shieldFlag?: number | undefined;
  saveTrafficFlag?: number | undefined;
}

export interface PbGetMsgReq {
  syncFlag?: number | undefined;
  syncCookie?: Uint8Array | undefined;
  rambleFlag?: number | undefined;
  latestRambleNumber?: number | undefined;
  otherRambleNumber?: number | undefined;
  onlineSyncFlag?: number | undefined;
  contextFlag?: number | undefined;
  whisperSessionId?: number | undefined;
  msgReqType?: number | undefined;
  pubaccountCookie?: Uint8Array | undefined;
  msgCtrlBuf?: Uint8Array | undefined;
  bytesServerBuf?: Uint8Array | undefined;
}

export interface PbGetOneDayRoamMsgReq {
  peerUin?: number | undefined;
  lastMsgtime?: number | undefined;
  random?: number | undefined;
  readCnt?: number | undefined;
}

export interface PbGetOneDayRoamMsgResp {
  result?: number | undefined;
  errmsg?: string | undefined;
  peerUin?: number | undefined;
  lastMsgtime?: number | undefined;
  random?:
    | number
    | undefined;
  /** repeated msg_comm.Msg msg = 6; */
  iscomplete?: number | undefined;
}

export interface PbGetRoamMsgReq {
  peerUin?: number | undefined;
  lastMsgtime?: number | undefined;
  random?: number | undefined;
  readCnt?: number | undefined;
  checkPwd?: number | undefined;
  sig?: Uint8Array | undefined;
  pwd?: Uint8Array | undefined;
  subcmd?: number | undefined;
  beginMsgtime?: number | undefined;
  reqType?: number | undefined;
}

export interface PbGetRoamMsgResp {
  result?: number | undefined;
  errmsg?: string | undefined;
  peerUin?: number | undefined;
  lastMsgtime?: number | undefined;
  random?:
    | number
    | undefined;
  /** repeated msg_comm.Msg msg = 6; */
  sig?: Uint8Array | undefined;
}

export interface PbGroupMsgWithDrawReqMessageInfo {
  uint32MsgSeq?: number | undefined;
  uint32MsgRandom?: number | undefined;
  uint32MsgType?: number | undefined;
  uint32ResvFlag?: number | undefined;
}

export interface PbGroupMsgWithDrawReq {
  uint32SubCmd?: number | undefined;
  uint32GroupType?: number | undefined;
  uint64GroupCode?: number | undefined;
  msgList: PbGroupMsgWithDrawReqMessageInfo[];
  bytesUserdef?: Uint8Array | undefined;
}

export interface PbGroupMsgWithDrawRespMessageResult {
  uint32Result?: number | undefined;
  uint32MsgSeq?: number | undefined;
  uint32MsgTime?: number | undefined;
  uint32MsgRandom?: number | undefined;
  bytesErrMsg?: Uint8Array | undefined;
  uint32MsgType?: number | undefined;
}

export interface PbGroupMsgWithDrawResp {
  result?: number | undefined;
  errmsg?: string | undefined;
  uint32SubCmd?: number | undefined;
  uint32GroupType?: number | undefined;
  uint64GroupCode?: number | undefined;
  failedMsgList: PbGroupMsgWithDrawRespMessageResult[];
  bytesUserdef?: Uint8Array | undefined;
  msgWordingInfo?: WithDrawWordingInfo | undefined;
}

export interface PbGroupReadedReportReq {
  groupCode?: number | undefined;
  lastReadSeq?: number | undefined;
}

export interface PbGroupReadedReportResp {
  result?: number | undefined;
  errmsg?: string | undefined;
  groupCode?: number | undefined;
  memberSeq?: number | undefined;
  groupMsgSeq?: number | undefined;
}

export interface PbInputNotifyInfo {
  toUin?: number | undefined;
  ime?: number | undefined;
  notifyFlag?: number | undefined;
  bytesPbReserve?: Uint8Array | undefined;
  iosPushWording?: Uint8Array | undefined;
}

export interface PbMsgReadedReportReq {
  grpReadReport: PbGroupReadedReportReq[];
  disReadReport: PbDiscussReadedReportReq[];
  c2cReadReport?: PbC2CReadedReportReq | undefined;
  bindUinReadReport?: PbBindUinMsgReadedConfirmReq | undefined;
}

export interface PbMsgReadedReportResp {
  grpReadReport: PbGroupReadedReportResp[];
  disReadReport: PbDiscussReadedReportResp[];
  c2cReadReport?: PbC2CReadedReportResp | undefined;
  bindUinReadReport?: PbBindUinMsgReadedConfirmResp | undefined;
}

export interface PbMsgWithDrawReq {
  c2cWithDraw: PbC2CMsgWithDrawReq[];
  groupWithDraw: PbGroupMsgWithDrawReq[];
}

export interface PbMsgWithDrawResp {
  c2cWithDraw: PbC2CMsgWithDrawResp[];
  groupWithDraw: PbGroupMsgWithDrawResp[];
}

export interface PbPullDiscussMsgSeqReqDiscussInfoReq {
  confUin?: number | undefined;
  lastSeq?: number | undefined;
}

export interface PbPullDiscussMsgSeqReq {
  discussInfoReq: PbPullDiscussMsgSeqReqDiscussInfoReq[];
}

export interface PbPullDiscussMsgSeqRespDiscussInfoResp {
  confUin?: number | undefined;
  memberSeq?: number | undefined;
  confSeq?: number | undefined;
}

export interface PbPullDiscussMsgSeqResp {
  result?: number | undefined;
  errmsg?: string | undefined;
  discussInfoResp: PbPullDiscussMsgSeqRespDiscussInfoResp[];
}

export interface PbPullGroupMsgSeqReqGroupInfoReq {
  groupCode?: number | undefined;
  lastSeq?: number | undefined;
}

export interface PbPullGroupMsgSeqReq {
  groupInfoReq: PbPullGroupMsgSeqReqGroupInfoReq[];
}

export interface PbPullGroupMsgSeqRespGroupInfoResp {
  groupCode?: number | undefined;
  memberSeq?: number | undefined;
  groupSeq?: number | undefined;
}

export interface PbPullGroupMsgSeqResp {
  result?: number | undefined;
  errmsg?: string | undefined;
  groupInfoResp: PbPullGroupMsgSeqRespGroupInfoResp[];
}

export interface PbSearchRoamMsgInCloudReq {
  serializeReqbody?: Uint8Array | undefined;
}

export interface PbSendMsgReq {
  routingHead?: RoutingHead | undefined;
  contentHead?: ContentHead | undefined;
  msgBody?: MsgBody | undefined;
  msgSeq?: number | undefined;
  msgRand?: number | undefined;
  syncCookie?:
    | Uint8Array
    | undefined;
  /** optional msg_comm.AppShareInfo app_share = 7; */
  msgVia?: number | undefined;
  dataStatist?: number | undefined;
  multiMsgAssist?: MultiMsgAssist | undefined;
  inputNotifyInfo?:
    | PbInputNotifyInfo
    | undefined;
  /** optional msg_ctrl.MsgCtrl msg_ctrl = 12; */
  receiptReq?: ReceiptReq | undefined;
  multiSendSeq?: number | undefined;
}

export interface PbSendMsgResp {
  result?: number | undefined;
  errmsg?: string | undefined;
  sendTime?: number | undefined;
  uint32SvrbusyWaitTime?: number | undefined;
  msgSendInfo?: MsgSendInfo | undefined;
  errtype?: number | undefined;
  transSvrInfo?: TransSvrInfo | undefined;
  receiptResp?: ReceiptResp | undefined;
  textAnalysisResult?: number | undefined;
  uint32MsgInfoFlag?: number | undefined;
  msgeleminfoServtype37?: Uint8Array | undefined;
}

export interface PbThirdQQUnReadMsgNumReqThirdQQReqInfo {
  thirdUin?: number | undefined;
  thirdUinSig?: Uint8Array | undefined;
  thirdUinCookie?: Uint8Array | undefined;
}

export interface PbThirdQQUnReadMsgNumReq {
  thirdqqReqInfo: PbThirdQQUnReadMsgNumReqThirdQQReqInfo[];
  source?: number | undefined;
}

export interface PbThirdQQUnReadMsgNumRespThirdQQRespInfo {
  thirdUin?: number | undefined;
  thirdUinCookie?: Uint8Array | undefined;
  msgNum?: number | undefined;
  msgFlag?: number | undefined;
  redbagTime?: number | undefined;
  status?: number | undefined;
  lastMsgTime?: number | undefined;
}

export interface PbThirdQQUnReadMsgNumResp {
  result?: number | undefined;
  errmsg?: string | undefined;
  thirdqqRespInfo: PbThirdQQUnReadMsgNumRespThirdQQRespInfo[];
  interval?: number | undefined;
}

export interface PbUnReadMsgSeqReq {
  c2cUnreadInfo?: PbC2CUnReadMsgNumReq | undefined;
  binduinUnreadInfo: PbBindUinUnReadMsgNumReq[];
  groupUnreadInfo?: PbPullGroupMsgSeqReq | undefined;
  discussUnreadInfo?: PbPullDiscussMsgSeqReq | undefined;
  thirdqqUnreadInfo?: PbThirdQQUnReadMsgNumReq | undefined;
}

export interface PbUnReadMsgSeqResp {
  c2cUnreadInfo?: PbC2CUnReadMsgNumResp | undefined;
  binduinUnreadInfo: PbBindUinUnReadMsgNumResp[];
  groupUnreadInfo?: PbPullGroupMsgSeqResp | undefined;
  discussUnreadInfo?: PbPullDiscussMsgSeqResp | undefined;
  thirdqqUnreadInfo?: PbThirdQQUnReadMsgNumResp | undefined;
}

export interface PubGroupTmp {
  toUin?: number | undefined;
  sig?: Uint8Array | undefined;
  groupUin?: number | undefined;
}

export interface PublicPlat {
  toUin?: number | undefined;
  sig?: Uint8Array | undefined;
}

export interface QQQueryBusinessTmp {
  toUin?: number | undefined;
  sig?: Uint8Array | undefined;
}

export interface RichStatusTmp {
  toUin?: number | undefined;
  sig?: Uint8Array | undefined;
}

export interface RoutingHead {
  c2c?: C2C | undefined;
  grp?: Grp | undefined;
  grpTmp?: GrpTmp | undefined;
  dis?: Dis | undefined;
  disTmp?: DisTmp | undefined;
  wpaTmp?: WPATmp | undefined;
  secretFile?: SecretFileHead | undefined;
  publicPlat?: PublicPlat | undefined;
  transMsg?: TransMsg | undefined;
  addressList?: AddressListTmp | undefined;
  richStatusTmp?: RichStatusTmp | undefined;
  transCmd?: TransCmd | undefined;
  accostTmp?: AccostTmp | undefined;
  pubGroupTmp?:
    | PubGroupTmp
    | undefined;
  /** optional Trans0x211 trans_0x211 = 15; */
  businessWpaTmp?: BusinessWPATmp | undefined;
  authTmp?: AuthTmp | undefined;
  bsnsTmp?: BsnsTmp | undefined;
  qqQuerybusinessTmp?: QQQueryBusinessTmp | undefined;
  nearbyDatingTmp?: NearByDatingTmp | undefined;
  nearbyAssistantTmp?: NearByAssistantTmp | undefined;
  commTmp?: CommTmp | undefined;
}

/**
 * optional SubMsgType0xc1.MsgBody secret_file_msg = 1;
 * optional SubMsgType0x1a.MsgBody secret_file_status = 2;
 */
export interface SecretFileHead {
}

export interface TransCmd {
  toUin?: number | undefined;
  msgType?: number | undefined;
}

export interface TransMsg {
  toUin?: number | undefined;
  c2cCmd?: number | undefined;
}

export interface TransReq {
  command?: number | undefined;
  reqTag?: number | undefined;
  reqBuff?: Uint8Array | undefined;
}

export interface TransResp {
  result?: number | undefined;
  errmsg?: string | undefined;
  respTag?: number | undefined;
  respBuff?: Uint8Array | undefined;
}

export interface TransSvrInfo {
  uint32SubType?: number | undefined;
  int32RetCode?: number | undefined;
  bytesErrMsg?: Uint8Array | undefined;
  bytesTransInfo?: Uint8Array | undefined;
}

export interface WithDrawWordingInfo {
  int32ItemId?: number | undefined;
  stringItemName?: string | undefined;
}

export interface WPATmp {
  toUin?: number | undefined;
  sig?: Uint8Array | undefined;
}

function createBaseAccostTmp(): AccostTmp {
  return { toUin: undefined, sig: undefined, reply: undefined };
}

export const AccostTmp: MessageFns<AccostTmp> = {
  encode(message: AccostTmp, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.toUin !== undefined) {
      writer.uint32(8).uint64(message.toUin);
    }
    if (message.sig !== undefined) {
      writer.uint32(18).bytes(message.sig);
    }
    if (message.reply !== undefined) {
      writer.uint32(24).bool(message.reply);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AccostTmp {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAccostTmp();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.toUin = longToNumber(reader.uint64());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.sig = reader.bytes();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.reply = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AccostTmp {
    return {
      toUin: isSet(object.toUin) ? globalThis.Number(object.toUin) : undefined,
      sig: isSet(object.sig) ? bytesFromBase64(object.sig) : undefined,
      reply: isSet(object.reply) ? globalThis.Boolean(object.reply) : undefined,
    };
  },

  toJSON(message: AccostTmp): unknown {
    const obj: any = {};
    if (message.toUin !== undefined) {
      obj.toUin = Math.round(message.toUin);
    }
    if (message.sig !== undefined) {
      obj.sig = base64FromBytes(message.sig);
    }
    if (message.reply !== undefined) {
      obj.reply = message.reply;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<AccostTmp>, I>>(base?: I): AccostTmp {
    return AccostTmp.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<AccostTmp>, I>>(object: I): AccostTmp {
    const message = createBaseAccostTmp();
    message.toUin = object.toUin ?? undefined;
    message.sig = object.sig ?? undefined;
    message.reply = object.reply ?? undefined;
    return message;
  },
};

function createBaseAddressListTmp(): AddressListTmp {
  return { fromPhone: undefined, toPhone: undefined, toUin: undefined, sig: undefined, fromContactSize: undefined };
}

export const AddressListTmp: MessageFns<AddressListTmp> = {
  encode(message: AddressListTmp, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.fromPhone !== undefined) {
      writer.uint32(10).string(message.fromPhone);
    }
    if (message.toPhone !== undefined) {
      writer.uint32(18).string(message.toPhone);
    }
    if (message.toUin !== undefined) {
      writer.uint32(24).uint64(message.toUin);
    }
    if (message.sig !== undefined) {
      writer.uint32(34).bytes(message.sig);
    }
    if (message.fromContactSize !== undefined) {
      writer.uint32(40).uint32(message.fromContactSize);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AddressListTmp {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAddressListTmp();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.fromPhone = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.toPhone = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.toUin = longToNumber(reader.uint64());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.sig = reader.bytes();
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.fromContactSize = reader.uint32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AddressListTmp {
    return {
      fromPhone: isSet(object.fromPhone) ? globalThis.String(object.fromPhone) : undefined,
      toPhone: isSet(object.toPhone) ? globalThis.String(object.toPhone) : undefined,
      toUin: isSet(object.toUin) ? globalThis.Number(object.toUin) : undefined,
      sig: isSet(object.sig) ? bytesFromBase64(object.sig) : undefined,
      fromContactSize: isSet(object.fromContactSize) ? globalThis.Number(object.fromContactSize) : undefined,
    };
  },

  toJSON(message: AddressListTmp): unknown {
    const obj: any = {};
    if (message.fromPhone !== undefined) {
      obj.fromPhone = message.fromPhone;
    }
    if (message.toPhone !== undefined) {
      obj.toPhone = message.toPhone;
    }
    if (message.toUin !== undefined) {
      obj.toUin = Math.round(message.toUin);
    }
    if (message.sig !== undefined) {
      obj.sig = base64FromBytes(message.sig);
    }
    if (message.fromContactSize !== undefined) {
      obj.fromContactSize = Math.round(message.fromContactSize);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<AddressListTmp>, I>>(base?: I): AddressListTmp {
    return AddressListTmp.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<AddressListTmp>, I>>(object: I): AddressListTmp {
    const message = createBaseAddressListTmp();
    message.fromPhone = object.fromPhone ?? undefined;
    message.toPhone = object.toPhone ?? undefined;
    message.toUin = object.toUin ?? undefined;
    message.sig = object.sig ?? undefined;
    message.fromContactSize = object.fromContactSize ?? undefined;
    return message;
  },
};

function createBaseAuthTmp(): AuthTmp {
  return { toUin: undefined, sig: undefined };
}

export const AuthTmp: MessageFns<AuthTmp> = {
  encode(message: AuthTmp, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.toUin !== undefined) {
      writer.uint32(8).uint64(message.toUin);
    }
    if (message.sig !== undefined) {
      writer.uint32(18).bytes(message.sig);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AuthTmp {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAuthTmp();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.toUin = longToNumber(reader.uint64());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.sig = reader.bytes();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AuthTmp {
    return {
      toUin: isSet(object.toUin) ? globalThis.Number(object.toUin) : undefined,
      sig: isSet(object.sig) ? bytesFromBase64(object.sig) : undefined,
    };
  },

  toJSON(message: AuthTmp): unknown {
    const obj: any = {};
    if (message.toUin !== undefined) {
      obj.toUin = Math.round(message.toUin);
    }
    if (message.sig !== undefined) {
      obj.sig = base64FromBytes(message.sig);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<AuthTmp>, I>>(base?: I): AuthTmp {
    return AuthTmp.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<AuthTmp>, I>>(object: I): AuthTmp {
    const message = createBaseAuthTmp();
    message.toUin = object.toUin ?? undefined;
    message.sig = object.sig ?? undefined;
    return message;
  },
};

function createBaseBsnsTmp(): BsnsTmp {
  return { toUin: undefined, sig: undefined };
}

export const BsnsTmp: MessageFns<BsnsTmp> = {
  encode(message: BsnsTmp, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.toUin !== undefined) {
      writer.uint32(8).uint64(message.toUin);
    }
    if (message.sig !== undefined) {
      writer.uint32(18).bytes(message.sig);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): BsnsTmp {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBsnsTmp();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.toUin = longToNumber(reader.uint64());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.sig = reader.bytes();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): BsnsTmp {
    return {
      toUin: isSet(object.toUin) ? globalThis.Number(object.toUin) : undefined,
      sig: isSet(object.sig) ? bytesFromBase64(object.sig) : undefined,
    };
  },

  toJSON(message: BsnsTmp): unknown {
    const obj: any = {};
    if (message.toUin !== undefined) {
      obj.toUin = Math.round(message.toUin);
    }
    if (message.sig !== undefined) {
      obj.sig = base64FromBytes(message.sig);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<BsnsTmp>, I>>(base?: I): BsnsTmp {
    return BsnsTmp.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<BsnsTmp>, I>>(object: I): BsnsTmp {
    const message = createBaseBsnsTmp();
    message.toUin = object.toUin ?? undefined;
    message.sig = object.sig ?? undefined;
    return message;
  },
};

function createBaseBusinessWPATmp(): BusinessWPATmp {
  return { toUin: undefined, sig: undefined, sigt: undefined };
}

export const BusinessWPATmp: MessageFns<BusinessWPATmp> = {
  encode(message: BusinessWPATmp, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.toUin !== undefined) {
      writer.uint32(8).uint64(message.toUin);
    }
    if (message.sig !== undefined) {
      writer.uint32(18).bytes(message.sig);
    }
    if (message.sigt !== undefined) {
      writer.uint32(26).bytes(message.sigt);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): BusinessWPATmp {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBusinessWPATmp();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.toUin = longToNumber(reader.uint64());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.sig = reader.bytes();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.sigt = reader.bytes();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): BusinessWPATmp {
    return {
      toUin: isSet(object.toUin) ? globalThis.Number(object.toUin) : undefined,
      sig: isSet(object.sig) ? bytesFromBase64(object.sig) : undefined,
      sigt: isSet(object.sigt) ? bytesFromBase64(object.sigt) : undefined,
    };
  },

  toJSON(message: BusinessWPATmp): unknown {
    const obj: any = {};
    if (message.toUin !== undefined) {
      obj.toUin = Math.round(message.toUin);
    }
    if (message.sig !== undefined) {
      obj.sig = base64FromBytes(message.sig);
    }
    if (message.sigt !== undefined) {
      obj.sigt = base64FromBytes(message.sigt);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<BusinessWPATmp>, I>>(base?: I): BusinessWPATmp {
    return BusinessWPATmp.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<BusinessWPATmp>, I>>(object: I): BusinessWPATmp {
    const message = createBaseBusinessWPATmp();
    message.toUin = object.toUin ?? undefined;
    message.sig = object.sig ?? undefined;
    message.sigt = object.sigt ?? undefined;
    return message;
  },
};

function createBaseC2C(): C2C {
  return { toUin: undefined };
}

export const C2C: MessageFns<C2C> = {
  encode(message: C2C, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.toUin !== undefined) {
      writer.uint32(8).uint64(message.toUin);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): C2C {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseC2C();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.toUin = longToNumber(reader.uint64());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): C2C {
    return { toUin: isSet(object.toUin) ? globalThis.Number(object.toUin) : undefined };
  },

  toJSON(message: C2C): unknown {
    const obj: any = {};
    if (message.toUin !== undefined) {
      obj.toUin = Math.round(message.toUin);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<C2C>, I>>(base?: I): C2C {
    return C2C.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<C2C>, I>>(object: I): C2C {
    const message = createBaseC2C();
    message.toUin = object.toUin ?? undefined;
    return message;
  },
};

function createBaseCommTmp(): CommTmp {
  return { toUin: undefined, c2cType: undefined, svrType: undefined, sig: undefined, reserved: undefined };
}

export const CommTmp: MessageFns<CommTmp> = {
  encode(message: CommTmp, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.toUin !== undefined) {
      writer.uint32(8).uint64(message.toUin);
    }
    if (message.c2cType !== undefined) {
      writer.uint32(16).uint32(message.c2cType);
    }
    if (message.svrType !== undefined) {
      writer.uint32(24).uint32(message.svrType);
    }
    if (message.sig !== undefined) {
      writer.uint32(34).bytes(message.sig);
    }
    if (message.reserved !== undefined) {
      writer.uint32(42).bytes(message.reserved);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CommTmp {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCommTmp();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.toUin = longToNumber(reader.uint64());
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.c2cType = reader.uint32();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.svrType = reader.uint32();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.sig = reader.bytes();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.reserved = reader.bytes();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CommTmp {
    return {
      toUin: isSet(object.toUin) ? globalThis.Number(object.toUin) : undefined,
      c2cType: isSet(object.c2cType) ? globalThis.Number(object.c2cType) : undefined,
      svrType: isSet(object.svrType) ? globalThis.Number(object.svrType) : undefined,
      sig: isSet(object.sig) ? bytesFromBase64(object.sig) : undefined,
      reserved: isSet(object.reserved) ? bytesFromBase64(object.reserved) : undefined,
    };
  },

  toJSON(message: CommTmp): unknown {
    const obj: any = {};
    if (message.toUin !== undefined) {
      obj.toUin = Math.round(message.toUin);
    }
    if (message.c2cType !== undefined) {
      obj.c2cType = Math.round(message.c2cType);
    }
    if (message.svrType !== undefined) {
      obj.svrType = Math.round(message.svrType);
    }
    if (message.sig !== undefined) {
      obj.sig = base64FromBytes(message.sig);
    }
    if (message.reserved !== undefined) {
      obj.reserved = base64FromBytes(message.reserved);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CommTmp>, I>>(base?: I): CommTmp {
    return CommTmp.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CommTmp>, I>>(object: I): CommTmp {
    const message = createBaseCommTmp();
    message.toUin = object.toUin ?? undefined;
    message.c2cType = object.c2cType ?? undefined;
    message.svrType = object.svrType ?? undefined;
    message.sig = object.sig ?? undefined;
    message.reserved = object.reserved ?? undefined;
    return message;
  },
};

function createBaseDis(): Dis {
  return { disUin: undefined };
}

export const Dis: MessageFns<Dis> = {
  encode(message: Dis, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.disUin !== undefined) {
      writer.uint32(8).uint64(message.disUin);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Dis {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDis();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.disUin = longToNumber(reader.uint64());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Dis {
    return { disUin: isSet(object.disUin) ? globalThis.Number(object.disUin) : undefined };
  },

  toJSON(message: Dis): unknown {
    const obj: any = {};
    if (message.disUin !== undefined) {
      obj.disUin = Math.round(message.disUin);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Dis>, I>>(base?: I): Dis {
    return Dis.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Dis>, I>>(object: I): Dis {
    const message = createBaseDis();
    message.disUin = object.disUin ?? undefined;
    return message;
  },
};

function createBaseDisTmp(): DisTmp {
  return { disUin: undefined, toUin: undefined };
}

export const DisTmp: MessageFns<DisTmp> = {
  encode(message: DisTmp, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.disUin !== undefined) {
      writer.uint32(8).uint64(message.disUin);
    }
    if (message.toUin !== undefined) {
      writer.uint32(16).uint64(message.toUin);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DisTmp {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDisTmp();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.disUin = longToNumber(reader.uint64());
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.toUin = longToNumber(reader.uint64());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DisTmp {
    return {
      disUin: isSet(object.disUin) ? globalThis.Number(object.disUin) : undefined,
      toUin: isSet(object.toUin) ? globalThis.Number(object.toUin) : undefined,
    };
  },

  toJSON(message: DisTmp): unknown {
    const obj: any = {};
    if (message.disUin !== undefined) {
      obj.disUin = Math.round(message.disUin);
    }
    if (message.toUin !== undefined) {
      obj.toUin = Math.round(message.toUin);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<DisTmp>, I>>(base?: I): DisTmp {
    return DisTmp.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<DisTmp>, I>>(object: I): DisTmp {
    const message = createBaseDisTmp();
    message.disUin = object.disUin ?? undefined;
    message.toUin = object.toUin ?? undefined;
    return message;
  },
};

function createBaseGrp(): Grp {
  return { groupCode: undefined };
}

export const Grp: MessageFns<Grp> = {
  encode(message: Grp, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.groupCode !== undefined) {
      writer.uint32(8).uint64(message.groupCode);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Grp {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGrp();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.groupCode = longToNumber(reader.uint64());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Grp {
    return { groupCode: isSet(object.groupCode) ? globalThis.Number(object.groupCode) : undefined };
  },

  toJSON(message: Grp): unknown {
    const obj: any = {};
    if (message.groupCode !== undefined) {
      obj.groupCode = Math.round(message.groupCode);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Grp>, I>>(base?: I): Grp {
    return Grp.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Grp>, I>>(object: I): Grp {
    const message = createBaseGrp();
    message.groupCode = object.groupCode ?? undefined;
    return message;
  },
};

function createBaseGrpTmp(): GrpTmp {
  return { groupUin: undefined, toUin: undefined };
}

export const GrpTmp: MessageFns<GrpTmp> = {
  encode(message: GrpTmp, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.groupUin !== undefined) {
      writer.uint32(8).uint64(message.groupUin);
    }
    if (message.toUin !== undefined) {
      writer.uint32(16).uint64(message.toUin);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GrpTmp {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGrpTmp();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.groupUin = longToNumber(reader.uint64());
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.toUin = longToNumber(reader.uint64());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GrpTmp {
    return {
      groupUin: isSet(object.groupUin) ? globalThis.Number(object.groupUin) : undefined,
      toUin: isSet(object.toUin) ? globalThis.Number(object.toUin) : undefined,
    };
  },

  toJSON(message: GrpTmp): unknown {
    const obj: any = {};
    if (message.groupUin !== undefined) {
      obj.groupUin = Math.round(message.groupUin);
    }
    if (message.toUin !== undefined) {
      obj.toUin = Math.round(message.toUin);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GrpTmp>, I>>(base?: I): GrpTmp {
    return GrpTmp.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GrpTmp>, I>>(object: I): GrpTmp {
    const message = createBaseGrpTmp();
    message.groupUin = object.groupUin ?? undefined;
    message.toUin = object.toUin ?? undefined;
    return message;
  },
};

function createBaseMsgSendInfo(): MsgSendInfo {
  return { receiver: undefined };
}

export const MsgSendInfo: MessageFns<MsgSendInfo> = {
  encode(message: MsgSendInfo, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.receiver !== undefined) {
      writer.uint32(8).uint32(message.receiver);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgSendInfo {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgSendInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.receiver = reader.uint32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MsgSendInfo {
    return { receiver: isSet(object.receiver) ? globalThis.Number(object.receiver) : undefined };
  },

  toJSON(message: MsgSendInfo): unknown {
    const obj: any = {};
    if (message.receiver !== undefined) {
      obj.receiver = Math.round(message.receiver);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MsgSendInfo>, I>>(base?: I): MsgSendInfo {
    return MsgSendInfo.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MsgSendInfo>, I>>(object: I): MsgSendInfo {
    const message = createBaseMsgSendInfo();
    message.receiver = object.receiver ?? undefined;
    return message;
  },
};

function createBaseMultiMsgAssist(): MultiMsgAssist {
  return {
    repeatedRouting: [],
    msgUse: undefined,
    uint64TempId: undefined,
    uint64VedioLen: undefined,
    bytesRedbagId: undefined,
    uint64RedbagAmount: undefined,
    uint32HasReadbag: undefined,
    uint32HasVedio: undefined,
  };
}

export const MultiMsgAssist: MessageFns<MultiMsgAssist> = {
  encode(message: MultiMsgAssist, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.repeatedRouting) {
      RoutingHead.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.msgUse !== undefined) {
      writer.uint32(16).int32(message.msgUse);
    }
    if (message.uint64TempId !== undefined) {
      writer.uint32(24).uint64(message.uint64TempId);
    }
    if (message.uint64VedioLen !== undefined) {
      writer.uint32(32).uint64(message.uint64VedioLen);
    }
    if (message.bytesRedbagId !== undefined) {
      writer.uint32(42).bytes(message.bytesRedbagId);
    }
    if (message.uint64RedbagAmount !== undefined) {
      writer.uint32(48).uint64(message.uint64RedbagAmount);
    }
    if (message.uint32HasReadbag !== undefined) {
      writer.uint32(56).uint32(message.uint32HasReadbag);
    }
    if (message.uint32HasVedio !== undefined) {
      writer.uint32(64).uint32(message.uint32HasVedio);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MultiMsgAssist {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMultiMsgAssist();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.repeatedRouting.push(RoutingHead.decode(reader, reader.uint32()));
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.msgUse = reader.int32();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.uint64TempId = longToNumber(reader.uint64());
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.uint64VedioLen = longToNumber(reader.uint64());
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.bytesRedbagId = reader.bytes();
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.uint64RedbagAmount = longToNumber(reader.uint64());
          continue;
        }
        case 7: {
          if (tag !== 56) {
            break;
          }

          message.uint32HasReadbag = reader.uint32();
          continue;
        }
        case 8: {
          if (tag !== 64) {
            break;
          }

          message.uint32HasVedio = reader.uint32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MultiMsgAssist {
    return {
      repeatedRouting: globalThis.Array.isArray(object?.repeatedRouting)
        ? object.repeatedRouting.map((e: any) => RoutingHead.fromJSON(e))
        : [],
      msgUse: isSet(object.msgUse) ? globalThis.Number(object.msgUse) : undefined,
      uint64TempId: isSet(object.uint64TempId) ? globalThis.Number(object.uint64TempId) : undefined,
      uint64VedioLen: isSet(object.uint64VedioLen) ? globalThis.Number(object.uint64VedioLen) : undefined,
      bytesRedbagId: isSet(object.bytesRedbagId) ? bytesFromBase64(object.bytesRedbagId) : undefined,
      uint64RedbagAmount: isSet(object.uint64RedbagAmount) ? globalThis.Number(object.uint64RedbagAmount) : undefined,
      uint32HasReadbag: isSet(object.uint32HasReadbag) ? globalThis.Number(object.uint32HasReadbag) : undefined,
      uint32HasVedio: isSet(object.uint32HasVedio) ? globalThis.Number(object.uint32HasVedio) : undefined,
    };
  },

  toJSON(message: MultiMsgAssist): unknown {
    const obj: any = {};
    if (message.repeatedRouting?.length) {
      obj.repeatedRouting = message.repeatedRouting.map((e) => RoutingHead.toJSON(e));
    }
    if (message.msgUse !== undefined) {
      obj.msgUse = Math.round(message.msgUse);
    }
    if (message.uint64TempId !== undefined) {
      obj.uint64TempId = Math.round(message.uint64TempId);
    }
    if (message.uint64VedioLen !== undefined) {
      obj.uint64VedioLen = Math.round(message.uint64VedioLen);
    }
    if (message.bytesRedbagId !== undefined) {
      obj.bytesRedbagId = base64FromBytes(message.bytesRedbagId);
    }
    if (message.uint64RedbagAmount !== undefined) {
      obj.uint64RedbagAmount = Math.round(message.uint64RedbagAmount);
    }
    if (message.uint32HasReadbag !== undefined) {
      obj.uint32HasReadbag = Math.round(message.uint32HasReadbag);
    }
    if (message.uint32HasVedio !== undefined) {
      obj.uint32HasVedio = Math.round(message.uint32HasVedio);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MultiMsgAssist>, I>>(base?: I): MultiMsgAssist {
    return MultiMsgAssist.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MultiMsgAssist>, I>>(object: I): MultiMsgAssist {
    const message = createBaseMultiMsgAssist();
    message.repeatedRouting = object.repeatedRouting?.map((e) => RoutingHead.fromPartial(e)) || [];
    message.msgUse = object.msgUse ?? undefined;
    message.uint64TempId = object.uint64TempId ?? undefined;
    message.uint64VedioLen = object.uint64VedioLen ?? undefined;
    message.bytesRedbagId = object.bytesRedbagId ?? undefined;
    message.uint64RedbagAmount = object.uint64RedbagAmount ?? undefined;
    message.uint32HasReadbag = object.uint32HasReadbag ?? undefined;
    message.uint32HasVedio = object.uint32HasVedio ?? undefined;
    return message;
  },
};

function createBaseNearByAssistantTmp(): NearByAssistantTmp {
  return { toUin: undefined, sig: undefined, reply: undefined };
}

export const NearByAssistantTmp: MessageFns<NearByAssistantTmp> = {
  encode(message: NearByAssistantTmp, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.toUin !== undefined) {
      writer.uint32(8).uint64(message.toUin);
    }
    if (message.sig !== undefined) {
      writer.uint32(18).bytes(message.sig);
    }
    if (message.reply !== undefined) {
      writer.uint32(24).bool(message.reply);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): NearByAssistantTmp {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseNearByAssistantTmp();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.toUin = longToNumber(reader.uint64());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.sig = reader.bytes();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.reply = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): NearByAssistantTmp {
    return {
      toUin: isSet(object.toUin) ? globalThis.Number(object.toUin) : undefined,
      sig: isSet(object.sig) ? bytesFromBase64(object.sig) : undefined,
      reply: isSet(object.reply) ? globalThis.Boolean(object.reply) : undefined,
    };
  },

  toJSON(message: NearByAssistantTmp): unknown {
    const obj: any = {};
    if (message.toUin !== undefined) {
      obj.toUin = Math.round(message.toUin);
    }
    if (message.sig !== undefined) {
      obj.sig = base64FromBytes(message.sig);
    }
    if (message.reply !== undefined) {
      obj.reply = message.reply;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<NearByAssistantTmp>, I>>(base?: I): NearByAssistantTmp {
    return NearByAssistantTmp.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<NearByAssistantTmp>, I>>(object: I): NearByAssistantTmp {
    const message = createBaseNearByAssistantTmp();
    message.toUin = object.toUin ?? undefined;
    message.sig = object.sig ?? undefined;
    message.reply = object.reply ?? undefined;
    return message;
  },
};

function createBaseNearByDatingTmp(): NearByDatingTmp {
  return { toUin: undefined, sig: undefined, reply: undefined };
}

export const NearByDatingTmp: MessageFns<NearByDatingTmp> = {
  encode(message: NearByDatingTmp, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.toUin !== undefined) {
      writer.uint32(8).uint64(message.toUin);
    }
    if (message.sig !== undefined) {
      writer.uint32(18).bytes(message.sig);
    }
    if (message.reply !== undefined) {
      writer.uint32(24).bool(message.reply);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): NearByDatingTmp {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseNearByDatingTmp();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.toUin = longToNumber(reader.uint64());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.sig = reader.bytes();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.reply = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): NearByDatingTmp {
    return {
      toUin: isSet(object.toUin) ? globalThis.Number(object.toUin) : undefined,
      sig: isSet(object.sig) ? bytesFromBase64(object.sig) : undefined,
      reply: isSet(object.reply) ? globalThis.Boolean(object.reply) : undefined,
    };
  },

  toJSON(message: NearByDatingTmp): unknown {
    const obj: any = {};
    if (message.toUin !== undefined) {
      obj.toUin = Math.round(message.toUin);
    }
    if (message.sig !== undefined) {
      obj.sig = base64FromBytes(message.sig);
    }
    if (message.reply !== undefined) {
      obj.reply = message.reply;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<NearByDatingTmp>, I>>(base?: I): NearByDatingTmp {
    return NearByDatingTmp.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<NearByDatingTmp>, I>>(object: I): NearByDatingTmp {
    const message = createBaseNearByDatingTmp();
    message.toUin = object.toUin ?? undefined;
    message.sig = object.sig ?? undefined;
    message.reply = object.reply ?? undefined;
    return message;
  },
};

function createBasePbBindUinGetMsgReq(): PbBindUinGetMsgReq {
  return { bindUin: undefined, bindUinSig: undefined, syncFlag: undefined, syncCookie: undefined };
}

export const PbBindUinGetMsgReq: MessageFns<PbBindUinGetMsgReq> = {
  encode(message: PbBindUinGetMsgReq, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.bindUin !== undefined) {
      writer.uint32(8).uint64(message.bindUin);
    }
    if (message.bindUinSig !== undefined) {
      writer.uint32(18).bytes(message.bindUinSig);
    }
    if (message.syncFlag !== undefined) {
      writer.uint32(24).int32(message.syncFlag);
    }
    if (message.syncCookie !== undefined) {
      writer.uint32(34).bytes(message.syncCookie);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PbBindUinGetMsgReq {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePbBindUinGetMsgReq();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.bindUin = longToNumber(reader.uint64());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.bindUinSig = reader.bytes();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.syncFlag = reader.int32();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.syncCookie = reader.bytes();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PbBindUinGetMsgReq {
    return {
      bindUin: isSet(object.bindUin) ? globalThis.Number(object.bindUin) : undefined,
      bindUinSig: isSet(object.bindUinSig) ? bytesFromBase64(object.bindUinSig) : undefined,
      syncFlag: isSet(object.syncFlag) ? globalThis.Number(object.syncFlag) : undefined,
      syncCookie: isSet(object.syncCookie) ? bytesFromBase64(object.syncCookie) : undefined,
    };
  },

  toJSON(message: PbBindUinGetMsgReq): unknown {
    const obj: any = {};
    if (message.bindUin !== undefined) {
      obj.bindUin = Math.round(message.bindUin);
    }
    if (message.bindUinSig !== undefined) {
      obj.bindUinSig = base64FromBytes(message.bindUinSig);
    }
    if (message.syncFlag !== undefined) {
      obj.syncFlag = Math.round(message.syncFlag);
    }
    if (message.syncCookie !== undefined) {
      obj.syncCookie = base64FromBytes(message.syncCookie);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<PbBindUinGetMsgReq>, I>>(base?: I): PbBindUinGetMsgReq {
    return PbBindUinGetMsgReq.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<PbBindUinGetMsgReq>, I>>(object: I): PbBindUinGetMsgReq {
    const message = createBasePbBindUinGetMsgReq();
    message.bindUin = object.bindUin ?? undefined;
    message.bindUinSig = object.bindUinSig ?? undefined;
    message.syncFlag = object.syncFlag ?? undefined;
    message.syncCookie = object.syncCookie ?? undefined;
    return message;
  },
};

function createBasePbBindUinMsgReadedConfirmReq(): PbBindUinMsgReadedConfirmReq {
  return { syncCookie: undefined, bindUin: undefined };
}

export const PbBindUinMsgReadedConfirmReq: MessageFns<PbBindUinMsgReadedConfirmReq> = {
  encode(message: PbBindUinMsgReadedConfirmReq, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.syncCookie !== undefined) {
      writer.uint32(10).bytes(message.syncCookie);
    }
    if (message.bindUin !== undefined) {
      writer.uint32(16).uint64(message.bindUin);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PbBindUinMsgReadedConfirmReq {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePbBindUinMsgReadedConfirmReq();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.syncCookie = reader.bytes();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.bindUin = longToNumber(reader.uint64());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PbBindUinMsgReadedConfirmReq {
    return {
      syncCookie: isSet(object.syncCookie) ? bytesFromBase64(object.syncCookie) : undefined,
      bindUin: isSet(object.bindUin) ? globalThis.Number(object.bindUin) : undefined,
    };
  },

  toJSON(message: PbBindUinMsgReadedConfirmReq): unknown {
    const obj: any = {};
    if (message.syncCookie !== undefined) {
      obj.syncCookie = base64FromBytes(message.syncCookie);
    }
    if (message.bindUin !== undefined) {
      obj.bindUin = Math.round(message.bindUin);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<PbBindUinMsgReadedConfirmReq>, I>>(base?: I): PbBindUinMsgReadedConfirmReq {
    return PbBindUinMsgReadedConfirmReq.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<PbBindUinMsgReadedConfirmReq>, I>>(object: I): PbBindUinMsgReadedConfirmReq {
    const message = createBasePbBindUinMsgReadedConfirmReq();
    message.syncCookie = object.syncCookie ?? undefined;
    message.bindUin = object.bindUin ?? undefined;
    return message;
  },
};

function createBasePbBindUinMsgReadedConfirmResp(): PbBindUinMsgReadedConfirmResp {
  return { result: undefined, errmsg: undefined, syncCookie: undefined, bindUin: undefined };
}

export const PbBindUinMsgReadedConfirmResp: MessageFns<PbBindUinMsgReadedConfirmResp> = {
  encode(message: PbBindUinMsgReadedConfirmResp, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.result !== undefined) {
      writer.uint32(8).uint32(message.result);
    }
    if (message.errmsg !== undefined) {
      writer.uint32(18).string(message.errmsg);
    }
    if (message.syncCookie !== undefined) {
      writer.uint32(26).bytes(message.syncCookie);
    }
    if (message.bindUin !== undefined) {
      writer.uint32(32).uint64(message.bindUin);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PbBindUinMsgReadedConfirmResp {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePbBindUinMsgReadedConfirmResp();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.result = reader.uint32();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.errmsg = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.syncCookie = reader.bytes();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.bindUin = longToNumber(reader.uint64());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PbBindUinMsgReadedConfirmResp {
    return {
      result: isSet(object.result) ? globalThis.Number(object.result) : undefined,
      errmsg: isSet(object.errmsg) ? globalThis.String(object.errmsg) : undefined,
      syncCookie: isSet(object.syncCookie) ? bytesFromBase64(object.syncCookie) : undefined,
      bindUin: isSet(object.bindUin) ? globalThis.Number(object.bindUin) : undefined,
    };
  },

  toJSON(message: PbBindUinMsgReadedConfirmResp): unknown {
    const obj: any = {};
    if (message.result !== undefined) {
      obj.result = Math.round(message.result);
    }
    if (message.errmsg !== undefined) {
      obj.errmsg = message.errmsg;
    }
    if (message.syncCookie !== undefined) {
      obj.syncCookie = base64FromBytes(message.syncCookie);
    }
    if (message.bindUin !== undefined) {
      obj.bindUin = Math.round(message.bindUin);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<PbBindUinMsgReadedConfirmResp>, I>>(base?: I): PbBindUinMsgReadedConfirmResp {
    return PbBindUinMsgReadedConfirmResp.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<PbBindUinMsgReadedConfirmResp>, I>>(
    object: I,
  ): PbBindUinMsgReadedConfirmResp {
    const message = createBasePbBindUinMsgReadedConfirmResp();
    message.result = object.result ?? undefined;
    message.errmsg = object.errmsg ?? undefined;
    message.syncCookie = object.syncCookie ?? undefined;
    message.bindUin = object.bindUin ?? undefined;
    return message;
  },
};

function createBasePbBindUinUnReadMsgNumReq(): PbBindUinUnReadMsgNumReq {
  return { bindUin: undefined, syncCookie: undefined };
}

export const PbBindUinUnReadMsgNumReq: MessageFns<PbBindUinUnReadMsgNumReq> = {
  encode(message: PbBindUinUnReadMsgNumReq, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.bindUin !== undefined) {
      writer.uint32(8).uint64(message.bindUin);
    }
    if (message.syncCookie !== undefined) {
      writer.uint32(18).bytes(message.syncCookie);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PbBindUinUnReadMsgNumReq {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePbBindUinUnReadMsgNumReq();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.bindUin = longToNumber(reader.uint64());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.syncCookie = reader.bytes();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PbBindUinUnReadMsgNumReq {
    return {
      bindUin: isSet(object.bindUin) ? globalThis.Number(object.bindUin) : undefined,
      syncCookie: isSet(object.syncCookie) ? bytesFromBase64(object.syncCookie) : undefined,
    };
  },

  toJSON(message: PbBindUinUnReadMsgNumReq): unknown {
    const obj: any = {};
    if (message.bindUin !== undefined) {
      obj.bindUin = Math.round(message.bindUin);
    }
    if (message.syncCookie !== undefined) {
      obj.syncCookie = base64FromBytes(message.syncCookie);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<PbBindUinUnReadMsgNumReq>, I>>(base?: I): PbBindUinUnReadMsgNumReq {
    return PbBindUinUnReadMsgNumReq.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<PbBindUinUnReadMsgNumReq>, I>>(object: I): PbBindUinUnReadMsgNumReq {
    const message = createBasePbBindUinUnReadMsgNumReq();
    message.bindUin = object.bindUin ?? undefined;
    message.syncCookie = object.syncCookie ?? undefined;
    return message;
  },
};

function createBasePbBindUinUnReadMsgNumResp(): PbBindUinUnReadMsgNumResp {
  return { result: undefined, errmsg: undefined, bindUin: undefined, msgNum: undefined };
}

export const PbBindUinUnReadMsgNumResp: MessageFns<PbBindUinUnReadMsgNumResp> = {
  encode(message: PbBindUinUnReadMsgNumResp, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.result !== undefined) {
      writer.uint32(8).uint32(message.result);
    }
    if (message.errmsg !== undefined) {
      writer.uint32(18).string(message.errmsg);
    }
    if (message.bindUin !== undefined) {
      writer.uint32(24).uint64(message.bindUin);
    }
    if (message.msgNum !== undefined) {
      writer.uint32(32).uint32(message.msgNum);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PbBindUinUnReadMsgNumResp {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePbBindUinUnReadMsgNumResp();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.result = reader.uint32();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.errmsg = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.bindUin = longToNumber(reader.uint64());
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.msgNum = reader.uint32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PbBindUinUnReadMsgNumResp {
    return {
      result: isSet(object.result) ? globalThis.Number(object.result) : undefined,
      errmsg: isSet(object.errmsg) ? globalThis.String(object.errmsg) : undefined,
      bindUin: isSet(object.bindUin) ? globalThis.Number(object.bindUin) : undefined,
      msgNum: isSet(object.msgNum) ? globalThis.Number(object.msgNum) : undefined,
    };
  },

  toJSON(message: PbBindUinUnReadMsgNumResp): unknown {
    const obj: any = {};
    if (message.result !== undefined) {
      obj.result = Math.round(message.result);
    }
    if (message.errmsg !== undefined) {
      obj.errmsg = message.errmsg;
    }
    if (message.bindUin !== undefined) {
      obj.bindUin = Math.round(message.bindUin);
    }
    if (message.msgNum !== undefined) {
      obj.msgNum = Math.round(message.msgNum);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<PbBindUinUnReadMsgNumResp>, I>>(base?: I): PbBindUinUnReadMsgNumResp {
    return PbBindUinUnReadMsgNumResp.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<PbBindUinUnReadMsgNumResp>, I>>(object: I): PbBindUinUnReadMsgNumResp {
    const message = createBasePbBindUinUnReadMsgNumResp();
    message.result = object.result ?? undefined;
    message.errmsg = object.errmsg ?? undefined;
    message.bindUin = object.bindUin ?? undefined;
    message.msgNum = object.msgNum ?? undefined;
    return message;
  },
};

function createBasePbC2CMsgWithDrawReqMsgInfo(): PbC2CMsgWithDrawReqMsgInfo {
  return {
    uint64FromUin: undefined,
    uint64ToUin: undefined,
    uint32MsgSeq: undefined,
    uint64MsgUid: undefined,
    uint64MsgTime: undefined,
    uint32MsgRandom: undefined,
    uint32PkgNum: undefined,
    uint32PkgIndex: undefined,
    uint32DivSeq: undefined,
    uint32MsgType: undefined,
    routingHead: undefined,
  };
}

export const PbC2CMsgWithDrawReqMsgInfo: MessageFns<PbC2CMsgWithDrawReqMsgInfo> = {
  encode(message: PbC2CMsgWithDrawReqMsgInfo, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.uint64FromUin !== undefined) {
      writer.uint32(8).uint64(message.uint64FromUin);
    }
    if (message.uint64ToUin !== undefined) {
      writer.uint32(16).uint64(message.uint64ToUin);
    }
    if (message.uint32MsgSeq !== undefined) {
      writer.uint32(24).uint32(message.uint32MsgSeq);
    }
    if (message.uint64MsgUid !== undefined) {
      writer.uint32(32).uint64(message.uint64MsgUid);
    }
    if (message.uint64MsgTime !== undefined) {
      writer.uint32(40).uint64(message.uint64MsgTime);
    }
    if (message.uint32MsgRandom !== undefined) {
      writer.uint32(48).uint32(message.uint32MsgRandom);
    }
    if (message.uint32PkgNum !== undefined) {
      writer.uint32(56).uint32(message.uint32PkgNum);
    }
    if (message.uint32PkgIndex !== undefined) {
      writer.uint32(64).uint32(message.uint32PkgIndex);
    }
    if (message.uint32DivSeq !== undefined) {
      writer.uint32(72).uint32(message.uint32DivSeq);
    }
    if (message.uint32MsgType !== undefined) {
      writer.uint32(80).uint32(message.uint32MsgType);
    }
    if (message.routingHead !== undefined) {
      RoutingHead.encode(message.routingHead, writer.uint32(90).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PbC2CMsgWithDrawReqMsgInfo {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePbC2CMsgWithDrawReqMsgInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.uint64FromUin = longToNumber(reader.uint64());
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.uint64ToUin = longToNumber(reader.uint64());
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.uint32MsgSeq = reader.uint32();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.uint64MsgUid = longToNumber(reader.uint64());
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.uint64MsgTime = longToNumber(reader.uint64());
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.uint32MsgRandom = reader.uint32();
          continue;
        }
        case 7: {
          if (tag !== 56) {
            break;
          }

          message.uint32PkgNum = reader.uint32();
          continue;
        }
        case 8: {
          if (tag !== 64) {
            break;
          }

          message.uint32PkgIndex = reader.uint32();
          continue;
        }
        case 9: {
          if (tag !== 72) {
            break;
          }

          message.uint32DivSeq = reader.uint32();
          continue;
        }
        case 10: {
          if (tag !== 80) {
            break;
          }

          message.uint32MsgType = reader.uint32();
          continue;
        }
        case 11: {
          if (tag !== 90) {
            break;
          }

          message.routingHead = RoutingHead.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PbC2CMsgWithDrawReqMsgInfo {
    return {
      uint64FromUin: isSet(object.uint64FromUin) ? globalThis.Number(object.uint64FromUin) : undefined,
      uint64ToUin: isSet(object.uint64ToUin) ? globalThis.Number(object.uint64ToUin) : undefined,
      uint32MsgSeq: isSet(object.uint32MsgSeq) ? globalThis.Number(object.uint32MsgSeq) : undefined,
      uint64MsgUid: isSet(object.uint64MsgUid) ? globalThis.Number(object.uint64MsgUid) : undefined,
      uint64MsgTime: isSet(object.uint64MsgTime) ? globalThis.Number(object.uint64MsgTime) : undefined,
      uint32MsgRandom: isSet(object.uint32MsgRandom) ? globalThis.Number(object.uint32MsgRandom) : undefined,
      uint32PkgNum: isSet(object.uint32PkgNum) ? globalThis.Number(object.uint32PkgNum) : undefined,
      uint32PkgIndex: isSet(object.uint32PkgIndex) ? globalThis.Number(object.uint32PkgIndex) : undefined,
      uint32DivSeq: isSet(object.uint32DivSeq) ? globalThis.Number(object.uint32DivSeq) : undefined,
      uint32MsgType: isSet(object.uint32MsgType) ? globalThis.Number(object.uint32MsgType) : undefined,
      routingHead: isSet(object.routingHead) ? RoutingHead.fromJSON(object.routingHead) : undefined,
    };
  },

  toJSON(message: PbC2CMsgWithDrawReqMsgInfo): unknown {
    const obj: any = {};
    if (message.uint64FromUin !== undefined) {
      obj.uint64FromUin = Math.round(message.uint64FromUin);
    }
    if (message.uint64ToUin !== undefined) {
      obj.uint64ToUin = Math.round(message.uint64ToUin);
    }
    if (message.uint32MsgSeq !== undefined) {
      obj.uint32MsgSeq = Math.round(message.uint32MsgSeq);
    }
    if (message.uint64MsgUid !== undefined) {
      obj.uint64MsgUid = Math.round(message.uint64MsgUid);
    }
    if (message.uint64MsgTime !== undefined) {
      obj.uint64MsgTime = Math.round(message.uint64MsgTime);
    }
    if (message.uint32MsgRandom !== undefined) {
      obj.uint32MsgRandom = Math.round(message.uint32MsgRandom);
    }
    if (message.uint32PkgNum !== undefined) {
      obj.uint32PkgNum = Math.round(message.uint32PkgNum);
    }
    if (message.uint32PkgIndex !== undefined) {
      obj.uint32PkgIndex = Math.round(message.uint32PkgIndex);
    }
    if (message.uint32DivSeq !== undefined) {
      obj.uint32DivSeq = Math.round(message.uint32DivSeq);
    }
    if (message.uint32MsgType !== undefined) {
      obj.uint32MsgType = Math.round(message.uint32MsgType);
    }
    if (message.routingHead !== undefined) {
      obj.routingHead = RoutingHead.toJSON(message.routingHead);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<PbC2CMsgWithDrawReqMsgInfo>, I>>(base?: I): PbC2CMsgWithDrawReqMsgInfo {
    return PbC2CMsgWithDrawReqMsgInfo.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<PbC2CMsgWithDrawReqMsgInfo>, I>>(object: I): PbC2CMsgWithDrawReqMsgInfo {
    const message = createBasePbC2CMsgWithDrawReqMsgInfo();
    message.uint64FromUin = object.uint64FromUin ?? undefined;
    message.uint64ToUin = object.uint64ToUin ?? undefined;
    message.uint32MsgSeq = object.uint32MsgSeq ?? undefined;
    message.uint64MsgUid = object.uint64MsgUid ?? undefined;
    message.uint64MsgTime = object.uint64MsgTime ?? undefined;
    message.uint32MsgRandom = object.uint32MsgRandom ?? undefined;
    message.uint32PkgNum = object.uint32PkgNum ?? undefined;
    message.uint32PkgIndex = object.uint32PkgIndex ?? undefined;
    message.uint32DivSeq = object.uint32DivSeq ?? undefined;
    message.uint32MsgType = object.uint32MsgType ?? undefined;
    message.routingHead = (object.routingHead !== undefined && object.routingHead !== null)
      ? RoutingHead.fromPartial(object.routingHead)
      : undefined;
    return message;
  },
};

function createBasePbC2CMsgWithDrawReq(): PbC2CMsgWithDrawReq {
  return { msgInfo: [], uint32LongMessageFlag: undefined, bytesReserved: undefined, uint32SubCmd: undefined };
}

export const PbC2CMsgWithDrawReq: MessageFns<PbC2CMsgWithDrawReq> = {
  encode(message: PbC2CMsgWithDrawReq, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.msgInfo) {
      PbC2CMsgWithDrawReqMsgInfo.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.uint32LongMessageFlag !== undefined) {
      writer.uint32(16).uint32(message.uint32LongMessageFlag);
    }
    if (message.bytesReserved !== undefined) {
      writer.uint32(26).bytes(message.bytesReserved);
    }
    if (message.uint32SubCmd !== undefined) {
      writer.uint32(32).uint32(message.uint32SubCmd);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PbC2CMsgWithDrawReq {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePbC2CMsgWithDrawReq();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.msgInfo.push(PbC2CMsgWithDrawReqMsgInfo.decode(reader, reader.uint32()));
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.uint32LongMessageFlag = reader.uint32();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.bytesReserved = reader.bytes();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.uint32SubCmd = reader.uint32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PbC2CMsgWithDrawReq {
    return {
      msgInfo: globalThis.Array.isArray(object?.msgInfo)
        ? object.msgInfo.map((e: any) => PbC2CMsgWithDrawReqMsgInfo.fromJSON(e))
        : [],
      uint32LongMessageFlag: isSet(object.uint32LongMessageFlag)
        ? globalThis.Number(object.uint32LongMessageFlag)
        : undefined,
      bytesReserved: isSet(object.bytesReserved) ? bytesFromBase64(object.bytesReserved) : undefined,
      uint32SubCmd: isSet(object.uint32SubCmd) ? globalThis.Number(object.uint32SubCmd) : undefined,
    };
  },

  toJSON(message: PbC2CMsgWithDrawReq): unknown {
    const obj: any = {};
    if (message.msgInfo?.length) {
      obj.msgInfo = message.msgInfo.map((e) => PbC2CMsgWithDrawReqMsgInfo.toJSON(e));
    }
    if (message.uint32LongMessageFlag !== undefined) {
      obj.uint32LongMessageFlag = Math.round(message.uint32LongMessageFlag);
    }
    if (message.bytesReserved !== undefined) {
      obj.bytesReserved = base64FromBytes(message.bytesReserved);
    }
    if (message.uint32SubCmd !== undefined) {
      obj.uint32SubCmd = Math.round(message.uint32SubCmd);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<PbC2CMsgWithDrawReq>, I>>(base?: I): PbC2CMsgWithDrawReq {
    return PbC2CMsgWithDrawReq.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<PbC2CMsgWithDrawReq>, I>>(object: I): PbC2CMsgWithDrawReq {
    const message = createBasePbC2CMsgWithDrawReq();
    message.msgInfo = object.msgInfo?.map((e) => PbC2CMsgWithDrawReqMsgInfo.fromPartial(e)) || [];
    message.uint32LongMessageFlag = object.uint32LongMessageFlag ?? undefined;
    message.bytesReserved = object.bytesReserved ?? undefined;
    message.uint32SubCmd = object.uint32SubCmd ?? undefined;
    return message;
  },
};

function createBasePbC2CMsgWithDrawRespMsgStatus(): PbC2CMsgWithDrawRespMsgStatus {
  return { msgInfo: undefined, uint32Status: undefined };
}

export const PbC2CMsgWithDrawRespMsgStatus: MessageFns<PbC2CMsgWithDrawRespMsgStatus> = {
  encode(message: PbC2CMsgWithDrawRespMsgStatus, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.msgInfo !== undefined) {
      PbC2CMsgWithDrawReqMsgInfo.encode(message.msgInfo, writer.uint32(10).fork()).join();
    }
    if (message.uint32Status !== undefined) {
      writer.uint32(16).uint32(message.uint32Status);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PbC2CMsgWithDrawRespMsgStatus {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePbC2CMsgWithDrawRespMsgStatus();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.msgInfo = PbC2CMsgWithDrawReqMsgInfo.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.uint32Status = reader.uint32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PbC2CMsgWithDrawRespMsgStatus {
    return {
      msgInfo: isSet(object.msgInfo) ? PbC2CMsgWithDrawReqMsgInfo.fromJSON(object.msgInfo) : undefined,
      uint32Status: isSet(object.uint32Status) ? globalThis.Number(object.uint32Status) : undefined,
    };
  },

  toJSON(message: PbC2CMsgWithDrawRespMsgStatus): unknown {
    const obj: any = {};
    if (message.msgInfo !== undefined) {
      obj.msgInfo = PbC2CMsgWithDrawReqMsgInfo.toJSON(message.msgInfo);
    }
    if (message.uint32Status !== undefined) {
      obj.uint32Status = Math.round(message.uint32Status);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<PbC2CMsgWithDrawRespMsgStatus>, I>>(base?: I): PbC2CMsgWithDrawRespMsgStatus {
    return PbC2CMsgWithDrawRespMsgStatus.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<PbC2CMsgWithDrawRespMsgStatus>, I>>(
    object: I,
  ): PbC2CMsgWithDrawRespMsgStatus {
    const message = createBasePbC2CMsgWithDrawRespMsgStatus();
    message.msgInfo = (object.msgInfo !== undefined && object.msgInfo !== null)
      ? PbC2CMsgWithDrawReqMsgInfo.fromPartial(object.msgInfo)
      : undefined;
    message.uint32Status = object.uint32Status ?? undefined;
    return message;
  },
};

function createBasePbC2CMsgWithDrawResp(): PbC2CMsgWithDrawResp {
  return { result: undefined, errmsg: undefined, msgStatus: [], uint32SubCmd: undefined, msgWordingInfo: undefined };
}

export const PbC2CMsgWithDrawResp: MessageFns<PbC2CMsgWithDrawResp> = {
  encode(message: PbC2CMsgWithDrawResp, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.result !== undefined) {
      writer.uint32(8).uint32(message.result);
    }
    if (message.errmsg !== undefined) {
      writer.uint32(18).string(message.errmsg);
    }
    for (const v of message.msgStatus) {
      PbC2CMsgWithDrawRespMsgStatus.encode(v!, writer.uint32(26).fork()).join();
    }
    if (message.uint32SubCmd !== undefined) {
      writer.uint32(32).uint32(message.uint32SubCmd);
    }
    if (message.msgWordingInfo !== undefined) {
      WithDrawWordingInfo.encode(message.msgWordingInfo, writer.uint32(42).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PbC2CMsgWithDrawResp {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePbC2CMsgWithDrawResp();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.result = reader.uint32();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.errmsg = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.msgStatus.push(PbC2CMsgWithDrawRespMsgStatus.decode(reader, reader.uint32()));
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.uint32SubCmd = reader.uint32();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.msgWordingInfo = WithDrawWordingInfo.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PbC2CMsgWithDrawResp {
    return {
      result: isSet(object.result) ? globalThis.Number(object.result) : undefined,
      errmsg: isSet(object.errmsg) ? globalThis.String(object.errmsg) : undefined,
      msgStatus: globalThis.Array.isArray(object?.msgStatus)
        ? object.msgStatus.map((e: any) => PbC2CMsgWithDrawRespMsgStatus.fromJSON(e))
        : [],
      uint32SubCmd: isSet(object.uint32SubCmd) ? globalThis.Number(object.uint32SubCmd) : undefined,
      msgWordingInfo: isSet(object.msgWordingInfo) ? WithDrawWordingInfo.fromJSON(object.msgWordingInfo) : undefined,
    };
  },

  toJSON(message: PbC2CMsgWithDrawResp): unknown {
    const obj: any = {};
    if (message.result !== undefined) {
      obj.result = Math.round(message.result);
    }
    if (message.errmsg !== undefined) {
      obj.errmsg = message.errmsg;
    }
    if (message.msgStatus?.length) {
      obj.msgStatus = message.msgStatus.map((e) => PbC2CMsgWithDrawRespMsgStatus.toJSON(e));
    }
    if (message.uint32SubCmd !== undefined) {
      obj.uint32SubCmd = Math.round(message.uint32SubCmd);
    }
    if (message.msgWordingInfo !== undefined) {
      obj.msgWordingInfo = WithDrawWordingInfo.toJSON(message.msgWordingInfo);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<PbC2CMsgWithDrawResp>, I>>(base?: I): PbC2CMsgWithDrawResp {
    return PbC2CMsgWithDrawResp.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<PbC2CMsgWithDrawResp>, I>>(object: I): PbC2CMsgWithDrawResp {
    const message = createBasePbC2CMsgWithDrawResp();
    message.result = object.result ?? undefined;
    message.errmsg = object.errmsg ?? undefined;
    message.msgStatus = object.msgStatus?.map((e) => PbC2CMsgWithDrawRespMsgStatus.fromPartial(e)) || [];
    message.uint32SubCmd = object.uint32SubCmd ?? undefined;
    message.msgWordingInfo = (object.msgWordingInfo !== undefined && object.msgWordingInfo !== null)
      ? WithDrawWordingInfo.fromPartial(object.msgWordingInfo)
      : undefined;
    return message;
  },
};

function createBasePbC2CReadedReportReqUinPairReadInfo(): PbC2CReadedReportReqUinPairReadInfo {
  return {
    peerUin: undefined,
    lastReadTime: undefined,
    crmSig: undefined,
    peerType: undefined,
    chatType: undefined,
    cpid: undefined,
    aioType: undefined,
    uint64ToTinyId: undefined,
  };
}

export const PbC2CReadedReportReqUinPairReadInfo: MessageFns<PbC2CReadedReportReqUinPairReadInfo> = {
  encode(message: PbC2CReadedReportReqUinPairReadInfo, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.peerUin !== undefined) {
      writer.uint32(8).uint64(message.peerUin);
    }
    if (message.lastReadTime !== undefined) {
      writer.uint32(16).uint32(message.lastReadTime);
    }
    if (message.crmSig !== undefined) {
      writer.uint32(26).bytes(message.crmSig);
    }
    if (message.peerType !== undefined) {
      writer.uint32(32).int32(message.peerType);
    }
    if (message.chatType !== undefined) {
      writer.uint32(40).uint32(message.chatType);
    }
    if (message.cpid !== undefined) {
      writer.uint32(48).uint64(message.cpid);
    }
    if (message.aioType !== undefined) {
      writer.uint32(56).uint32(message.aioType);
    }
    if (message.uint64ToTinyId !== undefined) {
      writer.uint32(64).uint64(message.uint64ToTinyId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PbC2CReadedReportReqUinPairReadInfo {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePbC2CReadedReportReqUinPairReadInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.peerUin = longToNumber(reader.uint64());
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.lastReadTime = reader.uint32();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.crmSig = reader.bytes();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.peerType = reader.int32();
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.chatType = reader.uint32();
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.cpid = longToNumber(reader.uint64());
          continue;
        }
        case 7: {
          if (tag !== 56) {
            break;
          }

          message.aioType = reader.uint32();
          continue;
        }
        case 8: {
          if (tag !== 64) {
            break;
          }

          message.uint64ToTinyId = longToNumber(reader.uint64());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PbC2CReadedReportReqUinPairReadInfo {
    return {
      peerUin: isSet(object.peerUin) ? globalThis.Number(object.peerUin) : undefined,
      lastReadTime: isSet(object.lastReadTime) ? globalThis.Number(object.lastReadTime) : undefined,
      crmSig: isSet(object.crmSig) ? bytesFromBase64(object.crmSig) : undefined,
      peerType: isSet(object.peerType) ? globalThis.Number(object.peerType) : undefined,
      chatType: isSet(object.chatType) ? globalThis.Number(object.chatType) : undefined,
      cpid: isSet(object.cpid) ? globalThis.Number(object.cpid) : undefined,
      aioType: isSet(object.aioType) ? globalThis.Number(object.aioType) : undefined,
      uint64ToTinyId: isSet(object.uint64ToTinyId) ? globalThis.Number(object.uint64ToTinyId) : undefined,
    };
  },

  toJSON(message: PbC2CReadedReportReqUinPairReadInfo): unknown {
    const obj: any = {};
    if (message.peerUin !== undefined) {
      obj.peerUin = Math.round(message.peerUin);
    }
    if (message.lastReadTime !== undefined) {
      obj.lastReadTime = Math.round(message.lastReadTime);
    }
    if (message.crmSig !== undefined) {
      obj.crmSig = base64FromBytes(message.crmSig);
    }
    if (message.peerType !== undefined) {
      obj.peerType = Math.round(message.peerType);
    }
    if (message.chatType !== undefined) {
      obj.chatType = Math.round(message.chatType);
    }
    if (message.cpid !== undefined) {
      obj.cpid = Math.round(message.cpid);
    }
    if (message.aioType !== undefined) {
      obj.aioType = Math.round(message.aioType);
    }
    if (message.uint64ToTinyId !== undefined) {
      obj.uint64ToTinyId = Math.round(message.uint64ToTinyId);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<PbC2CReadedReportReqUinPairReadInfo>, I>>(
    base?: I,
  ): PbC2CReadedReportReqUinPairReadInfo {
    return PbC2CReadedReportReqUinPairReadInfo.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<PbC2CReadedReportReqUinPairReadInfo>, I>>(
    object: I,
  ): PbC2CReadedReportReqUinPairReadInfo {
    const message = createBasePbC2CReadedReportReqUinPairReadInfo();
    message.peerUin = object.peerUin ?? undefined;
    message.lastReadTime = object.lastReadTime ?? undefined;
    message.crmSig = object.crmSig ?? undefined;
    message.peerType = object.peerType ?? undefined;
    message.chatType = object.chatType ?? undefined;
    message.cpid = object.cpid ?? undefined;
    message.aioType = object.aioType ?? undefined;
    message.uint64ToTinyId = object.uint64ToTinyId ?? undefined;
    return message;
  },
};

function createBasePbC2CReadedReportReq(): PbC2CReadedReportReq {
  return { syncCookie: undefined, pairInfo: [] };
}

export const PbC2CReadedReportReq: MessageFns<PbC2CReadedReportReq> = {
  encode(message: PbC2CReadedReportReq, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.syncCookie !== undefined) {
      writer.uint32(10).bytes(message.syncCookie);
    }
    for (const v of message.pairInfo) {
      PbC2CReadedReportReqUinPairReadInfo.encode(v!, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PbC2CReadedReportReq {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePbC2CReadedReportReq();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.syncCookie = reader.bytes();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.pairInfo.push(PbC2CReadedReportReqUinPairReadInfo.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PbC2CReadedReportReq {
    return {
      syncCookie: isSet(object.syncCookie) ? bytesFromBase64(object.syncCookie) : undefined,
      pairInfo: globalThis.Array.isArray(object?.pairInfo)
        ? object.pairInfo.map((e: any) => PbC2CReadedReportReqUinPairReadInfo.fromJSON(e))
        : [],
    };
  },

  toJSON(message: PbC2CReadedReportReq): unknown {
    const obj: any = {};
    if (message.syncCookie !== undefined) {
      obj.syncCookie = base64FromBytes(message.syncCookie);
    }
    if (message.pairInfo?.length) {
      obj.pairInfo = message.pairInfo.map((e) => PbC2CReadedReportReqUinPairReadInfo.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<PbC2CReadedReportReq>, I>>(base?: I): PbC2CReadedReportReq {
    return PbC2CReadedReportReq.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<PbC2CReadedReportReq>, I>>(object: I): PbC2CReadedReportReq {
    const message = createBasePbC2CReadedReportReq();
    message.syncCookie = object.syncCookie ?? undefined;
    message.pairInfo = object.pairInfo?.map((e) => PbC2CReadedReportReqUinPairReadInfo.fromPartial(e)) || [];
    return message;
  },
};

function createBasePbC2CReadedReportResp(): PbC2CReadedReportResp {
  return { result: undefined, errmsg: undefined, syncCookie: undefined };
}

export const PbC2CReadedReportResp: MessageFns<PbC2CReadedReportResp> = {
  encode(message: PbC2CReadedReportResp, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.result !== undefined) {
      writer.uint32(8).uint32(message.result);
    }
    if (message.errmsg !== undefined) {
      writer.uint32(18).string(message.errmsg);
    }
    if (message.syncCookie !== undefined) {
      writer.uint32(26).bytes(message.syncCookie);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PbC2CReadedReportResp {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePbC2CReadedReportResp();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.result = reader.uint32();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.errmsg = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.syncCookie = reader.bytes();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PbC2CReadedReportResp {
    return {
      result: isSet(object.result) ? globalThis.Number(object.result) : undefined,
      errmsg: isSet(object.errmsg) ? globalThis.String(object.errmsg) : undefined,
      syncCookie: isSet(object.syncCookie) ? bytesFromBase64(object.syncCookie) : undefined,
    };
  },

  toJSON(message: PbC2CReadedReportResp): unknown {
    const obj: any = {};
    if (message.result !== undefined) {
      obj.result = Math.round(message.result);
    }
    if (message.errmsg !== undefined) {
      obj.errmsg = message.errmsg;
    }
    if (message.syncCookie !== undefined) {
      obj.syncCookie = base64FromBytes(message.syncCookie);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<PbC2CReadedReportResp>, I>>(base?: I): PbC2CReadedReportResp {
    return PbC2CReadedReportResp.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<PbC2CReadedReportResp>, I>>(object: I): PbC2CReadedReportResp {
    const message = createBasePbC2CReadedReportResp();
    message.result = object.result ?? undefined;
    message.errmsg = object.errmsg ?? undefined;
    message.syncCookie = object.syncCookie ?? undefined;
    return message;
  },
};

function createBasePbC2CUnReadMsgNumReq(): PbC2CUnReadMsgNumReq {
  return {};
}

export const PbC2CUnReadMsgNumReq: MessageFns<PbC2CUnReadMsgNumReq> = {
  encode(_: PbC2CUnReadMsgNumReq, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PbC2CUnReadMsgNumReq {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePbC2CUnReadMsgNumReq();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): PbC2CUnReadMsgNumReq {
    return {};
  },

  toJSON(_: PbC2CUnReadMsgNumReq): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<PbC2CUnReadMsgNumReq>, I>>(base?: I): PbC2CUnReadMsgNumReq {
    return PbC2CUnReadMsgNumReq.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<PbC2CUnReadMsgNumReq>, I>>(_: I): PbC2CUnReadMsgNumReq {
    const message = createBasePbC2CUnReadMsgNumReq();
    return message;
  },
};

function createBasePbC2CUnReadMsgNumResp(): PbC2CUnReadMsgNumResp {
  return { result: undefined, errmsg: undefined, msgNum: undefined };
}

export const PbC2CUnReadMsgNumResp: MessageFns<PbC2CUnReadMsgNumResp> = {
  encode(message: PbC2CUnReadMsgNumResp, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.result !== undefined) {
      writer.uint32(8).uint32(message.result);
    }
    if (message.errmsg !== undefined) {
      writer.uint32(18).string(message.errmsg);
    }
    if (message.msgNum !== undefined) {
      writer.uint32(24).uint32(message.msgNum);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PbC2CUnReadMsgNumResp {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePbC2CUnReadMsgNumResp();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.result = reader.uint32();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.errmsg = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.msgNum = reader.uint32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PbC2CUnReadMsgNumResp {
    return {
      result: isSet(object.result) ? globalThis.Number(object.result) : undefined,
      errmsg: isSet(object.errmsg) ? globalThis.String(object.errmsg) : undefined,
      msgNum: isSet(object.msgNum) ? globalThis.Number(object.msgNum) : undefined,
    };
  },

  toJSON(message: PbC2CUnReadMsgNumResp): unknown {
    const obj: any = {};
    if (message.result !== undefined) {
      obj.result = Math.round(message.result);
    }
    if (message.errmsg !== undefined) {
      obj.errmsg = message.errmsg;
    }
    if (message.msgNum !== undefined) {
      obj.msgNum = Math.round(message.msgNum);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<PbC2CUnReadMsgNumResp>, I>>(base?: I): PbC2CUnReadMsgNumResp {
    return PbC2CUnReadMsgNumResp.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<PbC2CUnReadMsgNumResp>, I>>(object: I): PbC2CUnReadMsgNumResp {
    const message = createBasePbC2CUnReadMsgNumResp();
    message.result = object.result ?? undefined;
    message.errmsg = object.errmsg ?? undefined;
    message.msgNum = object.msgNum ?? undefined;
    return message;
  },
};

function createBasePbDeleteMsgReqMsgItem(): PbDeleteMsgReqMsgItem {
  return {
    fromUin: undefined,
    toUin: undefined,
    msgType: undefined,
    msgSeq: undefined,
    msgUid: undefined,
    sig: undefined,
  };
}

export const PbDeleteMsgReqMsgItem: MessageFns<PbDeleteMsgReqMsgItem> = {
  encode(message: PbDeleteMsgReqMsgItem, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.fromUin !== undefined) {
      writer.uint32(8).uint64(message.fromUin);
    }
    if (message.toUin !== undefined) {
      writer.uint32(16).uint64(message.toUin);
    }
    if (message.msgType !== undefined) {
      writer.uint32(24).uint32(message.msgType);
    }
    if (message.msgSeq !== undefined) {
      writer.uint32(32).uint32(message.msgSeq);
    }
    if (message.msgUid !== undefined) {
      writer.uint32(40).uint64(message.msgUid);
    }
    if (message.sig !== undefined) {
      writer.uint32(50).bytes(message.sig);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PbDeleteMsgReqMsgItem {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePbDeleteMsgReqMsgItem();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.fromUin = longToNumber(reader.uint64());
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.toUin = longToNumber(reader.uint64());
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.msgType = reader.uint32();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.msgSeq = reader.uint32();
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.msgUid = longToNumber(reader.uint64());
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.sig = reader.bytes();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PbDeleteMsgReqMsgItem {
    return {
      fromUin: isSet(object.fromUin) ? globalThis.Number(object.fromUin) : undefined,
      toUin: isSet(object.toUin) ? globalThis.Number(object.toUin) : undefined,
      msgType: isSet(object.msgType) ? globalThis.Number(object.msgType) : undefined,
      msgSeq: isSet(object.msgSeq) ? globalThis.Number(object.msgSeq) : undefined,
      msgUid: isSet(object.msgUid) ? globalThis.Number(object.msgUid) : undefined,
      sig: isSet(object.sig) ? bytesFromBase64(object.sig) : undefined,
    };
  },

  toJSON(message: PbDeleteMsgReqMsgItem): unknown {
    const obj: any = {};
    if (message.fromUin !== undefined) {
      obj.fromUin = Math.round(message.fromUin);
    }
    if (message.toUin !== undefined) {
      obj.toUin = Math.round(message.toUin);
    }
    if (message.msgType !== undefined) {
      obj.msgType = Math.round(message.msgType);
    }
    if (message.msgSeq !== undefined) {
      obj.msgSeq = Math.round(message.msgSeq);
    }
    if (message.msgUid !== undefined) {
      obj.msgUid = Math.round(message.msgUid);
    }
    if (message.sig !== undefined) {
      obj.sig = base64FromBytes(message.sig);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<PbDeleteMsgReqMsgItem>, I>>(base?: I): PbDeleteMsgReqMsgItem {
    return PbDeleteMsgReqMsgItem.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<PbDeleteMsgReqMsgItem>, I>>(object: I): PbDeleteMsgReqMsgItem {
    const message = createBasePbDeleteMsgReqMsgItem();
    message.fromUin = object.fromUin ?? undefined;
    message.toUin = object.toUin ?? undefined;
    message.msgType = object.msgType ?? undefined;
    message.msgSeq = object.msgSeq ?? undefined;
    message.msgUid = object.msgUid ?? undefined;
    message.sig = object.sig ?? undefined;
    return message;
  },
};

function createBasePbDeleteMsgReq(): PbDeleteMsgReq {
  return { msgItems: [] };
}

export const PbDeleteMsgReq: MessageFns<PbDeleteMsgReq> = {
  encode(message: PbDeleteMsgReq, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.msgItems) {
      PbDeleteMsgReqMsgItem.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PbDeleteMsgReq {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePbDeleteMsgReq();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.msgItems.push(PbDeleteMsgReqMsgItem.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PbDeleteMsgReq {
    return {
      msgItems: globalThis.Array.isArray(object?.msgItems)
        ? object.msgItems.map((e: any) => PbDeleteMsgReqMsgItem.fromJSON(e))
        : [],
    };
  },

  toJSON(message: PbDeleteMsgReq): unknown {
    const obj: any = {};
    if (message.msgItems?.length) {
      obj.msgItems = message.msgItems.map((e) => PbDeleteMsgReqMsgItem.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<PbDeleteMsgReq>, I>>(base?: I): PbDeleteMsgReq {
    return PbDeleteMsgReq.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<PbDeleteMsgReq>, I>>(object: I): PbDeleteMsgReq {
    const message = createBasePbDeleteMsgReq();
    message.msgItems = object.msgItems?.map((e) => PbDeleteMsgReqMsgItem.fromPartial(e)) || [];
    return message;
  },
};

function createBasePbDeleteMsgResp(): PbDeleteMsgResp {
  return { result: undefined, errmsg: undefined };
}

export const PbDeleteMsgResp: MessageFns<PbDeleteMsgResp> = {
  encode(message: PbDeleteMsgResp, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.result !== undefined) {
      writer.uint32(8).uint32(message.result);
    }
    if (message.errmsg !== undefined) {
      writer.uint32(18).string(message.errmsg);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PbDeleteMsgResp {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePbDeleteMsgResp();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.result = reader.uint32();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.errmsg = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PbDeleteMsgResp {
    return {
      result: isSet(object.result) ? globalThis.Number(object.result) : undefined,
      errmsg: isSet(object.errmsg) ? globalThis.String(object.errmsg) : undefined,
    };
  },

  toJSON(message: PbDeleteMsgResp): unknown {
    const obj: any = {};
    if (message.result !== undefined) {
      obj.result = Math.round(message.result);
    }
    if (message.errmsg !== undefined) {
      obj.errmsg = message.errmsg;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<PbDeleteMsgResp>, I>>(base?: I): PbDeleteMsgResp {
    return PbDeleteMsgResp.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<PbDeleteMsgResp>, I>>(object: I): PbDeleteMsgResp {
    const message = createBasePbDeleteMsgResp();
    message.result = object.result ?? undefined;
    message.errmsg = object.errmsg ?? undefined;
    return message;
  },
};

function createBasePbDelRoamMsgReqC2CMsg(): PbDelRoamMsgReqC2CMsg {
  return { fromUin: undefined, peerUin: undefined, msgTime: undefined, msgRandom: undefined, msgSeq: undefined };
}

export const PbDelRoamMsgReqC2CMsg: MessageFns<PbDelRoamMsgReqC2CMsg> = {
  encode(message: PbDelRoamMsgReqC2CMsg, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.fromUin !== undefined) {
      writer.uint32(8).uint64(message.fromUin);
    }
    if (message.peerUin !== undefined) {
      writer.uint32(16).uint64(message.peerUin);
    }
    if (message.msgTime !== undefined) {
      writer.uint32(24).uint32(message.msgTime);
    }
    if (message.msgRandom !== undefined) {
      writer.uint32(32).uint32(message.msgRandom);
    }
    if (message.msgSeq !== undefined) {
      writer.uint32(40).uint32(message.msgSeq);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PbDelRoamMsgReqC2CMsg {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePbDelRoamMsgReqC2CMsg();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.fromUin = longToNumber(reader.uint64());
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.peerUin = longToNumber(reader.uint64());
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.msgTime = reader.uint32();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.msgRandom = reader.uint32();
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.msgSeq = reader.uint32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PbDelRoamMsgReqC2CMsg {
    return {
      fromUin: isSet(object.fromUin) ? globalThis.Number(object.fromUin) : undefined,
      peerUin: isSet(object.peerUin) ? globalThis.Number(object.peerUin) : undefined,
      msgTime: isSet(object.msgTime) ? globalThis.Number(object.msgTime) : undefined,
      msgRandom: isSet(object.msgRandom) ? globalThis.Number(object.msgRandom) : undefined,
      msgSeq: isSet(object.msgSeq) ? globalThis.Number(object.msgSeq) : undefined,
    };
  },

  toJSON(message: PbDelRoamMsgReqC2CMsg): unknown {
    const obj: any = {};
    if (message.fromUin !== undefined) {
      obj.fromUin = Math.round(message.fromUin);
    }
    if (message.peerUin !== undefined) {
      obj.peerUin = Math.round(message.peerUin);
    }
    if (message.msgTime !== undefined) {
      obj.msgTime = Math.round(message.msgTime);
    }
    if (message.msgRandom !== undefined) {
      obj.msgRandom = Math.round(message.msgRandom);
    }
    if (message.msgSeq !== undefined) {
      obj.msgSeq = Math.round(message.msgSeq);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<PbDelRoamMsgReqC2CMsg>, I>>(base?: I): PbDelRoamMsgReqC2CMsg {
    return PbDelRoamMsgReqC2CMsg.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<PbDelRoamMsgReqC2CMsg>, I>>(object: I): PbDelRoamMsgReqC2CMsg {
    const message = createBasePbDelRoamMsgReqC2CMsg();
    message.fromUin = object.fromUin ?? undefined;
    message.peerUin = object.peerUin ?? undefined;
    message.msgTime = object.msgTime ?? undefined;
    message.msgRandom = object.msgRandom ?? undefined;
    message.msgSeq = object.msgSeq ?? undefined;
    return message;
  },
};

function createBasePbDelRoamMsgReqDisMsg(): PbDelRoamMsgReqDisMsg {
  return { discussUin: undefined, msgSeq: undefined };
}

export const PbDelRoamMsgReqDisMsg: MessageFns<PbDelRoamMsgReqDisMsg> = {
  encode(message: PbDelRoamMsgReqDisMsg, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.discussUin !== undefined) {
      writer.uint32(8).uint64(message.discussUin);
    }
    if (message.msgSeq !== undefined) {
      writer.uint32(16).uint64(message.msgSeq);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PbDelRoamMsgReqDisMsg {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePbDelRoamMsgReqDisMsg();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.discussUin = longToNumber(reader.uint64());
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.msgSeq = longToNumber(reader.uint64());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PbDelRoamMsgReqDisMsg {
    return {
      discussUin: isSet(object.discussUin) ? globalThis.Number(object.discussUin) : undefined,
      msgSeq: isSet(object.msgSeq) ? globalThis.Number(object.msgSeq) : undefined,
    };
  },

  toJSON(message: PbDelRoamMsgReqDisMsg): unknown {
    const obj: any = {};
    if (message.discussUin !== undefined) {
      obj.discussUin = Math.round(message.discussUin);
    }
    if (message.msgSeq !== undefined) {
      obj.msgSeq = Math.round(message.msgSeq);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<PbDelRoamMsgReqDisMsg>, I>>(base?: I): PbDelRoamMsgReqDisMsg {
    return PbDelRoamMsgReqDisMsg.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<PbDelRoamMsgReqDisMsg>, I>>(object: I): PbDelRoamMsgReqDisMsg {
    const message = createBasePbDelRoamMsgReqDisMsg();
    message.discussUin = object.discussUin ?? undefined;
    message.msgSeq = object.msgSeq ?? undefined;
    return message;
  },
};

function createBasePbDelRoamMsgReqGrpMsg(): PbDelRoamMsgReqGrpMsg {
  return { groupCode: undefined, msgSeq: undefined, uint32ResvFlag: undefined };
}

export const PbDelRoamMsgReqGrpMsg: MessageFns<PbDelRoamMsgReqGrpMsg> = {
  encode(message: PbDelRoamMsgReqGrpMsg, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.groupCode !== undefined) {
      writer.uint32(8).uint64(message.groupCode);
    }
    if (message.msgSeq !== undefined) {
      writer.uint32(16).uint64(message.msgSeq);
    }
    if (message.uint32ResvFlag !== undefined) {
      writer.uint32(24).uint32(message.uint32ResvFlag);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PbDelRoamMsgReqGrpMsg {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePbDelRoamMsgReqGrpMsg();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.groupCode = longToNumber(reader.uint64());
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.msgSeq = longToNumber(reader.uint64());
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.uint32ResvFlag = reader.uint32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PbDelRoamMsgReqGrpMsg {
    return {
      groupCode: isSet(object.groupCode) ? globalThis.Number(object.groupCode) : undefined,
      msgSeq: isSet(object.msgSeq) ? globalThis.Number(object.msgSeq) : undefined,
      uint32ResvFlag: isSet(object.uint32ResvFlag) ? globalThis.Number(object.uint32ResvFlag) : undefined,
    };
  },

  toJSON(message: PbDelRoamMsgReqGrpMsg): unknown {
    const obj: any = {};
    if (message.groupCode !== undefined) {
      obj.groupCode = Math.round(message.groupCode);
    }
    if (message.msgSeq !== undefined) {
      obj.msgSeq = Math.round(message.msgSeq);
    }
    if (message.uint32ResvFlag !== undefined) {
      obj.uint32ResvFlag = Math.round(message.uint32ResvFlag);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<PbDelRoamMsgReqGrpMsg>, I>>(base?: I): PbDelRoamMsgReqGrpMsg {
    return PbDelRoamMsgReqGrpMsg.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<PbDelRoamMsgReqGrpMsg>, I>>(object: I): PbDelRoamMsgReqGrpMsg {
    const message = createBasePbDelRoamMsgReqGrpMsg();
    message.groupCode = object.groupCode ?? undefined;
    message.msgSeq = object.msgSeq ?? undefined;
    message.uint32ResvFlag = object.uint32ResvFlag ?? undefined;
    return message;
  },
};

function createBasePbDelRoamMsgReq(): PbDelRoamMsgReq {
  return { c2cMsg: undefined, grpMsg: undefined, disMsg: undefined };
}

export const PbDelRoamMsgReq: MessageFns<PbDelRoamMsgReq> = {
  encode(message: PbDelRoamMsgReq, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.c2cMsg !== undefined) {
      PbDelRoamMsgReqC2CMsg.encode(message.c2cMsg, writer.uint32(10).fork()).join();
    }
    if (message.grpMsg !== undefined) {
      PbDelRoamMsgReqGrpMsg.encode(message.grpMsg, writer.uint32(18).fork()).join();
    }
    if (message.disMsg !== undefined) {
      PbDelRoamMsgReqDisMsg.encode(message.disMsg, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PbDelRoamMsgReq {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePbDelRoamMsgReq();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.c2cMsg = PbDelRoamMsgReqC2CMsg.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.grpMsg = PbDelRoamMsgReqGrpMsg.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.disMsg = PbDelRoamMsgReqDisMsg.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PbDelRoamMsgReq {
    return {
      c2cMsg: isSet(object.c2cMsg) ? PbDelRoamMsgReqC2CMsg.fromJSON(object.c2cMsg) : undefined,
      grpMsg: isSet(object.grpMsg) ? PbDelRoamMsgReqGrpMsg.fromJSON(object.grpMsg) : undefined,
      disMsg: isSet(object.disMsg) ? PbDelRoamMsgReqDisMsg.fromJSON(object.disMsg) : undefined,
    };
  },

  toJSON(message: PbDelRoamMsgReq): unknown {
    const obj: any = {};
    if (message.c2cMsg !== undefined) {
      obj.c2cMsg = PbDelRoamMsgReqC2CMsg.toJSON(message.c2cMsg);
    }
    if (message.grpMsg !== undefined) {
      obj.grpMsg = PbDelRoamMsgReqGrpMsg.toJSON(message.grpMsg);
    }
    if (message.disMsg !== undefined) {
      obj.disMsg = PbDelRoamMsgReqDisMsg.toJSON(message.disMsg);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<PbDelRoamMsgReq>, I>>(base?: I): PbDelRoamMsgReq {
    return PbDelRoamMsgReq.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<PbDelRoamMsgReq>, I>>(object: I): PbDelRoamMsgReq {
    const message = createBasePbDelRoamMsgReq();
    message.c2cMsg = (object.c2cMsg !== undefined && object.c2cMsg !== null)
      ? PbDelRoamMsgReqC2CMsg.fromPartial(object.c2cMsg)
      : undefined;
    message.grpMsg = (object.grpMsg !== undefined && object.grpMsg !== null)
      ? PbDelRoamMsgReqGrpMsg.fromPartial(object.grpMsg)
      : undefined;
    message.disMsg = (object.disMsg !== undefined && object.disMsg !== null)
      ? PbDelRoamMsgReqDisMsg.fromPartial(object.disMsg)
      : undefined;
    return message;
  },
};

function createBasePbDelRoamMsgResp(): PbDelRoamMsgResp {
  return { result: undefined, errmsg: undefined };
}

export const PbDelRoamMsgResp: MessageFns<PbDelRoamMsgResp> = {
  encode(message: PbDelRoamMsgResp, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.result !== undefined) {
      writer.uint32(8).uint32(message.result);
    }
    if (message.errmsg !== undefined) {
      writer.uint32(18).string(message.errmsg);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PbDelRoamMsgResp {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePbDelRoamMsgResp();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.result = reader.uint32();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.errmsg = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PbDelRoamMsgResp {
    return {
      result: isSet(object.result) ? globalThis.Number(object.result) : undefined,
      errmsg: isSet(object.errmsg) ? globalThis.String(object.errmsg) : undefined,
    };
  },

  toJSON(message: PbDelRoamMsgResp): unknown {
    const obj: any = {};
    if (message.result !== undefined) {
      obj.result = Math.round(message.result);
    }
    if (message.errmsg !== undefined) {
      obj.errmsg = message.errmsg;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<PbDelRoamMsgResp>, I>>(base?: I): PbDelRoamMsgResp {
    return PbDelRoamMsgResp.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<PbDelRoamMsgResp>, I>>(object: I): PbDelRoamMsgResp {
    const message = createBasePbDelRoamMsgResp();
    message.result = object.result ?? undefined;
    message.errmsg = object.errmsg ?? undefined;
    return message;
  },
};

function createBasePbDiscussReadedReportReq(): PbDiscussReadedReportReq {
  return { confUin: undefined, lastReadSeq: undefined };
}

export const PbDiscussReadedReportReq: MessageFns<PbDiscussReadedReportReq> = {
  encode(message: PbDiscussReadedReportReq, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.confUin !== undefined) {
      writer.uint32(8).uint64(message.confUin);
    }
    if (message.lastReadSeq !== undefined) {
      writer.uint32(16).uint64(message.lastReadSeq);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PbDiscussReadedReportReq {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePbDiscussReadedReportReq();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.confUin = longToNumber(reader.uint64());
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.lastReadSeq = longToNumber(reader.uint64());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PbDiscussReadedReportReq {
    return {
      confUin: isSet(object.confUin) ? globalThis.Number(object.confUin) : undefined,
      lastReadSeq: isSet(object.lastReadSeq) ? globalThis.Number(object.lastReadSeq) : undefined,
    };
  },

  toJSON(message: PbDiscussReadedReportReq): unknown {
    const obj: any = {};
    if (message.confUin !== undefined) {
      obj.confUin = Math.round(message.confUin);
    }
    if (message.lastReadSeq !== undefined) {
      obj.lastReadSeq = Math.round(message.lastReadSeq);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<PbDiscussReadedReportReq>, I>>(base?: I): PbDiscussReadedReportReq {
    return PbDiscussReadedReportReq.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<PbDiscussReadedReportReq>, I>>(object: I): PbDiscussReadedReportReq {
    const message = createBasePbDiscussReadedReportReq();
    message.confUin = object.confUin ?? undefined;
    message.lastReadSeq = object.lastReadSeq ?? undefined;
    return message;
  },
};

function createBasePbDiscussReadedReportResp(): PbDiscussReadedReportResp {
  return { result: undefined, errmsg: undefined, confUin: undefined, memberSeq: undefined, confSeq: undefined };
}

export const PbDiscussReadedReportResp: MessageFns<PbDiscussReadedReportResp> = {
  encode(message: PbDiscussReadedReportResp, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.result !== undefined) {
      writer.uint32(8).uint32(message.result);
    }
    if (message.errmsg !== undefined) {
      writer.uint32(18).string(message.errmsg);
    }
    if (message.confUin !== undefined) {
      writer.uint32(24).uint64(message.confUin);
    }
    if (message.memberSeq !== undefined) {
      writer.uint32(32).uint64(message.memberSeq);
    }
    if (message.confSeq !== undefined) {
      writer.uint32(40).uint64(message.confSeq);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PbDiscussReadedReportResp {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePbDiscussReadedReportResp();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.result = reader.uint32();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.errmsg = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.confUin = longToNumber(reader.uint64());
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.memberSeq = longToNumber(reader.uint64());
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.confSeq = longToNumber(reader.uint64());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PbDiscussReadedReportResp {
    return {
      result: isSet(object.result) ? globalThis.Number(object.result) : undefined,
      errmsg: isSet(object.errmsg) ? globalThis.String(object.errmsg) : undefined,
      confUin: isSet(object.confUin) ? globalThis.Number(object.confUin) : undefined,
      memberSeq: isSet(object.memberSeq) ? globalThis.Number(object.memberSeq) : undefined,
      confSeq: isSet(object.confSeq) ? globalThis.Number(object.confSeq) : undefined,
    };
  },

  toJSON(message: PbDiscussReadedReportResp): unknown {
    const obj: any = {};
    if (message.result !== undefined) {
      obj.result = Math.round(message.result);
    }
    if (message.errmsg !== undefined) {
      obj.errmsg = message.errmsg;
    }
    if (message.confUin !== undefined) {
      obj.confUin = Math.round(message.confUin);
    }
    if (message.memberSeq !== undefined) {
      obj.memberSeq = Math.round(message.memberSeq);
    }
    if (message.confSeq !== undefined) {
      obj.confSeq = Math.round(message.confSeq);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<PbDiscussReadedReportResp>, I>>(base?: I): PbDiscussReadedReportResp {
    return PbDiscussReadedReportResp.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<PbDiscussReadedReportResp>, I>>(object: I): PbDiscussReadedReportResp {
    const message = createBasePbDiscussReadedReportResp();
    message.result = object.result ?? undefined;
    message.errmsg = object.errmsg ?? undefined;
    message.confUin = object.confUin ?? undefined;
    message.memberSeq = object.memberSeq ?? undefined;
    message.confSeq = object.confSeq ?? undefined;
    return message;
  },
};

function createBasePbGetDiscussMsgReq(): PbGetDiscussMsgReq {
  return {
    discussUin: undefined,
    endSeq: undefined,
    beginSeq: undefined,
    lastGetTime: undefined,
    discussInfoSeq: undefined,
    filter: undefined,
    memberSeq: undefined,
  };
}

export const PbGetDiscussMsgReq: MessageFns<PbGetDiscussMsgReq> = {
  encode(message: PbGetDiscussMsgReq, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.discussUin !== undefined) {
      writer.uint32(8).uint64(message.discussUin);
    }
    if (message.endSeq !== undefined) {
      writer.uint32(16).uint64(message.endSeq);
    }
    if (message.beginSeq !== undefined) {
      writer.uint32(24).uint64(message.beginSeq);
    }
    if (message.lastGetTime !== undefined) {
      writer.uint32(32).uint64(message.lastGetTime);
    }
    if (message.discussInfoSeq !== undefined) {
      writer.uint32(40).uint64(message.discussInfoSeq);
    }
    if (message.filter !== undefined) {
      writer.uint32(48).int32(message.filter);
    }
    if (message.memberSeq !== undefined) {
      writer.uint32(56).uint64(message.memberSeq);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PbGetDiscussMsgReq {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePbGetDiscussMsgReq();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.discussUin = longToNumber(reader.uint64());
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.endSeq = longToNumber(reader.uint64());
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.beginSeq = longToNumber(reader.uint64());
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.lastGetTime = longToNumber(reader.uint64());
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.discussInfoSeq = longToNumber(reader.uint64());
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.filter = reader.int32();
          continue;
        }
        case 7: {
          if (tag !== 56) {
            break;
          }

          message.memberSeq = longToNumber(reader.uint64());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PbGetDiscussMsgReq {
    return {
      discussUin: isSet(object.discussUin) ? globalThis.Number(object.discussUin) : undefined,
      endSeq: isSet(object.endSeq) ? globalThis.Number(object.endSeq) : undefined,
      beginSeq: isSet(object.beginSeq) ? globalThis.Number(object.beginSeq) : undefined,
      lastGetTime: isSet(object.lastGetTime) ? globalThis.Number(object.lastGetTime) : undefined,
      discussInfoSeq: isSet(object.discussInfoSeq) ? globalThis.Number(object.discussInfoSeq) : undefined,
      filter: isSet(object.filter) ? globalThis.Number(object.filter) : undefined,
      memberSeq: isSet(object.memberSeq) ? globalThis.Number(object.memberSeq) : undefined,
    };
  },

  toJSON(message: PbGetDiscussMsgReq): unknown {
    const obj: any = {};
    if (message.discussUin !== undefined) {
      obj.discussUin = Math.round(message.discussUin);
    }
    if (message.endSeq !== undefined) {
      obj.endSeq = Math.round(message.endSeq);
    }
    if (message.beginSeq !== undefined) {
      obj.beginSeq = Math.round(message.beginSeq);
    }
    if (message.lastGetTime !== undefined) {
      obj.lastGetTime = Math.round(message.lastGetTime);
    }
    if (message.discussInfoSeq !== undefined) {
      obj.discussInfoSeq = Math.round(message.discussInfoSeq);
    }
    if (message.filter !== undefined) {
      obj.filter = Math.round(message.filter);
    }
    if (message.memberSeq !== undefined) {
      obj.memberSeq = Math.round(message.memberSeq);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<PbGetDiscussMsgReq>, I>>(base?: I): PbGetDiscussMsgReq {
    return PbGetDiscussMsgReq.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<PbGetDiscussMsgReq>, I>>(object: I): PbGetDiscussMsgReq {
    const message = createBasePbGetDiscussMsgReq();
    message.discussUin = object.discussUin ?? undefined;
    message.endSeq = object.endSeq ?? undefined;
    message.beginSeq = object.beginSeq ?? undefined;
    message.lastGetTime = object.lastGetTime ?? undefined;
    message.discussInfoSeq = object.discussInfoSeq ?? undefined;
    message.filter = object.filter ?? undefined;
    message.memberSeq = object.memberSeq ?? undefined;
    return message;
  },
};

function createBasePbGetGroupMsgReq(): PbGetGroupMsgReq {
  return {
    groupCode: undefined,
    beginSeq: undefined,
    endSeq: undefined,
    filter: undefined,
    memberSeq: undefined,
    publicGroup: undefined,
    shieldFlag: undefined,
    saveTrafficFlag: undefined,
  };
}

export const PbGetGroupMsgReq: MessageFns<PbGetGroupMsgReq> = {
  encode(message: PbGetGroupMsgReq, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.groupCode !== undefined) {
      writer.uint32(8).uint64(message.groupCode);
    }
    if (message.beginSeq !== undefined) {
      writer.uint32(16).uint64(message.beginSeq);
    }
    if (message.endSeq !== undefined) {
      writer.uint32(24).uint64(message.endSeq);
    }
    if (message.filter !== undefined) {
      writer.uint32(32).int32(message.filter);
    }
    if (message.memberSeq !== undefined) {
      writer.uint32(40).uint64(message.memberSeq);
    }
    if (message.publicGroup !== undefined) {
      writer.uint32(48).bool(message.publicGroup);
    }
    if (message.shieldFlag !== undefined) {
      writer.uint32(56).uint32(message.shieldFlag);
    }
    if (message.saveTrafficFlag !== undefined) {
      writer.uint32(64).uint32(message.saveTrafficFlag);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PbGetGroupMsgReq {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePbGetGroupMsgReq();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.groupCode = longToNumber(reader.uint64());
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.beginSeq = longToNumber(reader.uint64());
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.endSeq = longToNumber(reader.uint64());
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.filter = reader.int32();
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.memberSeq = longToNumber(reader.uint64());
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.publicGroup = reader.bool();
          continue;
        }
        case 7: {
          if (tag !== 56) {
            break;
          }

          message.shieldFlag = reader.uint32();
          continue;
        }
        case 8: {
          if (tag !== 64) {
            break;
          }

          message.saveTrafficFlag = reader.uint32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PbGetGroupMsgReq {
    return {
      groupCode: isSet(object.groupCode) ? globalThis.Number(object.groupCode) : undefined,
      beginSeq: isSet(object.beginSeq) ? globalThis.Number(object.beginSeq) : undefined,
      endSeq: isSet(object.endSeq) ? globalThis.Number(object.endSeq) : undefined,
      filter: isSet(object.filter) ? globalThis.Number(object.filter) : undefined,
      memberSeq: isSet(object.memberSeq) ? globalThis.Number(object.memberSeq) : undefined,
      publicGroup: isSet(object.publicGroup) ? globalThis.Boolean(object.publicGroup) : undefined,
      shieldFlag: isSet(object.shieldFlag) ? globalThis.Number(object.shieldFlag) : undefined,
      saveTrafficFlag: isSet(object.saveTrafficFlag) ? globalThis.Number(object.saveTrafficFlag) : undefined,
    };
  },

  toJSON(message: PbGetGroupMsgReq): unknown {
    const obj: any = {};
    if (message.groupCode !== undefined) {
      obj.groupCode = Math.round(message.groupCode);
    }
    if (message.beginSeq !== undefined) {
      obj.beginSeq = Math.round(message.beginSeq);
    }
    if (message.endSeq !== undefined) {
      obj.endSeq = Math.round(message.endSeq);
    }
    if (message.filter !== undefined) {
      obj.filter = Math.round(message.filter);
    }
    if (message.memberSeq !== undefined) {
      obj.memberSeq = Math.round(message.memberSeq);
    }
    if (message.publicGroup !== undefined) {
      obj.publicGroup = message.publicGroup;
    }
    if (message.shieldFlag !== undefined) {
      obj.shieldFlag = Math.round(message.shieldFlag);
    }
    if (message.saveTrafficFlag !== undefined) {
      obj.saveTrafficFlag = Math.round(message.saveTrafficFlag);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<PbGetGroupMsgReq>, I>>(base?: I): PbGetGroupMsgReq {
    return PbGetGroupMsgReq.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<PbGetGroupMsgReq>, I>>(object: I): PbGetGroupMsgReq {
    const message = createBasePbGetGroupMsgReq();
    message.groupCode = object.groupCode ?? undefined;
    message.beginSeq = object.beginSeq ?? undefined;
    message.endSeq = object.endSeq ?? undefined;
    message.filter = object.filter ?? undefined;
    message.memberSeq = object.memberSeq ?? undefined;
    message.publicGroup = object.publicGroup ?? undefined;
    message.shieldFlag = object.shieldFlag ?? undefined;
    message.saveTrafficFlag = object.saveTrafficFlag ?? undefined;
    return message;
  },
};

function createBasePbGetMsgReq(): PbGetMsgReq {
  return {
    syncFlag: undefined,
    syncCookie: undefined,
    rambleFlag: undefined,
    latestRambleNumber: undefined,
    otherRambleNumber: undefined,
    onlineSyncFlag: undefined,
    contextFlag: undefined,
    whisperSessionId: undefined,
    msgReqType: undefined,
    pubaccountCookie: undefined,
    msgCtrlBuf: undefined,
    bytesServerBuf: undefined,
  };
}

export const PbGetMsgReq: MessageFns<PbGetMsgReq> = {
  encode(message: PbGetMsgReq, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.syncFlag !== undefined) {
      writer.uint32(8).int32(message.syncFlag);
    }
    if (message.syncCookie !== undefined) {
      writer.uint32(18).bytes(message.syncCookie);
    }
    if (message.rambleFlag !== undefined) {
      writer.uint32(24).uint32(message.rambleFlag);
    }
    if (message.latestRambleNumber !== undefined) {
      writer.uint32(32).uint32(message.latestRambleNumber);
    }
    if (message.otherRambleNumber !== undefined) {
      writer.uint32(40).uint32(message.otherRambleNumber);
    }
    if (message.onlineSyncFlag !== undefined) {
      writer.uint32(48).uint32(message.onlineSyncFlag);
    }
    if (message.contextFlag !== undefined) {
      writer.uint32(56).uint32(message.contextFlag);
    }
    if (message.whisperSessionId !== undefined) {
      writer.uint32(64).uint32(message.whisperSessionId);
    }
    if (message.msgReqType !== undefined) {
      writer.uint32(72).uint32(message.msgReqType);
    }
    if (message.pubaccountCookie !== undefined) {
      writer.uint32(82).bytes(message.pubaccountCookie);
    }
    if (message.msgCtrlBuf !== undefined) {
      writer.uint32(90).bytes(message.msgCtrlBuf);
    }
    if (message.bytesServerBuf !== undefined) {
      writer.uint32(98).bytes(message.bytesServerBuf);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PbGetMsgReq {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePbGetMsgReq();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.syncFlag = reader.int32();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.syncCookie = reader.bytes();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.rambleFlag = reader.uint32();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.latestRambleNumber = reader.uint32();
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.otherRambleNumber = reader.uint32();
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.onlineSyncFlag = reader.uint32();
          continue;
        }
        case 7: {
          if (tag !== 56) {
            break;
          }

          message.contextFlag = reader.uint32();
          continue;
        }
        case 8: {
          if (tag !== 64) {
            break;
          }

          message.whisperSessionId = reader.uint32();
          continue;
        }
        case 9: {
          if (tag !== 72) {
            break;
          }

          message.msgReqType = reader.uint32();
          continue;
        }
        case 10: {
          if (tag !== 82) {
            break;
          }

          message.pubaccountCookie = reader.bytes();
          continue;
        }
        case 11: {
          if (tag !== 90) {
            break;
          }

          message.msgCtrlBuf = reader.bytes();
          continue;
        }
        case 12: {
          if (tag !== 98) {
            break;
          }

          message.bytesServerBuf = reader.bytes();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PbGetMsgReq {
    return {
      syncFlag: isSet(object.syncFlag) ? globalThis.Number(object.syncFlag) : undefined,
      syncCookie: isSet(object.syncCookie) ? bytesFromBase64(object.syncCookie) : undefined,
      rambleFlag: isSet(object.rambleFlag) ? globalThis.Number(object.rambleFlag) : undefined,
      latestRambleNumber: isSet(object.latestRambleNumber) ? globalThis.Number(object.latestRambleNumber) : undefined,
      otherRambleNumber: isSet(object.otherRambleNumber) ? globalThis.Number(object.otherRambleNumber) : undefined,
      onlineSyncFlag: isSet(object.onlineSyncFlag) ? globalThis.Number(object.onlineSyncFlag) : undefined,
      contextFlag: isSet(object.contextFlag) ? globalThis.Number(object.contextFlag) : undefined,
      whisperSessionId: isSet(object.whisperSessionId) ? globalThis.Number(object.whisperSessionId) : undefined,
      msgReqType: isSet(object.msgReqType) ? globalThis.Number(object.msgReqType) : undefined,
      pubaccountCookie: isSet(object.pubaccountCookie) ? bytesFromBase64(object.pubaccountCookie) : undefined,
      msgCtrlBuf: isSet(object.msgCtrlBuf) ? bytesFromBase64(object.msgCtrlBuf) : undefined,
      bytesServerBuf: isSet(object.bytesServerBuf) ? bytesFromBase64(object.bytesServerBuf) : undefined,
    };
  },

  toJSON(message: PbGetMsgReq): unknown {
    const obj: any = {};
    if (message.syncFlag !== undefined) {
      obj.syncFlag = Math.round(message.syncFlag);
    }
    if (message.syncCookie !== undefined) {
      obj.syncCookie = base64FromBytes(message.syncCookie);
    }
    if (message.rambleFlag !== undefined) {
      obj.rambleFlag = Math.round(message.rambleFlag);
    }
    if (message.latestRambleNumber !== undefined) {
      obj.latestRambleNumber = Math.round(message.latestRambleNumber);
    }
    if (message.otherRambleNumber !== undefined) {
      obj.otherRambleNumber = Math.round(message.otherRambleNumber);
    }
    if (message.onlineSyncFlag !== undefined) {
      obj.onlineSyncFlag = Math.round(message.onlineSyncFlag);
    }
    if (message.contextFlag !== undefined) {
      obj.contextFlag = Math.round(message.contextFlag);
    }
    if (message.whisperSessionId !== undefined) {
      obj.whisperSessionId = Math.round(message.whisperSessionId);
    }
    if (message.msgReqType !== undefined) {
      obj.msgReqType = Math.round(message.msgReqType);
    }
    if (message.pubaccountCookie !== undefined) {
      obj.pubaccountCookie = base64FromBytes(message.pubaccountCookie);
    }
    if (message.msgCtrlBuf !== undefined) {
      obj.msgCtrlBuf = base64FromBytes(message.msgCtrlBuf);
    }
    if (message.bytesServerBuf !== undefined) {
      obj.bytesServerBuf = base64FromBytes(message.bytesServerBuf);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<PbGetMsgReq>, I>>(base?: I): PbGetMsgReq {
    return PbGetMsgReq.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<PbGetMsgReq>, I>>(object: I): PbGetMsgReq {
    const message = createBasePbGetMsgReq();
    message.syncFlag = object.syncFlag ?? undefined;
    message.syncCookie = object.syncCookie ?? undefined;
    message.rambleFlag = object.rambleFlag ?? undefined;
    message.latestRambleNumber = object.latestRambleNumber ?? undefined;
    message.otherRambleNumber = object.otherRambleNumber ?? undefined;
    message.onlineSyncFlag = object.onlineSyncFlag ?? undefined;
    message.contextFlag = object.contextFlag ?? undefined;
    message.whisperSessionId = object.whisperSessionId ?? undefined;
    message.msgReqType = object.msgReqType ?? undefined;
    message.pubaccountCookie = object.pubaccountCookie ?? undefined;
    message.msgCtrlBuf = object.msgCtrlBuf ?? undefined;
    message.bytesServerBuf = object.bytesServerBuf ?? undefined;
    return message;
  },
};

function createBasePbGetOneDayRoamMsgReq(): PbGetOneDayRoamMsgReq {
  return { peerUin: undefined, lastMsgtime: undefined, random: undefined, readCnt: undefined };
}

export const PbGetOneDayRoamMsgReq: MessageFns<PbGetOneDayRoamMsgReq> = {
  encode(message: PbGetOneDayRoamMsgReq, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.peerUin !== undefined) {
      writer.uint32(8).uint64(message.peerUin);
    }
    if (message.lastMsgtime !== undefined) {
      writer.uint32(16).uint64(message.lastMsgtime);
    }
    if (message.random !== undefined) {
      writer.uint32(24).uint64(message.random);
    }
    if (message.readCnt !== undefined) {
      writer.uint32(32).uint32(message.readCnt);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PbGetOneDayRoamMsgReq {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePbGetOneDayRoamMsgReq();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.peerUin = longToNumber(reader.uint64());
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.lastMsgtime = longToNumber(reader.uint64());
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.random = longToNumber(reader.uint64());
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.readCnt = reader.uint32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PbGetOneDayRoamMsgReq {
    return {
      peerUin: isSet(object.peerUin) ? globalThis.Number(object.peerUin) : undefined,
      lastMsgtime: isSet(object.lastMsgtime) ? globalThis.Number(object.lastMsgtime) : undefined,
      random: isSet(object.random) ? globalThis.Number(object.random) : undefined,
      readCnt: isSet(object.readCnt) ? globalThis.Number(object.readCnt) : undefined,
    };
  },

  toJSON(message: PbGetOneDayRoamMsgReq): unknown {
    const obj: any = {};
    if (message.peerUin !== undefined) {
      obj.peerUin = Math.round(message.peerUin);
    }
    if (message.lastMsgtime !== undefined) {
      obj.lastMsgtime = Math.round(message.lastMsgtime);
    }
    if (message.random !== undefined) {
      obj.random = Math.round(message.random);
    }
    if (message.readCnt !== undefined) {
      obj.readCnt = Math.round(message.readCnt);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<PbGetOneDayRoamMsgReq>, I>>(base?: I): PbGetOneDayRoamMsgReq {
    return PbGetOneDayRoamMsgReq.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<PbGetOneDayRoamMsgReq>, I>>(object: I): PbGetOneDayRoamMsgReq {
    const message = createBasePbGetOneDayRoamMsgReq();
    message.peerUin = object.peerUin ?? undefined;
    message.lastMsgtime = object.lastMsgtime ?? undefined;
    message.random = object.random ?? undefined;
    message.readCnt = object.readCnt ?? undefined;
    return message;
  },
};

function createBasePbGetOneDayRoamMsgResp(): PbGetOneDayRoamMsgResp {
  return {
    result: undefined,
    errmsg: undefined,
    peerUin: undefined,
    lastMsgtime: undefined,
    random: undefined,
    iscomplete: undefined,
  };
}

export const PbGetOneDayRoamMsgResp: MessageFns<PbGetOneDayRoamMsgResp> = {
  encode(message: PbGetOneDayRoamMsgResp, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.result !== undefined) {
      writer.uint32(8).uint32(message.result);
    }
    if (message.errmsg !== undefined) {
      writer.uint32(18).string(message.errmsg);
    }
    if (message.peerUin !== undefined) {
      writer.uint32(24).uint64(message.peerUin);
    }
    if (message.lastMsgtime !== undefined) {
      writer.uint32(32).uint64(message.lastMsgtime);
    }
    if (message.random !== undefined) {
      writer.uint32(40).uint64(message.random);
    }
    if (message.iscomplete !== undefined) {
      writer.uint32(56).uint32(message.iscomplete);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PbGetOneDayRoamMsgResp {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePbGetOneDayRoamMsgResp();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.result = reader.uint32();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.errmsg = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.peerUin = longToNumber(reader.uint64());
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.lastMsgtime = longToNumber(reader.uint64());
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.random = longToNumber(reader.uint64());
          continue;
        }
        case 7: {
          if (tag !== 56) {
            break;
          }

          message.iscomplete = reader.uint32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PbGetOneDayRoamMsgResp {
    return {
      result: isSet(object.result) ? globalThis.Number(object.result) : undefined,
      errmsg: isSet(object.errmsg) ? globalThis.String(object.errmsg) : undefined,
      peerUin: isSet(object.peerUin) ? globalThis.Number(object.peerUin) : undefined,
      lastMsgtime: isSet(object.lastMsgtime) ? globalThis.Number(object.lastMsgtime) : undefined,
      random: isSet(object.random) ? globalThis.Number(object.random) : undefined,
      iscomplete: isSet(object.iscomplete) ? globalThis.Number(object.iscomplete) : undefined,
    };
  },

  toJSON(message: PbGetOneDayRoamMsgResp): unknown {
    const obj: any = {};
    if (message.result !== undefined) {
      obj.result = Math.round(message.result);
    }
    if (message.errmsg !== undefined) {
      obj.errmsg = message.errmsg;
    }
    if (message.peerUin !== undefined) {
      obj.peerUin = Math.round(message.peerUin);
    }
    if (message.lastMsgtime !== undefined) {
      obj.lastMsgtime = Math.round(message.lastMsgtime);
    }
    if (message.random !== undefined) {
      obj.random = Math.round(message.random);
    }
    if (message.iscomplete !== undefined) {
      obj.iscomplete = Math.round(message.iscomplete);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<PbGetOneDayRoamMsgResp>, I>>(base?: I): PbGetOneDayRoamMsgResp {
    return PbGetOneDayRoamMsgResp.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<PbGetOneDayRoamMsgResp>, I>>(object: I): PbGetOneDayRoamMsgResp {
    const message = createBasePbGetOneDayRoamMsgResp();
    message.result = object.result ?? undefined;
    message.errmsg = object.errmsg ?? undefined;
    message.peerUin = object.peerUin ?? undefined;
    message.lastMsgtime = object.lastMsgtime ?? undefined;
    message.random = object.random ?? undefined;
    message.iscomplete = object.iscomplete ?? undefined;
    return message;
  },
};

function createBasePbGetRoamMsgReq(): PbGetRoamMsgReq {
  return {
    peerUin: undefined,
    lastMsgtime: undefined,
    random: undefined,
    readCnt: undefined,
    checkPwd: undefined,
    sig: undefined,
    pwd: undefined,
    subcmd: undefined,
    beginMsgtime: undefined,
    reqType: undefined,
  };
}

export const PbGetRoamMsgReq: MessageFns<PbGetRoamMsgReq> = {
  encode(message: PbGetRoamMsgReq, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.peerUin !== undefined) {
      writer.uint32(8).uint64(message.peerUin);
    }
    if (message.lastMsgtime !== undefined) {
      writer.uint32(16).uint64(message.lastMsgtime);
    }
    if (message.random !== undefined) {
      writer.uint32(24).uint64(message.random);
    }
    if (message.readCnt !== undefined) {
      writer.uint32(32).uint32(message.readCnt);
    }
    if (message.checkPwd !== undefined) {
      writer.uint32(40).uint32(message.checkPwd);
    }
    if (message.sig !== undefined) {
      writer.uint32(50).bytes(message.sig);
    }
    if (message.pwd !== undefined) {
      writer.uint32(58).bytes(message.pwd);
    }
    if (message.subcmd !== undefined) {
      writer.uint32(64).uint32(message.subcmd);
    }
    if (message.beginMsgtime !== undefined) {
      writer.uint32(72).uint64(message.beginMsgtime);
    }
    if (message.reqType !== undefined) {
      writer.uint32(80).uint32(message.reqType);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PbGetRoamMsgReq {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePbGetRoamMsgReq();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.peerUin = longToNumber(reader.uint64());
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.lastMsgtime = longToNumber(reader.uint64());
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.random = longToNumber(reader.uint64());
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.readCnt = reader.uint32();
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.checkPwd = reader.uint32();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.sig = reader.bytes();
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.pwd = reader.bytes();
          continue;
        }
        case 8: {
          if (tag !== 64) {
            break;
          }

          message.subcmd = reader.uint32();
          continue;
        }
        case 9: {
          if (tag !== 72) {
            break;
          }

          message.beginMsgtime = longToNumber(reader.uint64());
          continue;
        }
        case 10: {
          if (tag !== 80) {
            break;
          }

          message.reqType = reader.uint32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PbGetRoamMsgReq {
    return {
      peerUin: isSet(object.peerUin) ? globalThis.Number(object.peerUin) : undefined,
      lastMsgtime: isSet(object.lastMsgtime) ? globalThis.Number(object.lastMsgtime) : undefined,
      random: isSet(object.random) ? globalThis.Number(object.random) : undefined,
      readCnt: isSet(object.readCnt) ? globalThis.Number(object.readCnt) : undefined,
      checkPwd: isSet(object.checkPwd) ? globalThis.Number(object.checkPwd) : undefined,
      sig: isSet(object.sig) ? bytesFromBase64(object.sig) : undefined,
      pwd: isSet(object.pwd) ? bytesFromBase64(object.pwd) : undefined,
      subcmd: isSet(object.subcmd) ? globalThis.Number(object.subcmd) : undefined,
      beginMsgtime: isSet(object.beginMsgtime) ? globalThis.Number(object.beginMsgtime) : undefined,
      reqType: isSet(object.reqType) ? globalThis.Number(object.reqType) : undefined,
    };
  },

  toJSON(message: PbGetRoamMsgReq): unknown {
    const obj: any = {};
    if (message.peerUin !== undefined) {
      obj.peerUin = Math.round(message.peerUin);
    }
    if (message.lastMsgtime !== undefined) {
      obj.lastMsgtime = Math.round(message.lastMsgtime);
    }
    if (message.random !== undefined) {
      obj.random = Math.round(message.random);
    }
    if (message.readCnt !== undefined) {
      obj.readCnt = Math.round(message.readCnt);
    }
    if (message.checkPwd !== undefined) {
      obj.checkPwd = Math.round(message.checkPwd);
    }
    if (message.sig !== undefined) {
      obj.sig = base64FromBytes(message.sig);
    }
    if (message.pwd !== undefined) {
      obj.pwd = base64FromBytes(message.pwd);
    }
    if (message.subcmd !== undefined) {
      obj.subcmd = Math.round(message.subcmd);
    }
    if (message.beginMsgtime !== undefined) {
      obj.beginMsgtime = Math.round(message.beginMsgtime);
    }
    if (message.reqType !== undefined) {
      obj.reqType = Math.round(message.reqType);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<PbGetRoamMsgReq>, I>>(base?: I): PbGetRoamMsgReq {
    return PbGetRoamMsgReq.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<PbGetRoamMsgReq>, I>>(object: I): PbGetRoamMsgReq {
    const message = createBasePbGetRoamMsgReq();
    message.peerUin = object.peerUin ?? undefined;
    message.lastMsgtime = object.lastMsgtime ?? undefined;
    message.random = object.random ?? undefined;
    message.readCnt = object.readCnt ?? undefined;
    message.checkPwd = object.checkPwd ?? undefined;
    message.sig = object.sig ?? undefined;
    message.pwd = object.pwd ?? undefined;
    message.subcmd = object.subcmd ?? undefined;
    message.beginMsgtime = object.beginMsgtime ?? undefined;
    message.reqType = object.reqType ?? undefined;
    return message;
  },
};

function createBasePbGetRoamMsgResp(): PbGetRoamMsgResp {
  return {
    result: undefined,
    errmsg: undefined,
    peerUin: undefined,
    lastMsgtime: undefined,
    random: undefined,
    sig: undefined,
  };
}

export const PbGetRoamMsgResp: MessageFns<PbGetRoamMsgResp> = {
  encode(message: PbGetRoamMsgResp, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.result !== undefined) {
      writer.uint32(8).uint32(message.result);
    }
    if (message.errmsg !== undefined) {
      writer.uint32(18).string(message.errmsg);
    }
    if (message.peerUin !== undefined) {
      writer.uint32(24).uint64(message.peerUin);
    }
    if (message.lastMsgtime !== undefined) {
      writer.uint32(32).uint64(message.lastMsgtime);
    }
    if (message.random !== undefined) {
      writer.uint32(40).uint64(message.random);
    }
    if (message.sig !== undefined) {
      writer.uint32(58).bytes(message.sig);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PbGetRoamMsgResp {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePbGetRoamMsgResp();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.result = reader.uint32();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.errmsg = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.peerUin = longToNumber(reader.uint64());
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.lastMsgtime = longToNumber(reader.uint64());
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.random = longToNumber(reader.uint64());
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.sig = reader.bytes();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PbGetRoamMsgResp {
    return {
      result: isSet(object.result) ? globalThis.Number(object.result) : undefined,
      errmsg: isSet(object.errmsg) ? globalThis.String(object.errmsg) : undefined,
      peerUin: isSet(object.peerUin) ? globalThis.Number(object.peerUin) : undefined,
      lastMsgtime: isSet(object.lastMsgtime) ? globalThis.Number(object.lastMsgtime) : undefined,
      random: isSet(object.random) ? globalThis.Number(object.random) : undefined,
      sig: isSet(object.sig) ? bytesFromBase64(object.sig) : undefined,
    };
  },

  toJSON(message: PbGetRoamMsgResp): unknown {
    const obj: any = {};
    if (message.result !== undefined) {
      obj.result = Math.round(message.result);
    }
    if (message.errmsg !== undefined) {
      obj.errmsg = message.errmsg;
    }
    if (message.peerUin !== undefined) {
      obj.peerUin = Math.round(message.peerUin);
    }
    if (message.lastMsgtime !== undefined) {
      obj.lastMsgtime = Math.round(message.lastMsgtime);
    }
    if (message.random !== undefined) {
      obj.random = Math.round(message.random);
    }
    if (message.sig !== undefined) {
      obj.sig = base64FromBytes(message.sig);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<PbGetRoamMsgResp>, I>>(base?: I): PbGetRoamMsgResp {
    return PbGetRoamMsgResp.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<PbGetRoamMsgResp>, I>>(object: I): PbGetRoamMsgResp {
    const message = createBasePbGetRoamMsgResp();
    message.result = object.result ?? undefined;
    message.errmsg = object.errmsg ?? undefined;
    message.peerUin = object.peerUin ?? undefined;
    message.lastMsgtime = object.lastMsgtime ?? undefined;
    message.random = object.random ?? undefined;
    message.sig = object.sig ?? undefined;
    return message;
  },
};

function createBasePbGroupMsgWithDrawReqMessageInfo(): PbGroupMsgWithDrawReqMessageInfo {
  return { uint32MsgSeq: undefined, uint32MsgRandom: undefined, uint32MsgType: undefined, uint32ResvFlag: undefined };
}

export const PbGroupMsgWithDrawReqMessageInfo: MessageFns<PbGroupMsgWithDrawReqMessageInfo> = {
  encode(message: PbGroupMsgWithDrawReqMessageInfo, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.uint32MsgSeq !== undefined) {
      writer.uint32(8).uint32(message.uint32MsgSeq);
    }
    if (message.uint32MsgRandom !== undefined) {
      writer.uint32(16).uint32(message.uint32MsgRandom);
    }
    if (message.uint32MsgType !== undefined) {
      writer.uint32(24).uint32(message.uint32MsgType);
    }
    if (message.uint32ResvFlag !== undefined) {
      writer.uint32(32).uint32(message.uint32ResvFlag);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PbGroupMsgWithDrawReqMessageInfo {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePbGroupMsgWithDrawReqMessageInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.uint32MsgSeq = reader.uint32();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.uint32MsgRandom = reader.uint32();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.uint32MsgType = reader.uint32();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.uint32ResvFlag = reader.uint32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PbGroupMsgWithDrawReqMessageInfo {
    return {
      uint32MsgSeq: isSet(object.uint32MsgSeq) ? globalThis.Number(object.uint32MsgSeq) : undefined,
      uint32MsgRandom: isSet(object.uint32MsgRandom) ? globalThis.Number(object.uint32MsgRandom) : undefined,
      uint32MsgType: isSet(object.uint32MsgType) ? globalThis.Number(object.uint32MsgType) : undefined,
      uint32ResvFlag: isSet(object.uint32ResvFlag) ? globalThis.Number(object.uint32ResvFlag) : undefined,
    };
  },

  toJSON(message: PbGroupMsgWithDrawReqMessageInfo): unknown {
    const obj: any = {};
    if (message.uint32MsgSeq !== undefined) {
      obj.uint32MsgSeq = Math.round(message.uint32MsgSeq);
    }
    if (message.uint32MsgRandom !== undefined) {
      obj.uint32MsgRandom = Math.round(message.uint32MsgRandom);
    }
    if (message.uint32MsgType !== undefined) {
      obj.uint32MsgType = Math.round(message.uint32MsgType);
    }
    if (message.uint32ResvFlag !== undefined) {
      obj.uint32ResvFlag = Math.round(message.uint32ResvFlag);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<PbGroupMsgWithDrawReqMessageInfo>, I>>(
    base?: I,
  ): PbGroupMsgWithDrawReqMessageInfo {
    return PbGroupMsgWithDrawReqMessageInfo.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<PbGroupMsgWithDrawReqMessageInfo>, I>>(
    object: I,
  ): PbGroupMsgWithDrawReqMessageInfo {
    const message = createBasePbGroupMsgWithDrawReqMessageInfo();
    message.uint32MsgSeq = object.uint32MsgSeq ?? undefined;
    message.uint32MsgRandom = object.uint32MsgRandom ?? undefined;
    message.uint32MsgType = object.uint32MsgType ?? undefined;
    message.uint32ResvFlag = object.uint32ResvFlag ?? undefined;
    return message;
  },
};

function createBasePbGroupMsgWithDrawReq(): PbGroupMsgWithDrawReq {
  return {
    uint32SubCmd: undefined,
    uint32GroupType: undefined,
    uint64GroupCode: undefined,
    msgList: [],
    bytesUserdef: undefined,
  };
}

export const PbGroupMsgWithDrawReq: MessageFns<PbGroupMsgWithDrawReq> = {
  encode(message: PbGroupMsgWithDrawReq, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.uint32SubCmd !== undefined) {
      writer.uint32(8).uint32(message.uint32SubCmd);
    }
    if (message.uint32GroupType !== undefined) {
      writer.uint32(16).uint32(message.uint32GroupType);
    }
    if (message.uint64GroupCode !== undefined) {
      writer.uint32(24).uint64(message.uint64GroupCode);
    }
    for (const v of message.msgList) {
      PbGroupMsgWithDrawReqMessageInfo.encode(v!, writer.uint32(34).fork()).join();
    }
    if (message.bytesUserdef !== undefined) {
      writer.uint32(42).bytes(message.bytesUserdef);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PbGroupMsgWithDrawReq {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePbGroupMsgWithDrawReq();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.uint32SubCmd = reader.uint32();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.uint32GroupType = reader.uint32();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.uint64GroupCode = longToNumber(reader.uint64());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.msgList.push(PbGroupMsgWithDrawReqMessageInfo.decode(reader, reader.uint32()));
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.bytesUserdef = reader.bytes();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PbGroupMsgWithDrawReq {
    return {
      uint32SubCmd: isSet(object.uint32SubCmd) ? globalThis.Number(object.uint32SubCmd) : undefined,
      uint32GroupType: isSet(object.uint32GroupType) ? globalThis.Number(object.uint32GroupType) : undefined,
      uint64GroupCode: isSet(object.uint64GroupCode) ? globalThis.Number(object.uint64GroupCode) : undefined,
      msgList: globalThis.Array.isArray(object?.msgList)
        ? object.msgList.map((e: any) => PbGroupMsgWithDrawReqMessageInfo.fromJSON(e))
        : [],
      bytesUserdef: isSet(object.bytesUserdef) ? bytesFromBase64(object.bytesUserdef) : undefined,
    };
  },

  toJSON(message: PbGroupMsgWithDrawReq): unknown {
    const obj: any = {};
    if (message.uint32SubCmd !== undefined) {
      obj.uint32SubCmd = Math.round(message.uint32SubCmd);
    }
    if (message.uint32GroupType !== undefined) {
      obj.uint32GroupType = Math.round(message.uint32GroupType);
    }
    if (message.uint64GroupCode !== undefined) {
      obj.uint64GroupCode = Math.round(message.uint64GroupCode);
    }
    if (message.msgList?.length) {
      obj.msgList = message.msgList.map((e) => PbGroupMsgWithDrawReqMessageInfo.toJSON(e));
    }
    if (message.bytesUserdef !== undefined) {
      obj.bytesUserdef = base64FromBytes(message.bytesUserdef);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<PbGroupMsgWithDrawReq>, I>>(base?: I): PbGroupMsgWithDrawReq {
    return PbGroupMsgWithDrawReq.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<PbGroupMsgWithDrawReq>, I>>(object: I): PbGroupMsgWithDrawReq {
    const message = createBasePbGroupMsgWithDrawReq();
    message.uint32SubCmd = object.uint32SubCmd ?? undefined;
    message.uint32GroupType = object.uint32GroupType ?? undefined;
    message.uint64GroupCode = object.uint64GroupCode ?? undefined;
    message.msgList = object.msgList?.map((e) => PbGroupMsgWithDrawReqMessageInfo.fromPartial(e)) || [];
    message.bytesUserdef = object.bytesUserdef ?? undefined;
    return message;
  },
};

function createBasePbGroupMsgWithDrawRespMessageResult(): PbGroupMsgWithDrawRespMessageResult {
  return {
    uint32Result: undefined,
    uint32MsgSeq: undefined,
    uint32MsgTime: undefined,
    uint32MsgRandom: undefined,
    bytesErrMsg: undefined,
    uint32MsgType: undefined,
  };
}

export const PbGroupMsgWithDrawRespMessageResult: MessageFns<PbGroupMsgWithDrawRespMessageResult> = {
  encode(message: PbGroupMsgWithDrawRespMessageResult, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.uint32Result !== undefined) {
      writer.uint32(8).uint32(message.uint32Result);
    }
    if (message.uint32MsgSeq !== undefined) {
      writer.uint32(16).uint32(message.uint32MsgSeq);
    }
    if (message.uint32MsgTime !== undefined) {
      writer.uint32(24).uint32(message.uint32MsgTime);
    }
    if (message.uint32MsgRandom !== undefined) {
      writer.uint32(32).uint32(message.uint32MsgRandom);
    }
    if (message.bytesErrMsg !== undefined) {
      writer.uint32(42).bytes(message.bytesErrMsg);
    }
    if (message.uint32MsgType !== undefined) {
      writer.uint32(48).uint32(message.uint32MsgType);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PbGroupMsgWithDrawRespMessageResult {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePbGroupMsgWithDrawRespMessageResult();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.uint32Result = reader.uint32();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.uint32MsgSeq = reader.uint32();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.uint32MsgTime = reader.uint32();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.uint32MsgRandom = reader.uint32();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.bytesErrMsg = reader.bytes();
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.uint32MsgType = reader.uint32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PbGroupMsgWithDrawRespMessageResult {
    return {
      uint32Result: isSet(object.uint32Result) ? globalThis.Number(object.uint32Result) : undefined,
      uint32MsgSeq: isSet(object.uint32MsgSeq) ? globalThis.Number(object.uint32MsgSeq) : undefined,
      uint32MsgTime: isSet(object.uint32MsgTime) ? globalThis.Number(object.uint32MsgTime) : undefined,
      uint32MsgRandom: isSet(object.uint32MsgRandom) ? globalThis.Number(object.uint32MsgRandom) : undefined,
      bytesErrMsg: isSet(object.bytesErrMsg) ? bytesFromBase64(object.bytesErrMsg) : undefined,
      uint32MsgType: isSet(object.uint32MsgType) ? globalThis.Number(object.uint32MsgType) : undefined,
    };
  },

  toJSON(message: PbGroupMsgWithDrawRespMessageResult): unknown {
    const obj: any = {};
    if (message.uint32Result !== undefined) {
      obj.uint32Result = Math.round(message.uint32Result);
    }
    if (message.uint32MsgSeq !== undefined) {
      obj.uint32MsgSeq = Math.round(message.uint32MsgSeq);
    }
    if (message.uint32MsgTime !== undefined) {
      obj.uint32MsgTime = Math.round(message.uint32MsgTime);
    }
    if (message.uint32MsgRandom !== undefined) {
      obj.uint32MsgRandom = Math.round(message.uint32MsgRandom);
    }
    if (message.bytesErrMsg !== undefined) {
      obj.bytesErrMsg = base64FromBytes(message.bytesErrMsg);
    }
    if (message.uint32MsgType !== undefined) {
      obj.uint32MsgType = Math.round(message.uint32MsgType);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<PbGroupMsgWithDrawRespMessageResult>, I>>(
    base?: I,
  ): PbGroupMsgWithDrawRespMessageResult {
    return PbGroupMsgWithDrawRespMessageResult.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<PbGroupMsgWithDrawRespMessageResult>, I>>(
    object: I,
  ): PbGroupMsgWithDrawRespMessageResult {
    const message = createBasePbGroupMsgWithDrawRespMessageResult();
    message.uint32Result = object.uint32Result ?? undefined;
    message.uint32MsgSeq = object.uint32MsgSeq ?? undefined;
    message.uint32MsgTime = object.uint32MsgTime ?? undefined;
    message.uint32MsgRandom = object.uint32MsgRandom ?? undefined;
    message.bytesErrMsg = object.bytesErrMsg ?? undefined;
    message.uint32MsgType = object.uint32MsgType ?? undefined;
    return message;
  },
};

function createBasePbGroupMsgWithDrawResp(): PbGroupMsgWithDrawResp {
  return {
    result: undefined,
    errmsg: undefined,
    uint32SubCmd: undefined,
    uint32GroupType: undefined,
    uint64GroupCode: undefined,
    failedMsgList: [],
    bytesUserdef: undefined,
    msgWordingInfo: undefined,
  };
}

export const PbGroupMsgWithDrawResp: MessageFns<PbGroupMsgWithDrawResp> = {
  encode(message: PbGroupMsgWithDrawResp, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.result !== undefined) {
      writer.uint32(8).uint32(message.result);
    }
    if (message.errmsg !== undefined) {
      writer.uint32(18).string(message.errmsg);
    }
    if (message.uint32SubCmd !== undefined) {
      writer.uint32(24).uint32(message.uint32SubCmd);
    }
    if (message.uint32GroupType !== undefined) {
      writer.uint32(32).uint32(message.uint32GroupType);
    }
    if (message.uint64GroupCode !== undefined) {
      writer.uint32(40).uint64(message.uint64GroupCode);
    }
    for (const v of message.failedMsgList) {
      PbGroupMsgWithDrawRespMessageResult.encode(v!, writer.uint32(50).fork()).join();
    }
    if (message.bytesUserdef !== undefined) {
      writer.uint32(58).bytes(message.bytesUserdef);
    }
    if (message.msgWordingInfo !== undefined) {
      WithDrawWordingInfo.encode(message.msgWordingInfo, writer.uint32(66).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PbGroupMsgWithDrawResp {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePbGroupMsgWithDrawResp();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.result = reader.uint32();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.errmsg = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.uint32SubCmd = reader.uint32();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.uint32GroupType = reader.uint32();
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.uint64GroupCode = longToNumber(reader.uint64());
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.failedMsgList.push(PbGroupMsgWithDrawRespMessageResult.decode(reader, reader.uint32()));
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.bytesUserdef = reader.bytes();
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.msgWordingInfo = WithDrawWordingInfo.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PbGroupMsgWithDrawResp {
    return {
      result: isSet(object.result) ? globalThis.Number(object.result) : undefined,
      errmsg: isSet(object.errmsg) ? globalThis.String(object.errmsg) : undefined,
      uint32SubCmd: isSet(object.uint32SubCmd) ? globalThis.Number(object.uint32SubCmd) : undefined,
      uint32GroupType: isSet(object.uint32GroupType) ? globalThis.Number(object.uint32GroupType) : undefined,
      uint64GroupCode: isSet(object.uint64GroupCode) ? globalThis.Number(object.uint64GroupCode) : undefined,
      failedMsgList: globalThis.Array.isArray(object?.failedMsgList)
        ? object.failedMsgList.map((e: any) => PbGroupMsgWithDrawRespMessageResult.fromJSON(e))
        : [],
      bytesUserdef: isSet(object.bytesUserdef) ? bytesFromBase64(object.bytesUserdef) : undefined,
      msgWordingInfo: isSet(object.msgWordingInfo) ? WithDrawWordingInfo.fromJSON(object.msgWordingInfo) : undefined,
    };
  },

  toJSON(message: PbGroupMsgWithDrawResp): unknown {
    const obj: any = {};
    if (message.result !== undefined) {
      obj.result = Math.round(message.result);
    }
    if (message.errmsg !== undefined) {
      obj.errmsg = message.errmsg;
    }
    if (message.uint32SubCmd !== undefined) {
      obj.uint32SubCmd = Math.round(message.uint32SubCmd);
    }
    if (message.uint32GroupType !== undefined) {
      obj.uint32GroupType = Math.round(message.uint32GroupType);
    }
    if (message.uint64GroupCode !== undefined) {
      obj.uint64GroupCode = Math.round(message.uint64GroupCode);
    }
    if (message.failedMsgList?.length) {
      obj.failedMsgList = message.failedMsgList.map((e) => PbGroupMsgWithDrawRespMessageResult.toJSON(e));
    }
    if (message.bytesUserdef !== undefined) {
      obj.bytesUserdef = base64FromBytes(message.bytesUserdef);
    }
    if (message.msgWordingInfo !== undefined) {
      obj.msgWordingInfo = WithDrawWordingInfo.toJSON(message.msgWordingInfo);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<PbGroupMsgWithDrawResp>, I>>(base?: I): PbGroupMsgWithDrawResp {
    return PbGroupMsgWithDrawResp.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<PbGroupMsgWithDrawResp>, I>>(object: I): PbGroupMsgWithDrawResp {
    const message = createBasePbGroupMsgWithDrawResp();
    message.result = object.result ?? undefined;
    message.errmsg = object.errmsg ?? undefined;
    message.uint32SubCmd = object.uint32SubCmd ?? undefined;
    message.uint32GroupType = object.uint32GroupType ?? undefined;
    message.uint64GroupCode = object.uint64GroupCode ?? undefined;
    message.failedMsgList = object.failedMsgList?.map((e) => PbGroupMsgWithDrawRespMessageResult.fromPartial(e)) || [];
    message.bytesUserdef = object.bytesUserdef ?? undefined;
    message.msgWordingInfo = (object.msgWordingInfo !== undefined && object.msgWordingInfo !== null)
      ? WithDrawWordingInfo.fromPartial(object.msgWordingInfo)
      : undefined;
    return message;
  },
};

function createBasePbGroupReadedReportReq(): PbGroupReadedReportReq {
  return { groupCode: undefined, lastReadSeq: undefined };
}

export const PbGroupReadedReportReq: MessageFns<PbGroupReadedReportReq> = {
  encode(message: PbGroupReadedReportReq, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.groupCode !== undefined) {
      writer.uint32(8).uint64(message.groupCode);
    }
    if (message.lastReadSeq !== undefined) {
      writer.uint32(16).uint64(message.lastReadSeq);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PbGroupReadedReportReq {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePbGroupReadedReportReq();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.groupCode = longToNumber(reader.uint64());
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.lastReadSeq = longToNumber(reader.uint64());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PbGroupReadedReportReq {
    return {
      groupCode: isSet(object.groupCode) ? globalThis.Number(object.groupCode) : undefined,
      lastReadSeq: isSet(object.lastReadSeq) ? globalThis.Number(object.lastReadSeq) : undefined,
    };
  },

  toJSON(message: PbGroupReadedReportReq): unknown {
    const obj: any = {};
    if (message.groupCode !== undefined) {
      obj.groupCode = Math.round(message.groupCode);
    }
    if (message.lastReadSeq !== undefined) {
      obj.lastReadSeq = Math.round(message.lastReadSeq);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<PbGroupReadedReportReq>, I>>(base?: I): PbGroupReadedReportReq {
    return PbGroupReadedReportReq.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<PbGroupReadedReportReq>, I>>(object: I): PbGroupReadedReportReq {
    const message = createBasePbGroupReadedReportReq();
    message.groupCode = object.groupCode ?? undefined;
    message.lastReadSeq = object.lastReadSeq ?? undefined;
    return message;
  },
};

function createBasePbGroupReadedReportResp(): PbGroupReadedReportResp {
  return { result: undefined, errmsg: undefined, groupCode: undefined, memberSeq: undefined, groupMsgSeq: undefined };
}

export const PbGroupReadedReportResp: MessageFns<PbGroupReadedReportResp> = {
  encode(message: PbGroupReadedReportResp, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.result !== undefined) {
      writer.uint32(8).uint32(message.result);
    }
    if (message.errmsg !== undefined) {
      writer.uint32(18).string(message.errmsg);
    }
    if (message.groupCode !== undefined) {
      writer.uint32(24).uint64(message.groupCode);
    }
    if (message.memberSeq !== undefined) {
      writer.uint32(32).uint64(message.memberSeq);
    }
    if (message.groupMsgSeq !== undefined) {
      writer.uint32(40).uint64(message.groupMsgSeq);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PbGroupReadedReportResp {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePbGroupReadedReportResp();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.result = reader.uint32();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.errmsg = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.groupCode = longToNumber(reader.uint64());
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.memberSeq = longToNumber(reader.uint64());
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.groupMsgSeq = longToNumber(reader.uint64());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PbGroupReadedReportResp {
    return {
      result: isSet(object.result) ? globalThis.Number(object.result) : undefined,
      errmsg: isSet(object.errmsg) ? globalThis.String(object.errmsg) : undefined,
      groupCode: isSet(object.groupCode) ? globalThis.Number(object.groupCode) : undefined,
      memberSeq: isSet(object.memberSeq) ? globalThis.Number(object.memberSeq) : undefined,
      groupMsgSeq: isSet(object.groupMsgSeq) ? globalThis.Number(object.groupMsgSeq) : undefined,
    };
  },

  toJSON(message: PbGroupReadedReportResp): unknown {
    const obj: any = {};
    if (message.result !== undefined) {
      obj.result = Math.round(message.result);
    }
    if (message.errmsg !== undefined) {
      obj.errmsg = message.errmsg;
    }
    if (message.groupCode !== undefined) {
      obj.groupCode = Math.round(message.groupCode);
    }
    if (message.memberSeq !== undefined) {
      obj.memberSeq = Math.round(message.memberSeq);
    }
    if (message.groupMsgSeq !== undefined) {
      obj.groupMsgSeq = Math.round(message.groupMsgSeq);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<PbGroupReadedReportResp>, I>>(base?: I): PbGroupReadedReportResp {
    return PbGroupReadedReportResp.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<PbGroupReadedReportResp>, I>>(object: I): PbGroupReadedReportResp {
    const message = createBasePbGroupReadedReportResp();
    message.result = object.result ?? undefined;
    message.errmsg = object.errmsg ?? undefined;
    message.groupCode = object.groupCode ?? undefined;
    message.memberSeq = object.memberSeq ?? undefined;
    message.groupMsgSeq = object.groupMsgSeq ?? undefined;
    return message;
  },
};

function createBasePbInputNotifyInfo(): PbInputNotifyInfo {
  return {
    toUin: undefined,
    ime: undefined,
    notifyFlag: undefined,
    bytesPbReserve: undefined,
    iosPushWording: undefined,
  };
}

export const PbInputNotifyInfo: MessageFns<PbInputNotifyInfo> = {
  encode(message: PbInputNotifyInfo, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.toUin !== undefined) {
      writer.uint32(8).uint64(message.toUin);
    }
    if (message.ime !== undefined) {
      writer.uint32(16).uint32(message.ime);
    }
    if (message.notifyFlag !== undefined) {
      writer.uint32(24).uint32(message.notifyFlag);
    }
    if (message.bytesPbReserve !== undefined) {
      writer.uint32(34).bytes(message.bytesPbReserve);
    }
    if (message.iosPushWording !== undefined) {
      writer.uint32(42).bytes(message.iosPushWording);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PbInputNotifyInfo {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePbInputNotifyInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.toUin = longToNumber(reader.uint64());
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.ime = reader.uint32();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.notifyFlag = reader.uint32();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.bytesPbReserve = reader.bytes();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.iosPushWording = reader.bytes();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PbInputNotifyInfo {
    return {
      toUin: isSet(object.toUin) ? globalThis.Number(object.toUin) : undefined,
      ime: isSet(object.ime) ? globalThis.Number(object.ime) : undefined,
      notifyFlag: isSet(object.notifyFlag) ? globalThis.Number(object.notifyFlag) : undefined,
      bytesPbReserve: isSet(object.bytesPbReserve) ? bytesFromBase64(object.bytesPbReserve) : undefined,
      iosPushWording: isSet(object.iosPushWording) ? bytesFromBase64(object.iosPushWording) : undefined,
    };
  },

  toJSON(message: PbInputNotifyInfo): unknown {
    const obj: any = {};
    if (message.toUin !== undefined) {
      obj.toUin = Math.round(message.toUin);
    }
    if (message.ime !== undefined) {
      obj.ime = Math.round(message.ime);
    }
    if (message.notifyFlag !== undefined) {
      obj.notifyFlag = Math.round(message.notifyFlag);
    }
    if (message.bytesPbReserve !== undefined) {
      obj.bytesPbReserve = base64FromBytes(message.bytesPbReserve);
    }
    if (message.iosPushWording !== undefined) {
      obj.iosPushWording = base64FromBytes(message.iosPushWording);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<PbInputNotifyInfo>, I>>(base?: I): PbInputNotifyInfo {
    return PbInputNotifyInfo.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<PbInputNotifyInfo>, I>>(object: I): PbInputNotifyInfo {
    const message = createBasePbInputNotifyInfo();
    message.toUin = object.toUin ?? undefined;
    message.ime = object.ime ?? undefined;
    message.notifyFlag = object.notifyFlag ?? undefined;
    message.bytesPbReserve = object.bytesPbReserve ?? undefined;
    message.iosPushWording = object.iosPushWording ?? undefined;
    return message;
  },
};

function createBasePbMsgReadedReportReq(): PbMsgReadedReportReq {
  return { grpReadReport: [], disReadReport: [], c2cReadReport: undefined, bindUinReadReport: undefined };
}

export const PbMsgReadedReportReq: MessageFns<PbMsgReadedReportReq> = {
  encode(message: PbMsgReadedReportReq, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.grpReadReport) {
      PbGroupReadedReportReq.encode(v!, writer.uint32(10).fork()).join();
    }
    for (const v of message.disReadReport) {
      PbDiscussReadedReportReq.encode(v!, writer.uint32(18).fork()).join();
    }
    if (message.c2cReadReport !== undefined) {
      PbC2CReadedReportReq.encode(message.c2cReadReport, writer.uint32(26).fork()).join();
    }
    if (message.bindUinReadReport !== undefined) {
      PbBindUinMsgReadedConfirmReq.encode(message.bindUinReadReport, writer.uint32(34).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PbMsgReadedReportReq {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePbMsgReadedReportReq();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.grpReadReport.push(PbGroupReadedReportReq.decode(reader, reader.uint32()));
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.disReadReport.push(PbDiscussReadedReportReq.decode(reader, reader.uint32()));
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.c2cReadReport = PbC2CReadedReportReq.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.bindUinReadReport = PbBindUinMsgReadedConfirmReq.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PbMsgReadedReportReq {
    return {
      grpReadReport: globalThis.Array.isArray(object?.grpReadReport)
        ? object.grpReadReport.map((e: any) => PbGroupReadedReportReq.fromJSON(e))
        : [],
      disReadReport: globalThis.Array.isArray(object?.disReadReport)
        ? object.disReadReport.map((e: any) => PbDiscussReadedReportReq.fromJSON(e))
        : [],
      c2cReadReport: isSet(object.c2cReadReport) ? PbC2CReadedReportReq.fromJSON(object.c2cReadReport) : undefined,
      bindUinReadReport: isSet(object.bindUinReadReport)
        ? PbBindUinMsgReadedConfirmReq.fromJSON(object.bindUinReadReport)
        : undefined,
    };
  },

  toJSON(message: PbMsgReadedReportReq): unknown {
    const obj: any = {};
    if (message.grpReadReport?.length) {
      obj.grpReadReport = message.grpReadReport.map((e) => PbGroupReadedReportReq.toJSON(e));
    }
    if (message.disReadReport?.length) {
      obj.disReadReport = message.disReadReport.map((e) => PbDiscussReadedReportReq.toJSON(e));
    }
    if (message.c2cReadReport !== undefined) {
      obj.c2cReadReport = PbC2CReadedReportReq.toJSON(message.c2cReadReport);
    }
    if (message.bindUinReadReport !== undefined) {
      obj.bindUinReadReport = PbBindUinMsgReadedConfirmReq.toJSON(message.bindUinReadReport);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<PbMsgReadedReportReq>, I>>(base?: I): PbMsgReadedReportReq {
    return PbMsgReadedReportReq.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<PbMsgReadedReportReq>, I>>(object: I): PbMsgReadedReportReq {
    const message = createBasePbMsgReadedReportReq();
    message.grpReadReport = object.grpReadReport?.map((e) => PbGroupReadedReportReq.fromPartial(e)) || [];
    message.disReadReport = object.disReadReport?.map((e) => PbDiscussReadedReportReq.fromPartial(e)) || [];
    message.c2cReadReport = (object.c2cReadReport !== undefined && object.c2cReadReport !== null)
      ? PbC2CReadedReportReq.fromPartial(object.c2cReadReport)
      : undefined;
    message.bindUinReadReport = (object.bindUinReadReport !== undefined && object.bindUinReadReport !== null)
      ? PbBindUinMsgReadedConfirmReq.fromPartial(object.bindUinReadReport)
      : undefined;
    return message;
  },
};

function createBasePbMsgReadedReportResp(): PbMsgReadedReportResp {
  return { grpReadReport: [], disReadReport: [], c2cReadReport: undefined, bindUinReadReport: undefined };
}

export const PbMsgReadedReportResp: MessageFns<PbMsgReadedReportResp> = {
  encode(message: PbMsgReadedReportResp, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.grpReadReport) {
      PbGroupReadedReportResp.encode(v!, writer.uint32(10).fork()).join();
    }
    for (const v of message.disReadReport) {
      PbDiscussReadedReportResp.encode(v!, writer.uint32(18).fork()).join();
    }
    if (message.c2cReadReport !== undefined) {
      PbC2CReadedReportResp.encode(message.c2cReadReport, writer.uint32(26).fork()).join();
    }
    if (message.bindUinReadReport !== undefined) {
      PbBindUinMsgReadedConfirmResp.encode(message.bindUinReadReport, writer.uint32(34).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PbMsgReadedReportResp {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePbMsgReadedReportResp();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.grpReadReport.push(PbGroupReadedReportResp.decode(reader, reader.uint32()));
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.disReadReport.push(PbDiscussReadedReportResp.decode(reader, reader.uint32()));
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.c2cReadReport = PbC2CReadedReportResp.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.bindUinReadReport = PbBindUinMsgReadedConfirmResp.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PbMsgReadedReportResp {
    return {
      grpReadReport: globalThis.Array.isArray(object?.grpReadReport)
        ? object.grpReadReport.map((e: any) => PbGroupReadedReportResp.fromJSON(e))
        : [],
      disReadReport: globalThis.Array.isArray(object?.disReadReport)
        ? object.disReadReport.map((e: any) => PbDiscussReadedReportResp.fromJSON(e))
        : [],
      c2cReadReport: isSet(object.c2cReadReport) ? PbC2CReadedReportResp.fromJSON(object.c2cReadReport) : undefined,
      bindUinReadReport: isSet(object.bindUinReadReport)
        ? PbBindUinMsgReadedConfirmResp.fromJSON(object.bindUinReadReport)
        : undefined,
    };
  },

  toJSON(message: PbMsgReadedReportResp): unknown {
    const obj: any = {};
    if (message.grpReadReport?.length) {
      obj.grpReadReport = message.grpReadReport.map((e) => PbGroupReadedReportResp.toJSON(e));
    }
    if (message.disReadReport?.length) {
      obj.disReadReport = message.disReadReport.map((e) => PbDiscussReadedReportResp.toJSON(e));
    }
    if (message.c2cReadReport !== undefined) {
      obj.c2cReadReport = PbC2CReadedReportResp.toJSON(message.c2cReadReport);
    }
    if (message.bindUinReadReport !== undefined) {
      obj.bindUinReadReport = PbBindUinMsgReadedConfirmResp.toJSON(message.bindUinReadReport);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<PbMsgReadedReportResp>, I>>(base?: I): PbMsgReadedReportResp {
    return PbMsgReadedReportResp.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<PbMsgReadedReportResp>, I>>(object: I): PbMsgReadedReportResp {
    const message = createBasePbMsgReadedReportResp();
    message.grpReadReport = object.grpReadReport?.map((e) => PbGroupReadedReportResp.fromPartial(e)) || [];
    message.disReadReport = object.disReadReport?.map((e) => PbDiscussReadedReportResp.fromPartial(e)) || [];
    message.c2cReadReport = (object.c2cReadReport !== undefined && object.c2cReadReport !== null)
      ? PbC2CReadedReportResp.fromPartial(object.c2cReadReport)
      : undefined;
    message.bindUinReadReport = (object.bindUinReadReport !== undefined && object.bindUinReadReport !== null)
      ? PbBindUinMsgReadedConfirmResp.fromPartial(object.bindUinReadReport)
      : undefined;
    return message;
  },
};

function createBasePbMsgWithDrawReq(): PbMsgWithDrawReq {
  return { c2cWithDraw: [], groupWithDraw: [] };
}

export const PbMsgWithDrawReq: MessageFns<PbMsgWithDrawReq> = {
  encode(message: PbMsgWithDrawReq, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.c2cWithDraw) {
      PbC2CMsgWithDrawReq.encode(v!, writer.uint32(10).fork()).join();
    }
    for (const v of message.groupWithDraw) {
      PbGroupMsgWithDrawReq.encode(v!, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PbMsgWithDrawReq {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePbMsgWithDrawReq();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.c2cWithDraw.push(PbC2CMsgWithDrawReq.decode(reader, reader.uint32()));
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.groupWithDraw.push(PbGroupMsgWithDrawReq.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PbMsgWithDrawReq {
    return {
      c2cWithDraw: globalThis.Array.isArray(object?.c2cWithDraw)
        ? object.c2cWithDraw.map((e: any) => PbC2CMsgWithDrawReq.fromJSON(e))
        : [],
      groupWithDraw: globalThis.Array.isArray(object?.groupWithDraw)
        ? object.groupWithDraw.map((e: any) => PbGroupMsgWithDrawReq.fromJSON(e))
        : [],
    };
  },

  toJSON(message: PbMsgWithDrawReq): unknown {
    const obj: any = {};
    if (message.c2cWithDraw?.length) {
      obj.c2cWithDraw = message.c2cWithDraw.map((e) => PbC2CMsgWithDrawReq.toJSON(e));
    }
    if (message.groupWithDraw?.length) {
      obj.groupWithDraw = message.groupWithDraw.map((e) => PbGroupMsgWithDrawReq.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<PbMsgWithDrawReq>, I>>(base?: I): PbMsgWithDrawReq {
    return PbMsgWithDrawReq.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<PbMsgWithDrawReq>, I>>(object: I): PbMsgWithDrawReq {
    const message = createBasePbMsgWithDrawReq();
    message.c2cWithDraw = object.c2cWithDraw?.map((e) => PbC2CMsgWithDrawReq.fromPartial(e)) || [];
    message.groupWithDraw = object.groupWithDraw?.map((e) => PbGroupMsgWithDrawReq.fromPartial(e)) || [];
    return message;
  },
};

function createBasePbMsgWithDrawResp(): PbMsgWithDrawResp {
  return { c2cWithDraw: [], groupWithDraw: [] };
}

export const PbMsgWithDrawResp: MessageFns<PbMsgWithDrawResp> = {
  encode(message: PbMsgWithDrawResp, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.c2cWithDraw) {
      PbC2CMsgWithDrawResp.encode(v!, writer.uint32(10).fork()).join();
    }
    for (const v of message.groupWithDraw) {
      PbGroupMsgWithDrawResp.encode(v!, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PbMsgWithDrawResp {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePbMsgWithDrawResp();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.c2cWithDraw.push(PbC2CMsgWithDrawResp.decode(reader, reader.uint32()));
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.groupWithDraw.push(PbGroupMsgWithDrawResp.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PbMsgWithDrawResp {
    return {
      c2cWithDraw: globalThis.Array.isArray(object?.c2cWithDraw)
        ? object.c2cWithDraw.map((e: any) => PbC2CMsgWithDrawResp.fromJSON(e))
        : [],
      groupWithDraw: globalThis.Array.isArray(object?.groupWithDraw)
        ? object.groupWithDraw.map((e: any) => PbGroupMsgWithDrawResp.fromJSON(e))
        : [],
    };
  },

  toJSON(message: PbMsgWithDrawResp): unknown {
    const obj: any = {};
    if (message.c2cWithDraw?.length) {
      obj.c2cWithDraw = message.c2cWithDraw.map((e) => PbC2CMsgWithDrawResp.toJSON(e));
    }
    if (message.groupWithDraw?.length) {
      obj.groupWithDraw = message.groupWithDraw.map((e) => PbGroupMsgWithDrawResp.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<PbMsgWithDrawResp>, I>>(base?: I): PbMsgWithDrawResp {
    return PbMsgWithDrawResp.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<PbMsgWithDrawResp>, I>>(object: I): PbMsgWithDrawResp {
    const message = createBasePbMsgWithDrawResp();
    message.c2cWithDraw = object.c2cWithDraw?.map((e) => PbC2CMsgWithDrawResp.fromPartial(e)) || [];
    message.groupWithDraw = object.groupWithDraw?.map((e) => PbGroupMsgWithDrawResp.fromPartial(e)) || [];
    return message;
  },
};

function createBasePbPullDiscussMsgSeqReqDiscussInfoReq(): PbPullDiscussMsgSeqReqDiscussInfoReq {
  return { confUin: undefined, lastSeq: undefined };
}

export const PbPullDiscussMsgSeqReqDiscussInfoReq: MessageFns<PbPullDiscussMsgSeqReqDiscussInfoReq> = {
  encode(message: PbPullDiscussMsgSeqReqDiscussInfoReq, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.confUin !== undefined) {
      writer.uint32(8).uint64(message.confUin);
    }
    if (message.lastSeq !== undefined) {
      writer.uint32(16).uint64(message.lastSeq);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PbPullDiscussMsgSeqReqDiscussInfoReq {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePbPullDiscussMsgSeqReqDiscussInfoReq();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.confUin = longToNumber(reader.uint64());
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.lastSeq = longToNumber(reader.uint64());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PbPullDiscussMsgSeqReqDiscussInfoReq {
    return {
      confUin: isSet(object.confUin) ? globalThis.Number(object.confUin) : undefined,
      lastSeq: isSet(object.lastSeq) ? globalThis.Number(object.lastSeq) : undefined,
    };
  },

  toJSON(message: PbPullDiscussMsgSeqReqDiscussInfoReq): unknown {
    const obj: any = {};
    if (message.confUin !== undefined) {
      obj.confUin = Math.round(message.confUin);
    }
    if (message.lastSeq !== undefined) {
      obj.lastSeq = Math.round(message.lastSeq);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<PbPullDiscussMsgSeqReqDiscussInfoReq>, I>>(
    base?: I,
  ): PbPullDiscussMsgSeqReqDiscussInfoReq {
    return PbPullDiscussMsgSeqReqDiscussInfoReq.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<PbPullDiscussMsgSeqReqDiscussInfoReq>, I>>(
    object: I,
  ): PbPullDiscussMsgSeqReqDiscussInfoReq {
    const message = createBasePbPullDiscussMsgSeqReqDiscussInfoReq();
    message.confUin = object.confUin ?? undefined;
    message.lastSeq = object.lastSeq ?? undefined;
    return message;
  },
};

function createBasePbPullDiscussMsgSeqReq(): PbPullDiscussMsgSeqReq {
  return { discussInfoReq: [] };
}

export const PbPullDiscussMsgSeqReq: MessageFns<PbPullDiscussMsgSeqReq> = {
  encode(message: PbPullDiscussMsgSeqReq, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.discussInfoReq) {
      PbPullDiscussMsgSeqReqDiscussInfoReq.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PbPullDiscussMsgSeqReq {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePbPullDiscussMsgSeqReq();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.discussInfoReq.push(PbPullDiscussMsgSeqReqDiscussInfoReq.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PbPullDiscussMsgSeqReq {
    return {
      discussInfoReq: globalThis.Array.isArray(object?.discussInfoReq)
        ? object.discussInfoReq.map((e: any) => PbPullDiscussMsgSeqReqDiscussInfoReq.fromJSON(e))
        : [],
    };
  },

  toJSON(message: PbPullDiscussMsgSeqReq): unknown {
    const obj: any = {};
    if (message.discussInfoReq?.length) {
      obj.discussInfoReq = message.discussInfoReq.map((e) => PbPullDiscussMsgSeqReqDiscussInfoReq.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<PbPullDiscussMsgSeqReq>, I>>(base?: I): PbPullDiscussMsgSeqReq {
    return PbPullDiscussMsgSeqReq.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<PbPullDiscussMsgSeqReq>, I>>(object: I): PbPullDiscussMsgSeqReq {
    const message = createBasePbPullDiscussMsgSeqReq();
    message.discussInfoReq = object.discussInfoReq?.map((e) => PbPullDiscussMsgSeqReqDiscussInfoReq.fromPartial(e)) ||
      [];
    return message;
  },
};

function createBasePbPullDiscussMsgSeqRespDiscussInfoResp(): PbPullDiscussMsgSeqRespDiscussInfoResp {
  return { confUin: undefined, memberSeq: undefined, confSeq: undefined };
}

export const PbPullDiscussMsgSeqRespDiscussInfoResp: MessageFns<PbPullDiscussMsgSeqRespDiscussInfoResp> = {
  encode(message: PbPullDiscussMsgSeqRespDiscussInfoResp, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.confUin !== undefined) {
      writer.uint32(8).uint64(message.confUin);
    }
    if (message.memberSeq !== undefined) {
      writer.uint32(16).uint64(message.memberSeq);
    }
    if (message.confSeq !== undefined) {
      writer.uint32(24).uint64(message.confSeq);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PbPullDiscussMsgSeqRespDiscussInfoResp {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePbPullDiscussMsgSeqRespDiscussInfoResp();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.confUin = longToNumber(reader.uint64());
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.memberSeq = longToNumber(reader.uint64());
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.confSeq = longToNumber(reader.uint64());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PbPullDiscussMsgSeqRespDiscussInfoResp {
    return {
      confUin: isSet(object.confUin) ? globalThis.Number(object.confUin) : undefined,
      memberSeq: isSet(object.memberSeq) ? globalThis.Number(object.memberSeq) : undefined,
      confSeq: isSet(object.confSeq) ? globalThis.Number(object.confSeq) : undefined,
    };
  },

  toJSON(message: PbPullDiscussMsgSeqRespDiscussInfoResp): unknown {
    const obj: any = {};
    if (message.confUin !== undefined) {
      obj.confUin = Math.round(message.confUin);
    }
    if (message.memberSeq !== undefined) {
      obj.memberSeq = Math.round(message.memberSeq);
    }
    if (message.confSeq !== undefined) {
      obj.confSeq = Math.round(message.confSeq);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<PbPullDiscussMsgSeqRespDiscussInfoResp>, I>>(
    base?: I,
  ): PbPullDiscussMsgSeqRespDiscussInfoResp {
    return PbPullDiscussMsgSeqRespDiscussInfoResp.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<PbPullDiscussMsgSeqRespDiscussInfoResp>, I>>(
    object: I,
  ): PbPullDiscussMsgSeqRespDiscussInfoResp {
    const message = createBasePbPullDiscussMsgSeqRespDiscussInfoResp();
    message.confUin = object.confUin ?? undefined;
    message.memberSeq = object.memberSeq ?? undefined;
    message.confSeq = object.confSeq ?? undefined;
    return message;
  },
};

function createBasePbPullDiscussMsgSeqResp(): PbPullDiscussMsgSeqResp {
  return { result: undefined, errmsg: undefined, discussInfoResp: [] };
}

export const PbPullDiscussMsgSeqResp: MessageFns<PbPullDiscussMsgSeqResp> = {
  encode(message: PbPullDiscussMsgSeqResp, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.result !== undefined) {
      writer.uint32(8).uint32(message.result);
    }
    if (message.errmsg !== undefined) {
      writer.uint32(18).string(message.errmsg);
    }
    for (const v of message.discussInfoResp) {
      PbPullDiscussMsgSeqRespDiscussInfoResp.encode(v!, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PbPullDiscussMsgSeqResp {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePbPullDiscussMsgSeqResp();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.result = reader.uint32();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.errmsg = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.discussInfoResp.push(PbPullDiscussMsgSeqRespDiscussInfoResp.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PbPullDiscussMsgSeqResp {
    return {
      result: isSet(object.result) ? globalThis.Number(object.result) : undefined,
      errmsg: isSet(object.errmsg) ? globalThis.String(object.errmsg) : undefined,
      discussInfoResp: globalThis.Array.isArray(object?.discussInfoResp)
        ? object.discussInfoResp.map((e: any) => PbPullDiscussMsgSeqRespDiscussInfoResp.fromJSON(e))
        : [],
    };
  },

  toJSON(message: PbPullDiscussMsgSeqResp): unknown {
    const obj: any = {};
    if (message.result !== undefined) {
      obj.result = Math.round(message.result);
    }
    if (message.errmsg !== undefined) {
      obj.errmsg = message.errmsg;
    }
    if (message.discussInfoResp?.length) {
      obj.discussInfoResp = message.discussInfoResp.map((e) => PbPullDiscussMsgSeqRespDiscussInfoResp.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<PbPullDiscussMsgSeqResp>, I>>(base?: I): PbPullDiscussMsgSeqResp {
    return PbPullDiscussMsgSeqResp.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<PbPullDiscussMsgSeqResp>, I>>(object: I): PbPullDiscussMsgSeqResp {
    const message = createBasePbPullDiscussMsgSeqResp();
    message.result = object.result ?? undefined;
    message.errmsg = object.errmsg ?? undefined;
    message.discussInfoResp =
      object.discussInfoResp?.map((e) => PbPullDiscussMsgSeqRespDiscussInfoResp.fromPartial(e)) || [];
    return message;
  },
};

function createBasePbPullGroupMsgSeqReqGroupInfoReq(): PbPullGroupMsgSeqReqGroupInfoReq {
  return { groupCode: undefined, lastSeq: undefined };
}

export const PbPullGroupMsgSeqReqGroupInfoReq: MessageFns<PbPullGroupMsgSeqReqGroupInfoReq> = {
  encode(message: PbPullGroupMsgSeqReqGroupInfoReq, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.groupCode !== undefined) {
      writer.uint32(8).uint64(message.groupCode);
    }
    if (message.lastSeq !== undefined) {
      writer.uint32(16).uint64(message.lastSeq);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PbPullGroupMsgSeqReqGroupInfoReq {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePbPullGroupMsgSeqReqGroupInfoReq();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.groupCode = longToNumber(reader.uint64());
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.lastSeq = longToNumber(reader.uint64());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PbPullGroupMsgSeqReqGroupInfoReq {
    return {
      groupCode: isSet(object.groupCode) ? globalThis.Number(object.groupCode) : undefined,
      lastSeq: isSet(object.lastSeq) ? globalThis.Number(object.lastSeq) : undefined,
    };
  },

  toJSON(message: PbPullGroupMsgSeqReqGroupInfoReq): unknown {
    const obj: any = {};
    if (message.groupCode !== undefined) {
      obj.groupCode = Math.round(message.groupCode);
    }
    if (message.lastSeq !== undefined) {
      obj.lastSeq = Math.round(message.lastSeq);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<PbPullGroupMsgSeqReqGroupInfoReq>, I>>(
    base?: I,
  ): PbPullGroupMsgSeqReqGroupInfoReq {
    return PbPullGroupMsgSeqReqGroupInfoReq.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<PbPullGroupMsgSeqReqGroupInfoReq>, I>>(
    object: I,
  ): PbPullGroupMsgSeqReqGroupInfoReq {
    const message = createBasePbPullGroupMsgSeqReqGroupInfoReq();
    message.groupCode = object.groupCode ?? undefined;
    message.lastSeq = object.lastSeq ?? undefined;
    return message;
  },
};

function createBasePbPullGroupMsgSeqReq(): PbPullGroupMsgSeqReq {
  return { groupInfoReq: [] };
}

export const PbPullGroupMsgSeqReq: MessageFns<PbPullGroupMsgSeqReq> = {
  encode(message: PbPullGroupMsgSeqReq, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.groupInfoReq) {
      PbPullGroupMsgSeqReqGroupInfoReq.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PbPullGroupMsgSeqReq {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePbPullGroupMsgSeqReq();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.groupInfoReq.push(PbPullGroupMsgSeqReqGroupInfoReq.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PbPullGroupMsgSeqReq {
    return {
      groupInfoReq: globalThis.Array.isArray(object?.groupInfoReq)
        ? object.groupInfoReq.map((e: any) => PbPullGroupMsgSeqReqGroupInfoReq.fromJSON(e))
        : [],
    };
  },

  toJSON(message: PbPullGroupMsgSeqReq): unknown {
    const obj: any = {};
    if (message.groupInfoReq?.length) {
      obj.groupInfoReq = message.groupInfoReq.map((e) => PbPullGroupMsgSeqReqGroupInfoReq.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<PbPullGroupMsgSeqReq>, I>>(base?: I): PbPullGroupMsgSeqReq {
    return PbPullGroupMsgSeqReq.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<PbPullGroupMsgSeqReq>, I>>(object: I): PbPullGroupMsgSeqReq {
    const message = createBasePbPullGroupMsgSeqReq();
    message.groupInfoReq = object.groupInfoReq?.map((e) => PbPullGroupMsgSeqReqGroupInfoReq.fromPartial(e)) || [];
    return message;
  },
};

function createBasePbPullGroupMsgSeqRespGroupInfoResp(): PbPullGroupMsgSeqRespGroupInfoResp {
  return { groupCode: undefined, memberSeq: undefined, groupSeq: undefined };
}

export const PbPullGroupMsgSeqRespGroupInfoResp: MessageFns<PbPullGroupMsgSeqRespGroupInfoResp> = {
  encode(message: PbPullGroupMsgSeqRespGroupInfoResp, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.groupCode !== undefined) {
      writer.uint32(8).uint64(message.groupCode);
    }
    if (message.memberSeq !== undefined) {
      writer.uint32(16).uint64(message.memberSeq);
    }
    if (message.groupSeq !== undefined) {
      writer.uint32(24).uint64(message.groupSeq);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PbPullGroupMsgSeqRespGroupInfoResp {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePbPullGroupMsgSeqRespGroupInfoResp();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.groupCode = longToNumber(reader.uint64());
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.memberSeq = longToNumber(reader.uint64());
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.groupSeq = longToNumber(reader.uint64());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PbPullGroupMsgSeqRespGroupInfoResp {
    return {
      groupCode: isSet(object.groupCode) ? globalThis.Number(object.groupCode) : undefined,
      memberSeq: isSet(object.memberSeq) ? globalThis.Number(object.memberSeq) : undefined,
      groupSeq: isSet(object.groupSeq) ? globalThis.Number(object.groupSeq) : undefined,
    };
  },

  toJSON(message: PbPullGroupMsgSeqRespGroupInfoResp): unknown {
    const obj: any = {};
    if (message.groupCode !== undefined) {
      obj.groupCode = Math.round(message.groupCode);
    }
    if (message.memberSeq !== undefined) {
      obj.memberSeq = Math.round(message.memberSeq);
    }
    if (message.groupSeq !== undefined) {
      obj.groupSeq = Math.round(message.groupSeq);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<PbPullGroupMsgSeqRespGroupInfoResp>, I>>(
    base?: I,
  ): PbPullGroupMsgSeqRespGroupInfoResp {
    return PbPullGroupMsgSeqRespGroupInfoResp.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<PbPullGroupMsgSeqRespGroupInfoResp>, I>>(
    object: I,
  ): PbPullGroupMsgSeqRespGroupInfoResp {
    const message = createBasePbPullGroupMsgSeqRespGroupInfoResp();
    message.groupCode = object.groupCode ?? undefined;
    message.memberSeq = object.memberSeq ?? undefined;
    message.groupSeq = object.groupSeq ?? undefined;
    return message;
  },
};

function createBasePbPullGroupMsgSeqResp(): PbPullGroupMsgSeqResp {
  return { result: undefined, errmsg: undefined, groupInfoResp: [] };
}

export const PbPullGroupMsgSeqResp: MessageFns<PbPullGroupMsgSeqResp> = {
  encode(message: PbPullGroupMsgSeqResp, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.result !== undefined) {
      writer.uint32(8).uint32(message.result);
    }
    if (message.errmsg !== undefined) {
      writer.uint32(18).string(message.errmsg);
    }
    for (const v of message.groupInfoResp) {
      PbPullGroupMsgSeqRespGroupInfoResp.encode(v!, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PbPullGroupMsgSeqResp {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePbPullGroupMsgSeqResp();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.result = reader.uint32();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.errmsg = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.groupInfoResp.push(PbPullGroupMsgSeqRespGroupInfoResp.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PbPullGroupMsgSeqResp {
    return {
      result: isSet(object.result) ? globalThis.Number(object.result) : undefined,
      errmsg: isSet(object.errmsg) ? globalThis.String(object.errmsg) : undefined,
      groupInfoResp: globalThis.Array.isArray(object?.groupInfoResp)
        ? object.groupInfoResp.map((e: any) => PbPullGroupMsgSeqRespGroupInfoResp.fromJSON(e))
        : [],
    };
  },

  toJSON(message: PbPullGroupMsgSeqResp): unknown {
    const obj: any = {};
    if (message.result !== undefined) {
      obj.result = Math.round(message.result);
    }
    if (message.errmsg !== undefined) {
      obj.errmsg = message.errmsg;
    }
    if (message.groupInfoResp?.length) {
      obj.groupInfoResp = message.groupInfoResp.map((e) => PbPullGroupMsgSeqRespGroupInfoResp.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<PbPullGroupMsgSeqResp>, I>>(base?: I): PbPullGroupMsgSeqResp {
    return PbPullGroupMsgSeqResp.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<PbPullGroupMsgSeqResp>, I>>(object: I): PbPullGroupMsgSeqResp {
    const message = createBasePbPullGroupMsgSeqResp();
    message.result = object.result ?? undefined;
    message.errmsg = object.errmsg ?? undefined;
    message.groupInfoResp = object.groupInfoResp?.map((e) => PbPullGroupMsgSeqRespGroupInfoResp.fromPartial(e)) || [];
    return message;
  },
};

function createBasePbSearchRoamMsgInCloudReq(): PbSearchRoamMsgInCloudReq {
  return { serializeReqbody: undefined };
}

export const PbSearchRoamMsgInCloudReq: MessageFns<PbSearchRoamMsgInCloudReq> = {
  encode(message: PbSearchRoamMsgInCloudReq, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.serializeReqbody !== undefined) {
      writer.uint32(10).bytes(message.serializeReqbody);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PbSearchRoamMsgInCloudReq {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePbSearchRoamMsgInCloudReq();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.serializeReqbody = reader.bytes();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PbSearchRoamMsgInCloudReq {
    return { serializeReqbody: isSet(object.serializeReqbody) ? bytesFromBase64(object.serializeReqbody) : undefined };
  },

  toJSON(message: PbSearchRoamMsgInCloudReq): unknown {
    const obj: any = {};
    if (message.serializeReqbody !== undefined) {
      obj.serializeReqbody = base64FromBytes(message.serializeReqbody);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<PbSearchRoamMsgInCloudReq>, I>>(base?: I): PbSearchRoamMsgInCloudReq {
    return PbSearchRoamMsgInCloudReq.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<PbSearchRoamMsgInCloudReq>, I>>(object: I): PbSearchRoamMsgInCloudReq {
    const message = createBasePbSearchRoamMsgInCloudReq();
    message.serializeReqbody = object.serializeReqbody ?? undefined;
    return message;
  },
};

function createBasePbSendMsgReq(): PbSendMsgReq {
  return {
    routingHead: undefined,
    contentHead: undefined,
    msgBody: undefined,
    msgSeq: undefined,
    msgRand: undefined,
    syncCookie: undefined,
    msgVia: undefined,
    dataStatist: undefined,
    multiMsgAssist: undefined,
    inputNotifyInfo: undefined,
    receiptReq: undefined,
    multiSendSeq: undefined,
  };
}

export const PbSendMsgReq: MessageFns<PbSendMsgReq> = {
  encode(message: PbSendMsgReq, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.routingHead !== undefined) {
      RoutingHead.encode(message.routingHead, writer.uint32(10).fork()).join();
    }
    if (message.contentHead !== undefined) {
      ContentHead.encode(message.contentHead, writer.uint32(18).fork()).join();
    }
    if (message.msgBody !== undefined) {
      MsgBody.encode(message.msgBody, writer.uint32(26).fork()).join();
    }
    if (message.msgSeq !== undefined) {
      writer.uint32(32).uint32(message.msgSeq);
    }
    if (message.msgRand !== undefined) {
      writer.uint32(40).uint32(message.msgRand);
    }
    if (message.syncCookie !== undefined) {
      writer.uint32(50).bytes(message.syncCookie);
    }
    if (message.msgVia !== undefined) {
      writer.uint32(64).uint32(message.msgVia);
    }
    if (message.dataStatist !== undefined) {
      writer.uint32(72).uint32(message.dataStatist);
    }
    if (message.multiMsgAssist !== undefined) {
      MultiMsgAssist.encode(message.multiMsgAssist, writer.uint32(82).fork()).join();
    }
    if (message.inputNotifyInfo !== undefined) {
      PbInputNotifyInfo.encode(message.inputNotifyInfo, writer.uint32(90).fork()).join();
    }
    if (message.receiptReq !== undefined) {
      ReceiptReq.encode(message.receiptReq, writer.uint32(106).fork()).join();
    }
    if (message.multiSendSeq !== undefined) {
      writer.uint32(112).uint32(message.multiSendSeq);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PbSendMsgReq {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePbSendMsgReq();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.routingHead = RoutingHead.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.contentHead = ContentHead.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.msgBody = MsgBody.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.msgSeq = reader.uint32();
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.msgRand = reader.uint32();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.syncCookie = reader.bytes();
          continue;
        }
        case 8: {
          if (tag !== 64) {
            break;
          }

          message.msgVia = reader.uint32();
          continue;
        }
        case 9: {
          if (tag !== 72) {
            break;
          }

          message.dataStatist = reader.uint32();
          continue;
        }
        case 10: {
          if (tag !== 82) {
            break;
          }

          message.multiMsgAssist = MultiMsgAssist.decode(reader, reader.uint32());
          continue;
        }
        case 11: {
          if (tag !== 90) {
            break;
          }

          message.inputNotifyInfo = PbInputNotifyInfo.decode(reader, reader.uint32());
          continue;
        }
        case 13: {
          if (tag !== 106) {
            break;
          }

          message.receiptReq = ReceiptReq.decode(reader, reader.uint32());
          continue;
        }
        case 14: {
          if (tag !== 112) {
            break;
          }

          message.multiSendSeq = reader.uint32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PbSendMsgReq {
    return {
      routingHead: isSet(object.routingHead) ? RoutingHead.fromJSON(object.routingHead) : undefined,
      contentHead: isSet(object.contentHead) ? ContentHead.fromJSON(object.contentHead) : undefined,
      msgBody: isSet(object.msgBody) ? MsgBody.fromJSON(object.msgBody) : undefined,
      msgSeq: isSet(object.msgSeq) ? globalThis.Number(object.msgSeq) : undefined,
      msgRand: isSet(object.msgRand) ? globalThis.Number(object.msgRand) : undefined,
      syncCookie: isSet(object.syncCookie) ? bytesFromBase64(object.syncCookie) : undefined,
      msgVia: isSet(object.msgVia) ? globalThis.Number(object.msgVia) : undefined,
      dataStatist: isSet(object.dataStatist) ? globalThis.Number(object.dataStatist) : undefined,
      multiMsgAssist: isSet(object.multiMsgAssist) ? MultiMsgAssist.fromJSON(object.multiMsgAssist) : undefined,
      inputNotifyInfo: isSet(object.inputNotifyInfo) ? PbInputNotifyInfo.fromJSON(object.inputNotifyInfo) : undefined,
      receiptReq: isSet(object.receiptReq) ? ReceiptReq.fromJSON(object.receiptReq) : undefined,
      multiSendSeq: isSet(object.multiSendSeq) ? globalThis.Number(object.multiSendSeq) : undefined,
    };
  },

  toJSON(message: PbSendMsgReq): unknown {
    const obj: any = {};
    if (message.routingHead !== undefined) {
      obj.routingHead = RoutingHead.toJSON(message.routingHead);
    }
    if (message.contentHead !== undefined) {
      obj.contentHead = ContentHead.toJSON(message.contentHead);
    }
    if (message.msgBody !== undefined) {
      obj.msgBody = MsgBody.toJSON(message.msgBody);
    }
    if (message.msgSeq !== undefined) {
      obj.msgSeq = Math.round(message.msgSeq);
    }
    if (message.msgRand !== undefined) {
      obj.msgRand = Math.round(message.msgRand);
    }
    if (message.syncCookie !== undefined) {
      obj.syncCookie = base64FromBytes(message.syncCookie);
    }
    if (message.msgVia !== undefined) {
      obj.msgVia = Math.round(message.msgVia);
    }
    if (message.dataStatist !== undefined) {
      obj.dataStatist = Math.round(message.dataStatist);
    }
    if (message.multiMsgAssist !== undefined) {
      obj.multiMsgAssist = MultiMsgAssist.toJSON(message.multiMsgAssist);
    }
    if (message.inputNotifyInfo !== undefined) {
      obj.inputNotifyInfo = PbInputNotifyInfo.toJSON(message.inputNotifyInfo);
    }
    if (message.receiptReq !== undefined) {
      obj.receiptReq = ReceiptReq.toJSON(message.receiptReq);
    }
    if (message.multiSendSeq !== undefined) {
      obj.multiSendSeq = Math.round(message.multiSendSeq);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<PbSendMsgReq>, I>>(base?: I): PbSendMsgReq {
    return PbSendMsgReq.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<PbSendMsgReq>, I>>(object: I): PbSendMsgReq {
    const message = createBasePbSendMsgReq();
    message.routingHead = (object.routingHead !== undefined && object.routingHead !== null)
      ? RoutingHead.fromPartial(object.routingHead)
      : undefined;
    message.contentHead = (object.contentHead !== undefined && object.contentHead !== null)
      ? ContentHead.fromPartial(object.contentHead)
      : undefined;
    message.msgBody = (object.msgBody !== undefined && object.msgBody !== null)
      ? MsgBody.fromPartial(object.msgBody)
      : undefined;
    message.msgSeq = object.msgSeq ?? undefined;
    message.msgRand = object.msgRand ?? undefined;
    message.syncCookie = object.syncCookie ?? undefined;
    message.msgVia = object.msgVia ?? undefined;
    message.dataStatist = object.dataStatist ?? undefined;
    message.multiMsgAssist = (object.multiMsgAssist !== undefined && object.multiMsgAssist !== null)
      ? MultiMsgAssist.fromPartial(object.multiMsgAssist)
      : undefined;
    message.inputNotifyInfo = (object.inputNotifyInfo !== undefined && object.inputNotifyInfo !== null)
      ? PbInputNotifyInfo.fromPartial(object.inputNotifyInfo)
      : undefined;
    message.receiptReq = (object.receiptReq !== undefined && object.receiptReq !== null)
      ? ReceiptReq.fromPartial(object.receiptReq)
      : undefined;
    message.multiSendSeq = object.multiSendSeq ?? undefined;
    return message;
  },
};

function createBasePbSendMsgResp(): PbSendMsgResp {
  return {
    result: undefined,
    errmsg: undefined,
    sendTime: undefined,
    uint32SvrbusyWaitTime: undefined,
    msgSendInfo: undefined,
    errtype: undefined,
    transSvrInfo: undefined,
    receiptResp: undefined,
    textAnalysisResult: undefined,
    uint32MsgInfoFlag: undefined,
    msgeleminfoServtype37: undefined,
  };
}

export const PbSendMsgResp: MessageFns<PbSendMsgResp> = {
  encode(message: PbSendMsgResp, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.result !== undefined) {
      writer.uint32(8).uint32(message.result);
    }
    if (message.errmsg !== undefined) {
      writer.uint32(18).string(message.errmsg);
    }
    if (message.sendTime !== undefined) {
      writer.uint32(24).uint32(message.sendTime);
    }
    if (message.uint32SvrbusyWaitTime !== undefined) {
      writer.uint32(32).uint32(message.uint32SvrbusyWaitTime);
    }
    if (message.msgSendInfo !== undefined) {
      MsgSendInfo.encode(message.msgSendInfo, writer.uint32(42).fork()).join();
    }
    if (message.errtype !== undefined) {
      writer.uint32(48).uint32(message.errtype);
    }
    if (message.transSvrInfo !== undefined) {
      TransSvrInfo.encode(message.transSvrInfo, writer.uint32(58).fork()).join();
    }
    if (message.receiptResp !== undefined) {
      ReceiptResp.encode(message.receiptResp, writer.uint32(66).fork()).join();
    }
    if (message.textAnalysisResult !== undefined) {
      writer.uint32(72).uint32(message.textAnalysisResult);
    }
    if (message.uint32MsgInfoFlag !== undefined) {
      writer.uint32(80).uint32(message.uint32MsgInfoFlag);
    }
    if (message.msgeleminfoServtype37 !== undefined) {
      writer.uint32(90).bytes(message.msgeleminfoServtype37);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PbSendMsgResp {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePbSendMsgResp();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.result = reader.uint32();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.errmsg = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.sendTime = reader.uint32();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.uint32SvrbusyWaitTime = reader.uint32();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.msgSendInfo = MsgSendInfo.decode(reader, reader.uint32());
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.errtype = reader.uint32();
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.transSvrInfo = TransSvrInfo.decode(reader, reader.uint32());
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.receiptResp = ReceiptResp.decode(reader, reader.uint32());
          continue;
        }
        case 9: {
          if (tag !== 72) {
            break;
          }

          message.textAnalysisResult = reader.uint32();
          continue;
        }
        case 10: {
          if (tag !== 80) {
            break;
          }

          message.uint32MsgInfoFlag = reader.uint32();
          continue;
        }
        case 11: {
          if (tag !== 90) {
            break;
          }

          message.msgeleminfoServtype37 = reader.bytes();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PbSendMsgResp {
    return {
      result: isSet(object.result) ? globalThis.Number(object.result) : undefined,
      errmsg: isSet(object.errmsg) ? globalThis.String(object.errmsg) : undefined,
      sendTime: isSet(object.sendTime) ? globalThis.Number(object.sendTime) : undefined,
      uint32SvrbusyWaitTime: isSet(object.uint32SvrbusyWaitTime)
        ? globalThis.Number(object.uint32SvrbusyWaitTime)
        : undefined,
      msgSendInfo: isSet(object.msgSendInfo) ? MsgSendInfo.fromJSON(object.msgSendInfo) : undefined,
      errtype: isSet(object.errtype) ? globalThis.Number(object.errtype) : undefined,
      transSvrInfo: isSet(object.transSvrInfo) ? TransSvrInfo.fromJSON(object.transSvrInfo) : undefined,
      receiptResp: isSet(object.receiptResp) ? ReceiptResp.fromJSON(object.receiptResp) : undefined,
      textAnalysisResult: isSet(object.textAnalysisResult) ? globalThis.Number(object.textAnalysisResult) : undefined,
      uint32MsgInfoFlag: isSet(object.uint32MsgInfoFlag) ? globalThis.Number(object.uint32MsgInfoFlag) : undefined,
      msgeleminfoServtype37: isSet(object.msgeleminfoServtype37)
        ? bytesFromBase64(object.msgeleminfoServtype37)
        : undefined,
    };
  },

  toJSON(message: PbSendMsgResp): unknown {
    const obj: any = {};
    if (message.result !== undefined) {
      obj.result = Math.round(message.result);
    }
    if (message.errmsg !== undefined) {
      obj.errmsg = message.errmsg;
    }
    if (message.sendTime !== undefined) {
      obj.sendTime = Math.round(message.sendTime);
    }
    if (message.uint32SvrbusyWaitTime !== undefined) {
      obj.uint32SvrbusyWaitTime = Math.round(message.uint32SvrbusyWaitTime);
    }
    if (message.msgSendInfo !== undefined) {
      obj.msgSendInfo = MsgSendInfo.toJSON(message.msgSendInfo);
    }
    if (message.errtype !== undefined) {
      obj.errtype = Math.round(message.errtype);
    }
    if (message.transSvrInfo !== undefined) {
      obj.transSvrInfo = TransSvrInfo.toJSON(message.transSvrInfo);
    }
    if (message.receiptResp !== undefined) {
      obj.receiptResp = ReceiptResp.toJSON(message.receiptResp);
    }
    if (message.textAnalysisResult !== undefined) {
      obj.textAnalysisResult = Math.round(message.textAnalysisResult);
    }
    if (message.uint32MsgInfoFlag !== undefined) {
      obj.uint32MsgInfoFlag = Math.round(message.uint32MsgInfoFlag);
    }
    if (message.msgeleminfoServtype37 !== undefined) {
      obj.msgeleminfoServtype37 = base64FromBytes(message.msgeleminfoServtype37);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<PbSendMsgResp>, I>>(base?: I): PbSendMsgResp {
    return PbSendMsgResp.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<PbSendMsgResp>, I>>(object: I): PbSendMsgResp {
    const message = createBasePbSendMsgResp();
    message.result = object.result ?? undefined;
    message.errmsg = object.errmsg ?? undefined;
    message.sendTime = object.sendTime ?? undefined;
    message.uint32SvrbusyWaitTime = object.uint32SvrbusyWaitTime ?? undefined;
    message.msgSendInfo = (object.msgSendInfo !== undefined && object.msgSendInfo !== null)
      ? MsgSendInfo.fromPartial(object.msgSendInfo)
      : undefined;
    message.errtype = object.errtype ?? undefined;
    message.transSvrInfo = (object.transSvrInfo !== undefined && object.transSvrInfo !== null)
      ? TransSvrInfo.fromPartial(object.transSvrInfo)
      : undefined;
    message.receiptResp = (object.receiptResp !== undefined && object.receiptResp !== null)
      ? ReceiptResp.fromPartial(object.receiptResp)
      : undefined;
    message.textAnalysisResult = object.textAnalysisResult ?? undefined;
    message.uint32MsgInfoFlag = object.uint32MsgInfoFlag ?? undefined;
    message.msgeleminfoServtype37 = object.msgeleminfoServtype37 ?? undefined;
    return message;
  },
};

function createBasePbThirdQQUnReadMsgNumReqThirdQQReqInfo(): PbThirdQQUnReadMsgNumReqThirdQQReqInfo {
  return { thirdUin: undefined, thirdUinSig: undefined, thirdUinCookie: undefined };
}

export const PbThirdQQUnReadMsgNumReqThirdQQReqInfo: MessageFns<PbThirdQQUnReadMsgNumReqThirdQQReqInfo> = {
  encode(message: PbThirdQQUnReadMsgNumReqThirdQQReqInfo, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.thirdUin !== undefined) {
      writer.uint32(8).uint64(message.thirdUin);
    }
    if (message.thirdUinSig !== undefined) {
      writer.uint32(18).bytes(message.thirdUinSig);
    }
    if (message.thirdUinCookie !== undefined) {
      writer.uint32(26).bytes(message.thirdUinCookie);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PbThirdQQUnReadMsgNumReqThirdQQReqInfo {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePbThirdQQUnReadMsgNumReqThirdQQReqInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.thirdUin = longToNumber(reader.uint64());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.thirdUinSig = reader.bytes();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.thirdUinCookie = reader.bytes();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PbThirdQQUnReadMsgNumReqThirdQQReqInfo {
    return {
      thirdUin: isSet(object.thirdUin) ? globalThis.Number(object.thirdUin) : undefined,
      thirdUinSig: isSet(object.thirdUinSig) ? bytesFromBase64(object.thirdUinSig) : undefined,
      thirdUinCookie: isSet(object.thirdUinCookie) ? bytesFromBase64(object.thirdUinCookie) : undefined,
    };
  },

  toJSON(message: PbThirdQQUnReadMsgNumReqThirdQQReqInfo): unknown {
    const obj: any = {};
    if (message.thirdUin !== undefined) {
      obj.thirdUin = Math.round(message.thirdUin);
    }
    if (message.thirdUinSig !== undefined) {
      obj.thirdUinSig = base64FromBytes(message.thirdUinSig);
    }
    if (message.thirdUinCookie !== undefined) {
      obj.thirdUinCookie = base64FromBytes(message.thirdUinCookie);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<PbThirdQQUnReadMsgNumReqThirdQQReqInfo>, I>>(
    base?: I,
  ): PbThirdQQUnReadMsgNumReqThirdQQReqInfo {
    return PbThirdQQUnReadMsgNumReqThirdQQReqInfo.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<PbThirdQQUnReadMsgNumReqThirdQQReqInfo>, I>>(
    object: I,
  ): PbThirdQQUnReadMsgNumReqThirdQQReqInfo {
    const message = createBasePbThirdQQUnReadMsgNumReqThirdQQReqInfo();
    message.thirdUin = object.thirdUin ?? undefined;
    message.thirdUinSig = object.thirdUinSig ?? undefined;
    message.thirdUinCookie = object.thirdUinCookie ?? undefined;
    return message;
  },
};

function createBasePbThirdQQUnReadMsgNumReq(): PbThirdQQUnReadMsgNumReq {
  return { thirdqqReqInfo: [], source: undefined };
}

export const PbThirdQQUnReadMsgNumReq: MessageFns<PbThirdQQUnReadMsgNumReq> = {
  encode(message: PbThirdQQUnReadMsgNumReq, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.thirdqqReqInfo) {
      PbThirdQQUnReadMsgNumReqThirdQQReqInfo.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.source !== undefined) {
      writer.uint32(16).uint32(message.source);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PbThirdQQUnReadMsgNumReq {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePbThirdQQUnReadMsgNumReq();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.thirdqqReqInfo.push(PbThirdQQUnReadMsgNumReqThirdQQReqInfo.decode(reader, reader.uint32()));
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.source = reader.uint32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PbThirdQQUnReadMsgNumReq {
    return {
      thirdqqReqInfo: globalThis.Array.isArray(object?.thirdqqReqInfo)
        ? object.thirdqqReqInfo.map((e: any) => PbThirdQQUnReadMsgNumReqThirdQQReqInfo.fromJSON(e))
        : [],
      source: isSet(object.source) ? globalThis.Number(object.source) : undefined,
    };
  },

  toJSON(message: PbThirdQQUnReadMsgNumReq): unknown {
    const obj: any = {};
    if (message.thirdqqReqInfo?.length) {
      obj.thirdqqReqInfo = message.thirdqqReqInfo.map((e) => PbThirdQQUnReadMsgNumReqThirdQQReqInfo.toJSON(e));
    }
    if (message.source !== undefined) {
      obj.source = Math.round(message.source);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<PbThirdQQUnReadMsgNumReq>, I>>(base?: I): PbThirdQQUnReadMsgNumReq {
    return PbThirdQQUnReadMsgNumReq.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<PbThirdQQUnReadMsgNumReq>, I>>(object: I): PbThirdQQUnReadMsgNumReq {
    const message = createBasePbThirdQQUnReadMsgNumReq();
    message.thirdqqReqInfo = object.thirdqqReqInfo?.map((e) => PbThirdQQUnReadMsgNumReqThirdQQReqInfo.fromPartial(e)) ||
      [];
    message.source = object.source ?? undefined;
    return message;
  },
};

function createBasePbThirdQQUnReadMsgNumRespThirdQQRespInfo(): PbThirdQQUnReadMsgNumRespThirdQQRespInfo {
  return {
    thirdUin: undefined,
    thirdUinCookie: undefined,
    msgNum: undefined,
    msgFlag: undefined,
    redbagTime: undefined,
    status: undefined,
    lastMsgTime: undefined,
  };
}

export const PbThirdQQUnReadMsgNumRespThirdQQRespInfo: MessageFns<PbThirdQQUnReadMsgNumRespThirdQQRespInfo> = {
  encode(message: PbThirdQQUnReadMsgNumRespThirdQQRespInfo, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.thirdUin !== undefined) {
      writer.uint32(8).uint64(message.thirdUin);
    }
    if (message.thirdUinCookie !== undefined) {
      writer.uint32(18).bytes(message.thirdUinCookie);
    }
    if (message.msgNum !== undefined) {
      writer.uint32(24).uint32(message.msgNum);
    }
    if (message.msgFlag !== undefined) {
      writer.uint32(32).uint32(message.msgFlag);
    }
    if (message.redbagTime !== undefined) {
      writer.uint32(40).uint32(message.redbagTime);
    }
    if (message.status !== undefined) {
      writer.uint32(48).uint32(message.status);
    }
    if (message.lastMsgTime !== undefined) {
      writer.uint32(56).uint32(message.lastMsgTime);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PbThirdQQUnReadMsgNumRespThirdQQRespInfo {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePbThirdQQUnReadMsgNumRespThirdQQRespInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.thirdUin = longToNumber(reader.uint64());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.thirdUinCookie = reader.bytes();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.msgNum = reader.uint32();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.msgFlag = reader.uint32();
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.redbagTime = reader.uint32();
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.status = reader.uint32();
          continue;
        }
        case 7: {
          if (tag !== 56) {
            break;
          }

          message.lastMsgTime = reader.uint32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PbThirdQQUnReadMsgNumRespThirdQQRespInfo {
    return {
      thirdUin: isSet(object.thirdUin) ? globalThis.Number(object.thirdUin) : undefined,
      thirdUinCookie: isSet(object.thirdUinCookie) ? bytesFromBase64(object.thirdUinCookie) : undefined,
      msgNum: isSet(object.msgNum) ? globalThis.Number(object.msgNum) : undefined,
      msgFlag: isSet(object.msgFlag) ? globalThis.Number(object.msgFlag) : undefined,
      redbagTime: isSet(object.redbagTime) ? globalThis.Number(object.redbagTime) : undefined,
      status: isSet(object.status) ? globalThis.Number(object.status) : undefined,
      lastMsgTime: isSet(object.lastMsgTime) ? globalThis.Number(object.lastMsgTime) : undefined,
    };
  },

  toJSON(message: PbThirdQQUnReadMsgNumRespThirdQQRespInfo): unknown {
    const obj: any = {};
    if (message.thirdUin !== undefined) {
      obj.thirdUin = Math.round(message.thirdUin);
    }
    if (message.thirdUinCookie !== undefined) {
      obj.thirdUinCookie = base64FromBytes(message.thirdUinCookie);
    }
    if (message.msgNum !== undefined) {
      obj.msgNum = Math.round(message.msgNum);
    }
    if (message.msgFlag !== undefined) {
      obj.msgFlag = Math.round(message.msgFlag);
    }
    if (message.redbagTime !== undefined) {
      obj.redbagTime = Math.round(message.redbagTime);
    }
    if (message.status !== undefined) {
      obj.status = Math.round(message.status);
    }
    if (message.lastMsgTime !== undefined) {
      obj.lastMsgTime = Math.round(message.lastMsgTime);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<PbThirdQQUnReadMsgNumRespThirdQQRespInfo>, I>>(
    base?: I,
  ): PbThirdQQUnReadMsgNumRespThirdQQRespInfo {
    return PbThirdQQUnReadMsgNumRespThirdQQRespInfo.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<PbThirdQQUnReadMsgNumRespThirdQQRespInfo>, I>>(
    object: I,
  ): PbThirdQQUnReadMsgNumRespThirdQQRespInfo {
    const message = createBasePbThirdQQUnReadMsgNumRespThirdQQRespInfo();
    message.thirdUin = object.thirdUin ?? undefined;
    message.thirdUinCookie = object.thirdUinCookie ?? undefined;
    message.msgNum = object.msgNum ?? undefined;
    message.msgFlag = object.msgFlag ?? undefined;
    message.redbagTime = object.redbagTime ?? undefined;
    message.status = object.status ?? undefined;
    message.lastMsgTime = object.lastMsgTime ?? undefined;
    return message;
  },
};

function createBasePbThirdQQUnReadMsgNumResp(): PbThirdQQUnReadMsgNumResp {
  return { result: undefined, errmsg: undefined, thirdqqRespInfo: [], interval: undefined };
}

export const PbThirdQQUnReadMsgNumResp: MessageFns<PbThirdQQUnReadMsgNumResp> = {
  encode(message: PbThirdQQUnReadMsgNumResp, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.result !== undefined) {
      writer.uint32(8).uint32(message.result);
    }
    if (message.errmsg !== undefined) {
      writer.uint32(18).string(message.errmsg);
    }
    for (const v of message.thirdqqRespInfo) {
      PbThirdQQUnReadMsgNumRespThirdQQRespInfo.encode(v!, writer.uint32(26).fork()).join();
    }
    if (message.interval !== undefined) {
      writer.uint32(32).uint32(message.interval);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PbThirdQQUnReadMsgNumResp {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePbThirdQQUnReadMsgNumResp();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.result = reader.uint32();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.errmsg = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.thirdqqRespInfo.push(PbThirdQQUnReadMsgNumRespThirdQQRespInfo.decode(reader, reader.uint32()));
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.interval = reader.uint32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PbThirdQQUnReadMsgNumResp {
    return {
      result: isSet(object.result) ? globalThis.Number(object.result) : undefined,
      errmsg: isSet(object.errmsg) ? globalThis.String(object.errmsg) : undefined,
      thirdqqRespInfo: globalThis.Array.isArray(object?.thirdqqRespInfo)
        ? object.thirdqqRespInfo.map((e: any) => PbThirdQQUnReadMsgNumRespThirdQQRespInfo.fromJSON(e))
        : [],
      interval: isSet(object.interval) ? globalThis.Number(object.interval) : undefined,
    };
  },

  toJSON(message: PbThirdQQUnReadMsgNumResp): unknown {
    const obj: any = {};
    if (message.result !== undefined) {
      obj.result = Math.round(message.result);
    }
    if (message.errmsg !== undefined) {
      obj.errmsg = message.errmsg;
    }
    if (message.thirdqqRespInfo?.length) {
      obj.thirdqqRespInfo = message.thirdqqRespInfo.map((e) => PbThirdQQUnReadMsgNumRespThirdQQRespInfo.toJSON(e));
    }
    if (message.interval !== undefined) {
      obj.interval = Math.round(message.interval);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<PbThirdQQUnReadMsgNumResp>, I>>(base?: I): PbThirdQQUnReadMsgNumResp {
    return PbThirdQQUnReadMsgNumResp.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<PbThirdQQUnReadMsgNumResp>, I>>(object: I): PbThirdQQUnReadMsgNumResp {
    const message = createBasePbThirdQQUnReadMsgNumResp();
    message.result = object.result ?? undefined;
    message.errmsg = object.errmsg ?? undefined;
    message.thirdqqRespInfo =
      object.thirdqqRespInfo?.map((e) => PbThirdQQUnReadMsgNumRespThirdQQRespInfo.fromPartial(e)) || [];
    message.interval = object.interval ?? undefined;
    return message;
  },
};

function createBasePbUnReadMsgSeqReq(): PbUnReadMsgSeqReq {
  return {
    c2cUnreadInfo: undefined,
    binduinUnreadInfo: [],
    groupUnreadInfo: undefined,
    discussUnreadInfo: undefined,
    thirdqqUnreadInfo: undefined,
  };
}

export const PbUnReadMsgSeqReq: MessageFns<PbUnReadMsgSeqReq> = {
  encode(message: PbUnReadMsgSeqReq, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.c2cUnreadInfo !== undefined) {
      PbC2CUnReadMsgNumReq.encode(message.c2cUnreadInfo, writer.uint32(10).fork()).join();
    }
    for (const v of message.binduinUnreadInfo) {
      PbBindUinUnReadMsgNumReq.encode(v!, writer.uint32(18).fork()).join();
    }
    if (message.groupUnreadInfo !== undefined) {
      PbPullGroupMsgSeqReq.encode(message.groupUnreadInfo, writer.uint32(26).fork()).join();
    }
    if (message.discussUnreadInfo !== undefined) {
      PbPullDiscussMsgSeqReq.encode(message.discussUnreadInfo, writer.uint32(34).fork()).join();
    }
    if (message.thirdqqUnreadInfo !== undefined) {
      PbThirdQQUnReadMsgNumReq.encode(message.thirdqqUnreadInfo, writer.uint32(42).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PbUnReadMsgSeqReq {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePbUnReadMsgSeqReq();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.c2cUnreadInfo = PbC2CUnReadMsgNumReq.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.binduinUnreadInfo.push(PbBindUinUnReadMsgNumReq.decode(reader, reader.uint32()));
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.groupUnreadInfo = PbPullGroupMsgSeqReq.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.discussUnreadInfo = PbPullDiscussMsgSeqReq.decode(reader, reader.uint32());
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.thirdqqUnreadInfo = PbThirdQQUnReadMsgNumReq.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PbUnReadMsgSeqReq {
    return {
      c2cUnreadInfo: isSet(object.c2cUnreadInfo) ? PbC2CUnReadMsgNumReq.fromJSON(object.c2cUnreadInfo) : undefined,
      binduinUnreadInfo: globalThis.Array.isArray(object?.binduinUnreadInfo)
        ? object.binduinUnreadInfo.map((e: any) => PbBindUinUnReadMsgNumReq.fromJSON(e))
        : [],
      groupUnreadInfo: isSet(object.groupUnreadInfo)
        ? PbPullGroupMsgSeqReq.fromJSON(object.groupUnreadInfo)
        : undefined,
      discussUnreadInfo: isSet(object.discussUnreadInfo)
        ? PbPullDiscussMsgSeqReq.fromJSON(object.discussUnreadInfo)
        : undefined,
      thirdqqUnreadInfo: isSet(object.thirdqqUnreadInfo)
        ? PbThirdQQUnReadMsgNumReq.fromJSON(object.thirdqqUnreadInfo)
        : undefined,
    };
  },

  toJSON(message: PbUnReadMsgSeqReq): unknown {
    const obj: any = {};
    if (message.c2cUnreadInfo !== undefined) {
      obj.c2cUnreadInfo = PbC2CUnReadMsgNumReq.toJSON(message.c2cUnreadInfo);
    }
    if (message.binduinUnreadInfo?.length) {
      obj.binduinUnreadInfo = message.binduinUnreadInfo.map((e) => PbBindUinUnReadMsgNumReq.toJSON(e));
    }
    if (message.groupUnreadInfo !== undefined) {
      obj.groupUnreadInfo = PbPullGroupMsgSeqReq.toJSON(message.groupUnreadInfo);
    }
    if (message.discussUnreadInfo !== undefined) {
      obj.discussUnreadInfo = PbPullDiscussMsgSeqReq.toJSON(message.discussUnreadInfo);
    }
    if (message.thirdqqUnreadInfo !== undefined) {
      obj.thirdqqUnreadInfo = PbThirdQQUnReadMsgNumReq.toJSON(message.thirdqqUnreadInfo);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<PbUnReadMsgSeqReq>, I>>(base?: I): PbUnReadMsgSeqReq {
    return PbUnReadMsgSeqReq.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<PbUnReadMsgSeqReq>, I>>(object: I): PbUnReadMsgSeqReq {
    const message = createBasePbUnReadMsgSeqReq();
    message.c2cUnreadInfo = (object.c2cUnreadInfo !== undefined && object.c2cUnreadInfo !== null)
      ? PbC2CUnReadMsgNumReq.fromPartial(object.c2cUnreadInfo)
      : undefined;
    message.binduinUnreadInfo = object.binduinUnreadInfo?.map((e) => PbBindUinUnReadMsgNumReq.fromPartial(e)) || [];
    message.groupUnreadInfo = (object.groupUnreadInfo !== undefined && object.groupUnreadInfo !== null)
      ? PbPullGroupMsgSeqReq.fromPartial(object.groupUnreadInfo)
      : undefined;
    message.discussUnreadInfo = (object.discussUnreadInfo !== undefined && object.discussUnreadInfo !== null)
      ? PbPullDiscussMsgSeqReq.fromPartial(object.discussUnreadInfo)
      : undefined;
    message.thirdqqUnreadInfo = (object.thirdqqUnreadInfo !== undefined && object.thirdqqUnreadInfo !== null)
      ? PbThirdQQUnReadMsgNumReq.fromPartial(object.thirdqqUnreadInfo)
      : undefined;
    return message;
  },
};

function createBasePbUnReadMsgSeqResp(): PbUnReadMsgSeqResp {
  return {
    c2cUnreadInfo: undefined,
    binduinUnreadInfo: [],
    groupUnreadInfo: undefined,
    discussUnreadInfo: undefined,
    thirdqqUnreadInfo: undefined,
  };
}

export const PbUnReadMsgSeqResp: MessageFns<PbUnReadMsgSeqResp> = {
  encode(message: PbUnReadMsgSeqResp, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.c2cUnreadInfo !== undefined) {
      PbC2CUnReadMsgNumResp.encode(message.c2cUnreadInfo, writer.uint32(10).fork()).join();
    }
    for (const v of message.binduinUnreadInfo) {
      PbBindUinUnReadMsgNumResp.encode(v!, writer.uint32(18).fork()).join();
    }
    if (message.groupUnreadInfo !== undefined) {
      PbPullGroupMsgSeqResp.encode(message.groupUnreadInfo, writer.uint32(26).fork()).join();
    }
    if (message.discussUnreadInfo !== undefined) {
      PbPullDiscussMsgSeqResp.encode(message.discussUnreadInfo, writer.uint32(34).fork()).join();
    }
    if (message.thirdqqUnreadInfo !== undefined) {
      PbThirdQQUnReadMsgNumResp.encode(message.thirdqqUnreadInfo, writer.uint32(42).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PbUnReadMsgSeqResp {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePbUnReadMsgSeqResp();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.c2cUnreadInfo = PbC2CUnReadMsgNumResp.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.binduinUnreadInfo.push(PbBindUinUnReadMsgNumResp.decode(reader, reader.uint32()));
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.groupUnreadInfo = PbPullGroupMsgSeqResp.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.discussUnreadInfo = PbPullDiscussMsgSeqResp.decode(reader, reader.uint32());
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.thirdqqUnreadInfo = PbThirdQQUnReadMsgNumResp.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PbUnReadMsgSeqResp {
    return {
      c2cUnreadInfo: isSet(object.c2cUnreadInfo) ? PbC2CUnReadMsgNumResp.fromJSON(object.c2cUnreadInfo) : undefined,
      binduinUnreadInfo: globalThis.Array.isArray(object?.binduinUnreadInfo)
        ? object.binduinUnreadInfo.map((e: any) => PbBindUinUnReadMsgNumResp.fromJSON(e))
        : [],
      groupUnreadInfo: isSet(object.groupUnreadInfo)
        ? PbPullGroupMsgSeqResp.fromJSON(object.groupUnreadInfo)
        : undefined,
      discussUnreadInfo: isSet(object.discussUnreadInfo)
        ? PbPullDiscussMsgSeqResp.fromJSON(object.discussUnreadInfo)
        : undefined,
      thirdqqUnreadInfo: isSet(object.thirdqqUnreadInfo)
        ? PbThirdQQUnReadMsgNumResp.fromJSON(object.thirdqqUnreadInfo)
        : undefined,
    };
  },

  toJSON(message: PbUnReadMsgSeqResp): unknown {
    const obj: any = {};
    if (message.c2cUnreadInfo !== undefined) {
      obj.c2cUnreadInfo = PbC2CUnReadMsgNumResp.toJSON(message.c2cUnreadInfo);
    }
    if (message.binduinUnreadInfo?.length) {
      obj.binduinUnreadInfo = message.binduinUnreadInfo.map((e) => PbBindUinUnReadMsgNumResp.toJSON(e));
    }
    if (message.groupUnreadInfo !== undefined) {
      obj.groupUnreadInfo = PbPullGroupMsgSeqResp.toJSON(message.groupUnreadInfo);
    }
    if (message.discussUnreadInfo !== undefined) {
      obj.discussUnreadInfo = PbPullDiscussMsgSeqResp.toJSON(message.discussUnreadInfo);
    }
    if (message.thirdqqUnreadInfo !== undefined) {
      obj.thirdqqUnreadInfo = PbThirdQQUnReadMsgNumResp.toJSON(message.thirdqqUnreadInfo);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<PbUnReadMsgSeqResp>, I>>(base?: I): PbUnReadMsgSeqResp {
    return PbUnReadMsgSeqResp.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<PbUnReadMsgSeqResp>, I>>(object: I): PbUnReadMsgSeqResp {
    const message = createBasePbUnReadMsgSeqResp();
    message.c2cUnreadInfo = (object.c2cUnreadInfo !== undefined && object.c2cUnreadInfo !== null)
      ? PbC2CUnReadMsgNumResp.fromPartial(object.c2cUnreadInfo)
      : undefined;
    message.binduinUnreadInfo = object.binduinUnreadInfo?.map((e) => PbBindUinUnReadMsgNumResp.fromPartial(e)) || [];
    message.groupUnreadInfo = (object.groupUnreadInfo !== undefined && object.groupUnreadInfo !== null)
      ? PbPullGroupMsgSeqResp.fromPartial(object.groupUnreadInfo)
      : undefined;
    message.discussUnreadInfo = (object.discussUnreadInfo !== undefined && object.discussUnreadInfo !== null)
      ? PbPullDiscussMsgSeqResp.fromPartial(object.discussUnreadInfo)
      : undefined;
    message.thirdqqUnreadInfo = (object.thirdqqUnreadInfo !== undefined && object.thirdqqUnreadInfo !== null)
      ? PbThirdQQUnReadMsgNumResp.fromPartial(object.thirdqqUnreadInfo)
      : undefined;
    return message;
  },
};

function createBasePubGroupTmp(): PubGroupTmp {
  return { toUin: undefined, sig: undefined, groupUin: undefined };
}

export const PubGroupTmp: MessageFns<PubGroupTmp> = {
  encode(message: PubGroupTmp, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.toUin !== undefined) {
      writer.uint32(8).uint64(message.toUin);
    }
    if (message.sig !== undefined) {
      writer.uint32(18).bytes(message.sig);
    }
    if (message.groupUin !== undefined) {
      writer.uint32(24).uint64(message.groupUin);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PubGroupTmp {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePubGroupTmp();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.toUin = longToNumber(reader.uint64());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.sig = reader.bytes();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.groupUin = longToNumber(reader.uint64());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PubGroupTmp {
    return {
      toUin: isSet(object.toUin) ? globalThis.Number(object.toUin) : undefined,
      sig: isSet(object.sig) ? bytesFromBase64(object.sig) : undefined,
      groupUin: isSet(object.groupUin) ? globalThis.Number(object.groupUin) : undefined,
    };
  },

  toJSON(message: PubGroupTmp): unknown {
    const obj: any = {};
    if (message.toUin !== undefined) {
      obj.toUin = Math.round(message.toUin);
    }
    if (message.sig !== undefined) {
      obj.sig = base64FromBytes(message.sig);
    }
    if (message.groupUin !== undefined) {
      obj.groupUin = Math.round(message.groupUin);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<PubGroupTmp>, I>>(base?: I): PubGroupTmp {
    return PubGroupTmp.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<PubGroupTmp>, I>>(object: I): PubGroupTmp {
    const message = createBasePubGroupTmp();
    message.toUin = object.toUin ?? undefined;
    message.sig = object.sig ?? undefined;
    message.groupUin = object.groupUin ?? undefined;
    return message;
  },
};

function createBasePublicPlat(): PublicPlat {
  return { toUin: undefined, sig: undefined };
}

export const PublicPlat: MessageFns<PublicPlat> = {
  encode(message: PublicPlat, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.toUin !== undefined) {
      writer.uint32(8).uint64(message.toUin);
    }
    if (message.sig !== undefined) {
      writer.uint32(18).bytes(message.sig);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PublicPlat {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePublicPlat();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.toUin = longToNumber(reader.uint64());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.sig = reader.bytes();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PublicPlat {
    return {
      toUin: isSet(object.toUin) ? globalThis.Number(object.toUin) : undefined,
      sig: isSet(object.sig) ? bytesFromBase64(object.sig) : undefined,
    };
  },

  toJSON(message: PublicPlat): unknown {
    const obj: any = {};
    if (message.toUin !== undefined) {
      obj.toUin = Math.round(message.toUin);
    }
    if (message.sig !== undefined) {
      obj.sig = base64FromBytes(message.sig);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<PublicPlat>, I>>(base?: I): PublicPlat {
    return PublicPlat.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<PublicPlat>, I>>(object: I): PublicPlat {
    const message = createBasePublicPlat();
    message.toUin = object.toUin ?? undefined;
    message.sig = object.sig ?? undefined;
    return message;
  },
};

function createBaseQQQueryBusinessTmp(): QQQueryBusinessTmp {
  return { toUin: undefined, sig: undefined };
}

export const QQQueryBusinessTmp: MessageFns<QQQueryBusinessTmp> = {
  encode(message: QQQueryBusinessTmp, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.toUin !== undefined) {
      writer.uint32(8).uint64(message.toUin);
    }
    if (message.sig !== undefined) {
      writer.uint32(18).bytes(message.sig);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): QQQueryBusinessTmp {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQQQueryBusinessTmp();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.toUin = longToNumber(reader.uint64());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.sig = reader.bytes();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): QQQueryBusinessTmp {
    return {
      toUin: isSet(object.toUin) ? globalThis.Number(object.toUin) : undefined,
      sig: isSet(object.sig) ? bytesFromBase64(object.sig) : undefined,
    };
  },

  toJSON(message: QQQueryBusinessTmp): unknown {
    const obj: any = {};
    if (message.toUin !== undefined) {
      obj.toUin = Math.round(message.toUin);
    }
    if (message.sig !== undefined) {
      obj.sig = base64FromBytes(message.sig);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<QQQueryBusinessTmp>, I>>(base?: I): QQQueryBusinessTmp {
    return QQQueryBusinessTmp.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<QQQueryBusinessTmp>, I>>(object: I): QQQueryBusinessTmp {
    const message = createBaseQQQueryBusinessTmp();
    message.toUin = object.toUin ?? undefined;
    message.sig = object.sig ?? undefined;
    return message;
  },
};

function createBaseRichStatusTmp(): RichStatusTmp {
  return { toUin: undefined, sig: undefined };
}

export const RichStatusTmp: MessageFns<RichStatusTmp> = {
  encode(message: RichStatusTmp, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.toUin !== undefined) {
      writer.uint32(8).uint64(message.toUin);
    }
    if (message.sig !== undefined) {
      writer.uint32(18).bytes(message.sig);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RichStatusTmp {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRichStatusTmp();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.toUin = longToNumber(reader.uint64());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.sig = reader.bytes();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RichStatusTmp {
    return {
      toUin: isSet(object.toUin) ? globalThis.Number(object.toUin) : undefined,
      sig: isSet(object.sig) ? bytesFromBase64(object.sig) : undefined,
    };
  },

  toJSON(message: RichStatusTmp): unknown {
    const obj: any = {};
    if (message.toUin !== undefined) {
      obj.toUin = Math.round(message.toUin);
    }
    if (message.sig !== undefined) {
      obj.sig = base64FromBytes(message.sig);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<RichStatusTmp>, I>>(base?: I): RichStatusTmp {
    return RichStatusTmp.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<RichStatusTmp>, I>>(object: I): RichStatusTmp {
    const message = createBaseRichStatusTmp();
    message.toUin = object.toUin ?? undefined;
    message.sig = object.sig ?? undefined;
    return message;
  },
};

function createBaseRoutingHead(): RoutingHead {
  return {
    c2c: undefined,
    grp: undefined,
    grpTmp: undefined,
    dis: undefined,
    disTmp: undefined,
    wpaTmp: undefined,
    secretFile: undefined,
    publicPlat: undefined,
    transMsg: undefined,
    addressList: undefined,
    richStatusTmp: undefined,
    transCmd: undefined,
    accostTmp: undefined,
    pubGroupTmp: undefined,
    businessWpaTmp: undefined,
    authTmp: undefined,
    bsnsTmp: undefined,
    qqQuerybusinessTmp: undefined,
    nearbyDatingTmp: undefined,
    nearbyAssistantTmp: undefined,
    commTmp: undefined,
  };
}

export const RoutingHead: MessageFns<RoutingHead> = {
  encode(message: RoutingHead, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.c2c !== undefined) {
      C2C.encode(message.c2c, writer.uint32(10).fork()).join();
    }
    if (message.grp !== undefined) {
      Grp.encode(message.grp, writer.uint32(18).fork()).join();
    }
    if (message.grpTmp !== undefined) {
      GrpTmp.encode(message.grpTmp, writer.uint32(26).fork()).join();
    }
    if (message.dis !== undefined) {
      Dis.encode(message.dis, writer.uint32(34).fork()).join();
    }
    if (message.disTmp !== undefined) {
      DisTmp.encode(message.disTmp, writer.uint32(42).fork()).join();
    }
    if (message.wpaTmp !== undefined) {
      WPATmp.encode(message.wpaTmp, writer.uint32(50).fork()).join();
    }
    if (message.secretFile !== undefined) {
      SecretFileHead.encode(message.secretFile, writer.uint32(58).fork()).join();
    }
    if (message.publicPlat !== undefined) {
      PublicPlat.encode(message.publicPlat, writer.uint32(66).fork()).join();
    }
    if (message.transMsg !== undefined) {
      TransMsg.encode(message.transMsg, writer.uint32(74).fork()).join();
    }
    if (message.addressList !== undefined) {
      AddressListTmp.encode(message.addressList, writer.uint32(82).fork()).join();
    }
    if (message.richStatusTmp !== undefined) {
      RichStatusTmp.encode(message.richStatusTmp, writer.uint32(90).fork()).join();
    }
    if (message.transCmd !== undefined) {
      TransCmd.encode(message.transCmd, writer.uint32(98).fork()).join();
    }
    if (message.accostTmp !== undefined) {
      AccostTmp.encode(message.accostTmp, writer.uint32(106).fork()).join();
    }
    if (message.pubGroupTmp !== undefined) {
      PubGroupTmp.encode(message.pubGroupTmp, writer.uint32(114).fork()).join();
    }
    if (message.businessWpaTmp !== undefined) {
      BusinessWPATmp.encode(message.businessWpaTmp, writer.uint32(130).fork()).join();
    }
    if (message.authTmp !== undefined) {
      AuthTmp.encode(message.authTmp, writer.uint32(138).fork()).join();
    }
    if (message.bsnsTmp !== undefined) {
      BsnsTmp.encode(message.bsnsTmp, writer.uint32(146).fork()).join();
    }
    if (message.qqQuerybusinessTmp !== undefined) {
      QQQueryBusinessTmp.encode(message.qqQuerybusinessTmp, writer.uint32(154).fork()).join();
    }
    if (message.nearbyDatingTmp !== undefined) {
      NearByDatingTmp.encode(message.nearbyDatingTmp, writer.uint32(162).fork()).join();
    }
    if (message.nearbyAssistantTmp !== undefined) {
      NearByAssistantTmp.encode(message.nearbyAssistantTmp, writer.uint32(170).fork()).join();
    }
    if (message.commTmp !== undefined) {
      CommTmp.encode(message.commTmp, writer.uint32(178).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RoutingHead {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRoutingHead();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.c2c = C2C.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.grp = Grp.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.grpTmp = GrpTmp.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.dis = Dis.decode(reader, reader.uint32());
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.disTmp = DisTmp.decode(reader, reader.uint32());
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.wpaTmp = WPATmp.decode(reader, reader.uint32());
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.secretFile = SecretFileHead.decode(reader, reader.uint32());
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.publicPlat = PublicPlat.decode(reader, reader.uint32());
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.transMsg = TransMsg.decode(reader, reader.uint32());
          continue;
        }
        case 10: {
          if (tag !== 82) {
            break;
          }

          message.addressList = AddressListTmp.decode(reader, reader.uint32());
          continue;
        }
        case 11: {
          if (tag !== 90) {
            break;
          }

          message.richStatusTmp = RichStatusTmp.decode(reader, reader.uint32());
          continue;
        }
        case 12: {
          if (tag !== 98) {
            break;
          }

          message.transCmd = TransCmd.decode(reader, reader.uint32());
          continue;
        }
        case 13: {
          if (tag !== 106) {
            break;
          }

          message.accostTmp = AccostTmp.decode(reader, reader.uint32());
          continue;
        }
        case 14: {
          if (tag !== 114) {
            break;
          }

          message.pubGroupTmp = PubGroupTmp.decode(reader, reader.uint32());
          continue;
        }
        case 16: {
          if (tag !== 130) {
            break;
          }

          message.businessWpaTmp = BusinessWPATmp.decode(reader, reader.uint32());
          continue;
        }
        case 17: {
          if (tag !== 138) {
            break;
          }

          message.authTmp = AuthTmp.decode(reader, reader.uint32());
          continue;
        }
        case 18: {
          if (tag !== 146) {
            break;
          }

          message.bsnsTmp = BsnsTmp.decode(reader, reader.uint32());
          continue;
        }
        case 19: {
          if (tag !== 154) {
            break;
          }

          message.qqQuerybusinessTmp = QQQueryBusinessTmp.decode(reader, reader.uint32());
          continue;
        }
        case 20: {
          if (tag !== 162) {
            break;
          }

          message.nearbyDatingTmp = NearByDatingTmp.decode(reader, reader.uint32());
          continue;
        }
        case 21: {
          if (tag !== 170) {
            break;
          }

          message.nearbyAssistantTmp = NearByAssistantTmp.decode(reader, reader.uint32());
          continue;
        }
        case 22: {
          if (tag !== 178) {
            break;
          }

          message.commTmp = CommTmp.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RoutingHead {
    return {
      c2c: isSet(object.c2c) ? C2C.fromJSON(object.c2c) : undefined,
      grp: isSet(object.grp) ? Grp.fromJSON(object.grp) : undefined,
      grpTmp: isSet(object.grpTmp) ? GrpTmp.fromJSON(object.grpTmp) : undefined,
      dis: isSet(object.dis) ? Dis.fromJSON(object.dis) : undefined,
      disTmp: isSet(object.disTmp) ? DisTmp.fromJSON(object.disTmp) : undefined,
      wpaTmp: isSet(object.wpaTmp) ? WPATmp.fromJSON(object.wpaTmp) : undefined,
      secretFile: isSet(object.secretFile) ? SecretFileHead.fromJSON(object.secretFile) : undefined,
      publicPlat: isSet(object.publicPlat) ? PublicPlat.fromJSON(object.publicPlat) : undefined,
      transMsg: isSet(object.transMsg) ? TransMsg.fromJSON(object.transMsg) : undefined,
      addressList: isSet(object.addressList) ? AddressListTmp.fromJSON(object.addressList) : undefined,
      richStatusTmp: isSet(object.richStatusTmp) ? RichStatusTmp.fromJSON(object.richStatusTmp) : undefined,
      transCmd: isSet(object.transCmd) ? TransCmd.fromJSON(object.transCmd) : undefined,
      accostTmp: isSet(object.accostTmp) ? AccostTmp.fromJSON(object.accostTmp) : undefined,
      pubGroupTmp: isSet(object.pubGroupTmp) ? PubGroupTmp.fromJSON(object.pubGroupTmp) : undefined,
      businessWpaTmp: isSet(object.businessWpaTmp) ? BusinessWPATmp.fromJSON(object.businessWpaTmp) : undefined,
      authTmp: isSet(object.authTmp) ? AuthTmp.fromJSON(object.authTmp) : undefined,
      bsnsTmp: isSet(object.bsnsTmp) ? BsnsTmp.fromJSON(object.bsnsTmp) : undefined,
      qqQuerybusinessTmp: isSet(object.qqQuerybusinessTmp)
        ? QQQueryBusinessTmp.fromJSON(object.qqQuerybusinessTmp)
        : undefined,
      nearbyDatingTmp: isSet(object.nearbyDatingTmp) ? NearByDatingTmp.fromJSON(object.nearbyDatingTmp) : undefined,
      nearbyAssistantTmp: isSet(object.nearbyAssistantTmp)
        ? NearByAssistantTmp.fromJSON(object.nearbyAssistantTmp)
        : undefined,
      commTmp: isSet(object.commTmp) ? CommTmp.fromJSON(object.commTmp) : undefined,
    };
  },

  toJSON(message: RoutingHead): unknown {
    const obj: any = {};
    if (message.c2c !== undefined) {
      obj.c2c = C2C.toJSON(message.c2c);
    }
    if (message.grp !== undefined) {
      obj.grp = Grp.toJSON(message.grp);
    }
    if (message.grpTmp !== undefined) {
      obj.grpTmp = GrpTmp.toJSON(message.grpTmp);
    }
    if (message.dis !== undefined) {
      obj.dis = Dis.toJSON(message.dis);
    }
    if (message.disTmp !== undefined) {
      obj.disTmp = DisTmp.toJSON(message.disTmp);
    }
    if (message.wpaTmp !== undefined) {
      obj.wpaTmp = WPATmp.toJSON(message.wpaTmp);
    }
    if (message.secretFile !== undefined) {
      obj.secretFile = SecretFileHead.toJSON(message.secretFile);
    }
    if (message.publicPlat !== undefined) {
      obj.publicPlat = PublicPlat.toJSON(message.publicPlat);
    }
    if (message.transMsg !== undefined) {
      obj.transMsg = TransMsg.toJSON(message.transMsg);
    }
    if (message.addressList !== undefined) {
      obj.addressList = AddressListTmp.toJSON(message.addressList);
    }
    if (message.richStatusTmp !== undefined) {
      obj.richStatusTmp = RichStatusTmp.toJSON(message.richStatusTmp);
    }
    if (message.transCmd !== undefined) {
      obj.transCmd = TransCmd.toJSON(message.transCmd);
    }
    if (message.accostTmp !== undefined) {
      obj.accostTmp = AccostTmp.toJSON(message.accostTmp);
    }
    if (message.pubGroupTmp !== undefined) {
      obj.pubGroupTmp = PubGroupTmp.toJSON(message.pubGroupTmp);
    }
    if (message.businessWpaTmp !== undefined) {
      obj.businessWpaTmp = BusinessWPATmp.toJSON(message.businessWpaTmp);
    }
    if (message.authTmp !== undefined) {
      obj.authTmp = AuthTmp.toJSON(message.authTmp);
    }
    if (message.bsnsTmp !== undefined) {
      obj.bsnsTmp = BsnsTmp.toJSON(message.bsnsTmp);
    }
    if (message.qqQuerybusinessTmp !== undefined) {
      obj.qqQuerybusinessTmp = QQQueryBusinessTmp.toJSON(message.qqQuerybusinessTmp);
    }
    if (message.nearbyDatingTmp !== undefined) {
      obj.nearbyDatingTmp = NearByDatingTmp.toJSON(message.nearbyDatingTmp);
    }
    if (message.nearbyAssistantTmp !== undefined) {
      obj.nearbyAssistantTmp = NearByAssistantTmp.toJSON(message.nearbyAssistantTmp);
    }
    if (message.commTmp !== undefined) {
      obj.commTmp = CommTmp.toJSON(message.commTmp);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<RoutingHead>, I>>(base?: I): RoutingHead {
    return RoutingHead.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<RoutingHead>, I>>(object: I): RoutingHead {
    const message = createBaseRoutingHead();
    message.c2c = (object.c2c !== undefined && object.c2c !== null) ? C2C.fromPartial(object.c2c) : undefined;
    message.grp = (object.grp !== undefined && object.grp !== null) ? Grp.fromPartial(object.grp) : undefined;
    message.grpTmp = (object.grpTmp !== undefined && object.grpTmp !== null)
      ? GrpTmp.fromPartial(object.grpTmp)
      : undefined;
    message.dis = (object.dis !== undefined && object.dis !== null) ? Dis.fromPartial(object.dis) : undefined;
    message.disTmp = (object.disTmp !== undefined && object.disTmp !== null)
      ? DisTmp.fromPartial(object.disTmp)
      : undefined;
    message.wpaTmp = (object.wpaTmp !== undefined && object.wpaTmp !== null)
      ? WPATmp.fromPartial(object.wpaTmp)
      : undefined;
    message.secretFile = (object.secretFile !== undefined && object.secretFile !== null)
      ? SecretFileHead.fromPartial(object.secretFile)
      : undefined;
    message.publicPlat = (object.publicPlat !== undefined && object.publicPlat !== null)
      ? PublicPlat.fromPartial(object.publicPlat)
      : undefined;
    message.transMsg = (object.transMsg !== undefined && object.transMsg !== null)
      ? TransMsg.fromPartial(object.transMsg)
      : undefined;
    message.addressList = (object.addressList !== undefined && object.addressList !== null)
      ? AddressListTmp.fromPartial(object.addressList)
      : undefined;
    message.richStatusTmp = (object.richStatusTmp !== undefined && object.richStatusTmp !== null)
      ? RichStatusTmp.fromPartial(object.richStatusTmp)
      : undefined;
    message.transCmd = (object.transCmd !== undefined && object.transCmd !== null)
      ? TransCmd.fromPartial(object.transCmd)
      : undefined;
    message.accostTmp = (object.accostTmp !== undefined && object.accostTmp !== null)
      ? AccostTmp.fromPartial(object.accostTmp)
      : undefined;
    message.pubGroupTmp = (object.pubGroupTmp !== undefined && object.pubGroupTmp !== null)
      ? PubGroupTmp.fromPartial(object.pubGroupTmp)
      : undefined;
    message.businessWpaTmp = (object.businessWpaTmp !== undefined && object.businessWpaTmp !== null)
      ? BusinessWPATmp.fromPartial(object.businessWpaTmp)
      : undefined;
    message.authTmp = (object.authTmp !== undefined && object.authTmp !== null)
      ? AuthTmp.fromPartial(object.authTmp)
      : undefined;
    message.bsnsTmp = (object.bsnsTmp !== undefined && object.bsnsTmp !== null)
      ? BsnsTmp.fromPartial(object.bsnsTmp)
      : undefined;
    message.qqQuerybusinessTmp = (object.qqQuerybusinessTmp !== undefined && object.qqQuerybusinessTmp !== null)
      ? QQQueryBusinessTmp.fromPartial(object.qqQuerybusinessTmp)
      : undefined;
    message.nearbyDatingTmp = (object.nearbyDatingTmp !== undefined && object.nearbyDatingTmp !== null)
      ? NearByDatingTmp.fromPartial(object.nearbyDatingTmp)
      : undefined;
    message.nearbyAssistantTmp = (object.nearbyAssistantTmp !== undefined && object.nearbyAssistantTmp !== null)
      ? NearByAssistantTmp.fromPartial(object.nearbyAssistantTmp)
      : undefined;
    message.commTmp = (object.commTmp !== undefined && object.commTmp !== null)
      ? CommTmp.fromPartial(object.commTmp)
      : undefined;
    return message;
  },
};

function createBaseSecretFileHead(): SecretFileHead {
  return {};
}

export const SecretFileHead: MessageFns<SecretFileHead> = {
  encode(_: SecretFileHead, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SecretFileHead {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSecretFileHead();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): SecretFileHead {
    return {};
  },

  toJSON(_: SecretFileHead): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<SecretFileHead>, I>>(base?: I): SecretFileHead {
    return SecretFileHead.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SecretFileHead>, I>>(_: I): SecretFileHead {
    const message = createBaseSecretFileHead();
    return message;
  },
};

function createBaseTransCmd(): TransCmd {
  return { toUin: undefined, msgType: undefined };
}

export const TransCmd: MessageFns<TransCmd> = {
  encode(message: TransCmd, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.toUin !== undefined) {
      writer.uint32(8).uint64(message.toUin);
    }
    if (message.msgType !== undefined) {
      writer.uint32(16).uint32(message.msgType);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): TransCmd {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTransCmd();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.toUin = longToNumber(reader.uint64());
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.msgType = reader.uint32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TransCmd {
    return {
      toUin: isSet(object.toUin) ? globalThis.Number(object.toUin) : undefined,
      msgType: isSet(object.msgType) ? globalThis.Number(object.msgType) : undefined,
    };
  },

  toJSON(message: TransCmd): unknown {
    const obj: any = {};
    if (message.toUin !== undefined) {
      obj.toUin = Math.round(message.toUin);
    }
    if (message.msgType !== undefined) {
      obj.msgType = Math.round(message.msgType);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<TransCmd>, I>>(base?: I): TransCmd {
    return TransCmd.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<TransCmd>, I>>(object: I): TransCmd {
    const message = createBaseTransCmd();
    message.toUin = object.toUin ?? undefined;
    message.msgType = object.msgType ?? undefined;
    return message;
  },
};

function createBaseTransMsg(): TransMsg {
  return { toUin: undefined, c2cCmd: undefined };
}

export const TransMsg: MessageFns<TransMsg> = {
  encode(message: TransMsg, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.toUin !== undefined) {
      writer.uint32(8).uint64(message.toUin);
    }
    if (message.c2cCmd !== undefined) {
      writer.uint32(16).uint32(message.c2cCmd);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): TransMsg {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTransMsg();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.toUin = longToNumber(reader.uint64());
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.c2cCmd = reader.uint32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TransMsg {
    return {
      toUin: isSet(object.toUin) ? globalThis.Number(object.toUin) : undefined,
      c2cCmd: isSet(object.c2cCmd) ? globalThis.Number(object.c2cCmd) : undefined,
    };
  },

  toJSON(message: TransMsg): unknown {
    const obj: any = {};
    if (message.toUin !== undefined) {
      obj.toUin = Math.round(message.toUin);
    }
    if (message.c2cCmd !== undefined) {
      obj.c2cCmd = Math.round(message.c2cCmd);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<TransMsg>, I>>(base?: I): TransMsg {
    return TransMsg.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<TransMsg>, I>>(object: I): TransMsg {
    const message = createBaseTransMsg();
    message.toUin = object.toUin ?? undefined;
    message.c2cCmd = object.c2cCmd ?? undefined;
    return message;
  },
};

function createBaseTransReq(): TransReq {
  return { command: undefined, reqTag: undefined, reqBuff: undefined };
}

export const TransReq: MessageFns<TransReq> = {
  encode(message: TransReq, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.command !== undefined) {
      writer.uint32(8).int32(message.command);
    }
    if (message.reqTag !== undefined) {
      writer.uint32(16).uint32(message.reqTag);
    }
    if (message.reqBuff !== undefined) {
      writer.uint32(26).bytes(message.reqBuff);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): TransReq {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTransReq();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.command = reader.int32();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.reqTag = reader.uint32();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.reqBuff = reader.bytes();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TransReq {
    return {
      command: isSet(object.command) ? globalThis.Number(object.command) : undefined,
      reqTag: isSet(object.reqTag) ? globalThis.Number(object.reqTag) : undefined,
      reqBuff: isSet(object.reqBuff) ? bytesFromBase64(object.reqBuff) : undefined,
    };
  },

  toJSON(message: TransReq): unknown {
    const obj: any = {};
    if (message.command !== undefined) {
      obj.command = Math.round(message.command);
    }
    if (message.reqTag !== undefined) {
      obj.reqTag = Math.round(message.reqTag);
    }
    if (message.reqBuff !== undefined) {
      obj.reqBuff = base64FromBytes(message.reqBuff);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<TransReq>, I>>(base?: I): TransReq {
    return TransReq.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<TransReq>, I>>(object: I): TransReq {
    const message = createBaseTransReq();
    message.command = object.command ?? undefined;
    message.reqTag = object.reqTag ?? undefined;
    message.reqBuff = object.reqBuff ?? undefined;
    return message;
  },
};

function createBaseTransResp(): TransResp {
  return { result: undefined, errmsg: undefined, respTag: undefined, respBuff: undefined };
}

export const TransResp: MessageFns<TransResp> = {
  encode(message: TransResp, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.result !== undefined) {
      writer.uint32(8).uint32(message.result);
    }
    if (message.errmsg !== undefined) {
      writer.uint32(18).string(message.errmsg);
    }
    if (message.respTag !== undefined) {
      writer.uint32(24).uint32(message.respTag);
    }
    if (message.respBuff !== undefined) {
      writer.uint32(34).bytes(message.respBuff);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): TransResp {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTransResp();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.result = reader.uint32();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.errmsg = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.respTag = reader.uint32();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.respBuff = reader.bytes();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TransResp {
    return {
      result: isSet(object.result) ? globalThis.Number(object.result) : undefined,
      errmsg: isSet(object.errmsg) ? globalThis.String(object.errmsg) : undefined,
      respTag: isSet(object.respTag) ? globalThis.Number(object.respTag) : undefined,
      respBuff: isSet(object.respBuff) ? bytesFromBase64(object.respBuff) : undefined,
    };
  },

  toJSON(message: TransResp): unknown {
    const obj: any = {};
    if (message.result !== undefined) {
      obj.result = Math.round(message.result);
    }
    if (message.errmsg !== undefined) {
      obj.errmsg = message.errmsg;
    }
    if (message.respTag !== undefined) {
      obj.respTag = Math.round(message.respTag);
    }
    if (message.respBuff !== undefined) {
      obj.respBuff = base64FromBytes(message.respBuff);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<TransResp>, I>>(base?: I): TransResp {
    return TransResp.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<TransResp>, I>>(object: I): TransResp {
    const message = createBaseTransResp();
    message.result = object.result ?? undefined;
    message.errmsg = object.errmsg ?? undefined;
    message.respTag = object.respTag ?? undefined;
    message.respBuff = object.respBuff ?? undefined;
    return message;
  },
};

function createBaseTransSvrInfo(): TransSvrInfo {
  return { uint32SubType: undefined, int32RetCode: undefined, bytesErrMsg: undefined, bytesTransInfo: undefined };
}

export const TransSvrInfo: MessageFns<TransSvrInfo> = {
  encode(message: TransSvrInfo, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.uint32SubType !== undefined) {
      writer.uint32(8).uint32(message.uint32SubType);
    }
    if (message.int32RetCode !== undefined) {
      writer.uint32(16).int32(message.int32RetCode);
    }
    if (message.bytesErrMsg !== undefined) {
      writer.uint32(26).bytes(message.bytesErrMsg);
    }
    if (message.bytesTransInfo !== undefined) {
      writer.uint32(34).bytes(message.bytesTransInfo);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): TransSvrInfo {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTransSvrInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.uint32SubType = reader.uint32();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.int32RetCode = reader.int32();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.bytesErrMsg = reader.bytes();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.bytesTransInfo = reader.bytes();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TransSvrInfo {
    return {
      uint32SubType: isSet(object.uint32SubType) ? globalThis.Number(object.uint32SubType) : undefined,
      int32RetCode: isSet(object.int32RetCode) ? globalThis.Number(object.int32RetCode) : undefined,
      bytesErrMsg: isSet(object.bytesErrMsg) ? bytesFromBase64(object.bytesErrMsg) : undefined,
      bytesTransInfo: isSet(object.bytesTransInfo) ? bytesFromBase64(object.bytesTransInfo) : undefined,
    };
  },

  toJSON(message: TransSvrInfo): unknown {
    const obj: any = {};
    if (message.uint32SubType !== undefined) {
      obj.uint32SubType = Math.round(message.uint32SubType);
    }
    if (message.int32RetCode !== undefined) {
      obj.int32RetCode = Math.round(message.int32RetCode);
    }
    if (message.bytesErrMsg !== undefined) {
      obj.bytesErrMsg = base64FromBytes(message.bytesErrMsg);
    }
    if (message.bytesTransInfo !== undefined) {
      obj.bytesTransInfo = base64FromBytes(message.bytesTransInfo);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<TransSvrInfo>, I>>(base?: I): TransSvrInfo {
    return TransSvrInfo.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<TransSvrInfo>, I>>(object: I): TransSvrInfo {
    const message = createBaseTransSvrInfo();
    message.uint32SubType = object.uint32SubType ?? undefined;
    message.int32RetCode = object.int32RetCode ?? undefined;
    message.bytesErrMsg = object.bytesErrMsg ?? undefined;
    message.bytesTransInfo = object.bytesTransInfo ?? undefined;
    return message;
  },
};

function createBaseWithDrawWordingInfo(): WithDrawWordingInfo {
  return { int32ItemId: undefined, stringItemName: undefined };
}

export const WithDrawWordingInfo: MessageFns<WithDrawWordingInfo> = {
  encode(message: WithDrawWordingInfo, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.int32ItemId !== undefined) {
      writer.uint32(8).int32(message.int32ItemId);
    }
    if (message.stringItemName !== undefined) {
      writer.uint32(18).string(message.stringItemName);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): WithDrawWordingInfo {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseWithDrawWordingInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.int32ItemId = reader.int32();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.stringItemName = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): WithDrawWordingInfo {
    return {
      int32ItemId: isSet(object.int32ItemId) ? globalThis.Number(object.int32ItemId) : undefined,
      stringItemName: isSet(object.stringItemName) ? globalThis.String(object.stringItemName) : undefined,
    };
  },

  toJSON(message: WithDrawWordingInfo): unknown {
    const obj: any = {};
    if (message.int32ItemId !== undefined) {
      obj.int32ItemId = Math.round(message.int32ItemId);
    }
    if (message.stringItemName !== undefined) {
      obj.stringItemName = message.stringItemName;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<WithDrawWordingInfo>, I>>(base?: I): WithDrawWordingInfo {
    return WithDrawWordingInfo.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<WithDrawWordingInfo>, I>>(object: I): WithDrawWordingInfo {
    const message = createBaseWithDrawWordingInfo();
    message.int32ItemId = object.int32ItemId ?? undefined;
    message.stringItemName = object.stringItemName ?? undefined;
    return message;
  },
};

function createBaseWPATmp(): WPATmp {
  return { toUin: undefined, sig: undefined };
}

export const WPATmp: MessageFns<WPATmp> = {
  encode(message: WPATmp, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.toUin !== undefined) {
      writer.uint32(8).uint64(message.toUin);
    }
    if (message.sig !== undefined) {
      writer.uint32(18).bytes(message.sig);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): WPATmp {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseWPATmp();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.toUin = longToNumber(reader.uint64());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.sig = reader.bytes();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): WPATmp {
    return {
      toUin: isSet(object.toUin) ? globalThis.Number(object.toUin) : undefined,
      sig: isSet(object.sig) ? bytesFromBase64(object.sig) : undefined,
    };
  },

  toJSON(message: WPATmp): unknown {
    const obj: any = {};
    if (message.toUin !== undefined) {
      obj.toUin = Math.round(message.toUin);
    }
    if (message.sig !== undefined) {
      obj.sig = base64FromBytes(message.sig);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<WPATmp>, I>>(base?: I): WPATmp {
    return WPATmp.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<WPATmp>, I>>(object: I): WPATmp {
    const message = createBaseWPATmp();
    message.toUin = object.toUin ?? undefined;
    message.sig = object.sig ?? undefined;
    return message;
  },
};

function bytesFromBase64(b64: string): Uint8Array {
  if ((globalThis as any).Buffer) {
    return Uint8Array.from(globalThis.Buffer.from(b64, "base64"));
  } else {
    const bin = globalThis.atob(b64);
    const arr = new Uint8Array(bin.length);
    for (let i = 0; i < bin.length; ++i) {
      arr[i] = bin.charCodeAt(i);
    }
    return arr;
  }
}

function base64FromBytes(arr: Uint8Array): string {
  if ((globalThis as any).Buffer) {
    return globalThis.Buffer.from(arr).toString("base64");
  } else {
    const bin: string[] = [];
    arr.forEach((byte) => {
      bin.push(globalThis.String.fromCharCode(byte));
    });
    return globalThis.btoa(bin.join(""));
  }
}

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

type KeysOfUnion<T> = T extends T ? keyof T : never;
export type Exact<P, I extends P> = P extends Builtin ? P
  : P & { [K in keyof P]: Exact<P[K], I[K]> } & { [K in Exclude<keyof I, KeysOfUnion<P>>]: never };

function longToNumber(int64: { toString(): string }): number {
  const num = globalThis.Number(int64.toString());
  if (num > globalThis.Number.MAX_SAFE_INTEGER) {
    throw new globalThis.Error("Value is larger than Number.MAX_SAFE_INTEGER");
  }
  if (num < globalThis.Number.MIN_SAFE_INTEGER) {
    throw new globalThis.Error("Value is smaller than Number.MIN_SAFE_INTEGER");
  }
  return num;
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create<I extends Exact<DeepPartial<T>, I>>(base?: I): T;
  fromPartial<I extends Exact<DeepPartial<T>, I>>(object: I): T;
}
