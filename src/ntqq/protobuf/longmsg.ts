// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.2.5
//   protoc               v6.32.1
// source: longmsg.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import { Msg } from "./nt_msg_common";

export const protobufPackage = "nt.longmsg";

export interface SsoSendLongMsgReq {
  body: LongMsgBody | undefined;
}

export interface LongMsgBody {
  fileName: string;
  data: LongMsgData | undefined;
}

export interface LongMsgData {
  msgs: Msg[];
}

export interface LongMsgSettings {
  /** 4 */
  field1: number;
  /** 1 */
  field2: number;
  /** 7 */
  field3: number;
  /** 0 */
  field4: number;
}

export interface SendLongMsgReq {
  info: SendLongMsgInfo | undefined;
  settings: LongMsgSettings | undefined;
}

export interface SendLongMsgInfo {
  /** Group: 3, Friend: 1 */
  type: number;
  peer?: PeerInfo | undefined;
  groupCode?: number | undefined;
  payload?: Uint8Array | undefined;
}

export interface PeerInfo {
  uid?: string | undefined;
}

export interface SendLongMsgResp {
  result: SendLongMsgResult | undefined;
  settings: LongMsgSettings | undefined;
}

export interface SendLongMsgResult {
  resId: string;
}

function createBaseSsoSendLongMsgReq(): SsoSendLongMsgReq {
  return { body: undefined };
}

export const SsoSendLongMsgReq: MessageFns<SsoSendLongMsgReq> = {
  encode(message: SsoSendLongMsgReq, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.body !== undefined) {
      LongMsgBody.encode(message.body, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SsoSendLongMsgReq {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSsoSendLongMsgReq();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.body = LongMsgBody.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SsoSendLongMsgReq {
    return { body: isSet(object.body) ? LongMsgBody.fromJSON(object.body) : undefined };
  },

  toJSON(message: SsoSendLongMsgReq): unknown {
    const obj: any = {};
    if (message.body !== undefined) {
      obj.body = LongMsgBody.toJSON(message.body);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<SsoSendLongMsgReq>, I>>(base?: I): SsoSendLongMsgReq {
    return SsoSendLongMsgReq.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SsoSendLongMsgReq>, I>>(object: I): SsoSendLongMsgReq {
    const message = createBaseSsoSendLongMsgReq();
    message.body = (object.body !== undefined && object.body !== null)
      ? LongMsgBody.fromPartial(object.body)
      : undefined;
    return message;
  },
};

function createBaseLongMsgBody(): LongMsgBody {
  return { fileName: "", data: undefined };
}

export const LongMsgBody: MessageFns<LongMsgBody> = {
  encode(message: LongMsgBody, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.fileName !== "") {
      writer.uint32(10).string(message.fileName);
    }
    if (message.data !== undefined) {
      LongMsgData.encode(message.data, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): LongMsgBody {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseLongMsgBody();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.fileName = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.data = LongMsgData.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): LongMsgBody {
    return {
      fileName: isSet(object.fileName) ? globalThis.String(object.fileName) : "",
      data: isSet(object.data) ? LongMsgData.fromJSON(object.data) : undefined,
    };
  },

  toJSON(message: LongMsgBody): unknown {
    const obj: any = {};
    if (message.fileName !== "") {
      obj.fileName = message.fileName;
    }
    if (message.data !== undefined) {
      obj.data = LongMsgData.toJSON(message.data);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<LongMsgBody>, I>>(base?: I): LongMsgBody {
    return LongMsgBody.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<LongMsgBody>, I>>(object: I): LongMsgBody {
    const message = createBaseLongMsgBody();
    message.fileName = object.fileName ?? "";
    message.data = (object.data !== undefined && object.data !== null)
      ? LongMsgData.fromPartial(object.data)
      : undefined;
    return message;
  },
};

function createBaseLongMsgData(): LongMsgData {
  return { msgs: [] };
}

export const LongMsgData: MessageFns<LongMsgData> = {
  encode(message: LongMsgData, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.msgs) {
      Msg.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): LongMsgData {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseLongMsgData();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.msgs.push(Msg.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): LongMsgData {
    return { msgs: globalThis.Array.isArray(object?.msgs) ? object.msgs.map((e: any) => Msg.fromJSON(e)) : [] };
  },

  toJSON(message: LongMsgData): unknown {
    const obj: any = {};
    if (message.msgs?.length) {
      obj.msgs = message.msgs.map((e) => Msg.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<LongMsgData>, I>>(base?: I): LongMsgData {
    return LongMsgData.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<LongMsgData>, I>>(object: I): LongMsgData {
    const message = createBaseLongMsgData();
    message.msgs = object.msgs?.map((e) => Msg.fromPartial(e)) || [];
    return message;
  },
};

function createBaseLongMsgSettings(): LongMsgSettings {
  return { field1: 0, field2: 0, field3: 0, field4: 0 };
}

export const LongMsgSettings: MessageFns<LongMsgSettings> = {
  encode(message: LongMsgSettings, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.field1 !== 0) {
      writer.uint32(8).uint32(message.field1);
    }
    if (message.field2 !== 0) {
      writer.uint32(16).uint32(message.field2);
    }
    if (message.field3 !== 0) {
      writer.uint32(24).uint32(message.field3);
    }
    if (message.field4 !== 0) {
      writer.uint32(32).uint32(message.field4);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): LongMsgSettings {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseLongMsgSettings();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.field1 = reader.uint32();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.field2 = reader.uint32();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.field3 = reader.uint32();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.field4 = reader.uint32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): LongMsgSettings {
    return {
      field1: isSet(object.field1) ? globalThis.Number(object.field1) : 0,
      field2: isSet(object.field2) ? globalThis.Number(object.field2) : 0,
      field3: isSet(object.field3) ? globalThis.Number(object.field3) : 0,
      field4: isSet(object.field4) ? globalThis.Number(object.field4) : 0,
    };
  },

  toJSON(message: LongMsgSettings): unknown {
    const obj: any = {};
    if (message.field1 !== 0) {
      obj.field1 = Math.round(message.field1);
    }
    if (message.field2 !== 0) {
      obj.field2 = Math.round(message.field2);
    }
    if (message.field3 !== 0) {
      obj.field3 = Math.round(message.field3);
    }
    if (message.field4 !== 0) {
      obj.field4 = Math.round(message.field4);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<LongMsgSettings>, I>>(base?: I): LongMsgSettings {
    return LongMsgSettings.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<LongMsgSettings>, I>>(object: I): LongMsgSettings {
    const message = createBaseLongMsgSettings();
    message.field1 = object.field1 ?? 0;
    message.field2 = object.field2 ?? 0;
    message.field3 = object.field3 ?? 0;
    message.field4 = object.field4 ?? 0;
    return message;
  },
};

function createBaseSendLongMsgReq(): SendLongMsgReq {
  return { info: undefined, settings: undefined };
}

export const SendLongMsgReq: MessageFns<SendLongMsgReq> = {
  encode(message: SendLongMsgReq, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.info !== undefined) {
      SendLongMsgInfo.encode(message.info, writer.uint32(18).fork()).join();
    }
    if (message.settings !== undefined) {
      LongMsgSettings.encode(message.settings, writer.uint32(122).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SendLongMsgReq {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSendLongMsgReq();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.info = SendLongMsgInfo.decode(reader, reader.uint32());
          continue;
        }
        case 15: {
          if (tag !== 122) {
            break;
          }

          message.settings = LongMsgSettings.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SendLongMsgReq {
    return {
      info: isSet(object.info) ? SendLongMsgInfo.fromJSON(object.info) : undefined,
      settings: isSet(object.settings) ? LongMsgSettings.fromJSON(object.settings) : undefined,
    };
  },

  toJSON(message: SendLongMsgReq): unknown {
    const obj: any = {};
    if (message.info !== undefined) {
      obj.info = SendLongMsgInfo.toJSON(message.info);
    }
    if (message.settings !== undefined) {
      obj.settings = LongMsgSettings.toJSON(message.settings);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<SendLongMsgReq>, I>>(base?: I): SendLongMsgReq {
    return SendLongMsgReq.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SendLongMsgReq>, I>>(object: I): SendLongMsgReq {
    const message = createBaseSendLongMsgReq();
    message.info = (object.info !== undefined && object.info !== null)
      ? SendLongMsgInfo.fromPartial(object.info)
      : undefined;
    message.settings = (object.settings !== undefined && object.settings !== null)
      ? LongMsgSettings.fromPartial(object.settings)
      : undefined;
    return message;
  },
};

function createBaseSendLongMsgInfo(): SendLongMsgInfo {
  return { type: 0, peer: undefined, groupCode: undefined, payload: undefined };
}

export const SendLongMsgInfo: MessageFns<SendLongMsgInfo> = {
  encode(message: SendLongMsgInfo, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.type !== 0) {
      writer.uint32(8).uint32(message.type);
    }
    if (message.peer !== undefined) {
      PeerInfo.encode(message.peer, writer.uint32(18).fork()).join();
    }
    if (message.groupCode !== undefined) {
      writer.uint32(24).uint32(message.groupCode);
    }
    if (message.payload !== undefined) {
      writer.uint32(34).bytes(message.payload);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SendLongMsgInfo {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSendLongMsgInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.type = reader.uint32();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.peer = PeerInfo.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.groupCode = reader.uint32();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.payload = reader.bytes();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SendLongMsgInfo {
    return {
      type: isSet(object.type) ? globalThis.Number(object.type) : 0,
      peer: isSet(object.peer) ? PeerInfo.fromJSON(object.peer) : undefined,
      groupCode: isSet(object.groupCode) ? globalThis.Number(object.groupCode) : undefined,
      payload: isSet(object.payload) ? bytesFromBase64(object.payload) : undefined,
    };
  },

  toJSON(message: SendLongMsgInfo): unknown {
    const obj: any = {};
    if (message.type !== 0) {
      obj.type = Math.round(message.type);
    }
    if (message.peer !== undefined) {
      obj.peer = PeerInfo.toJSON(message.peer);
    }
    if (message.groupCode !== undefined) {
      obj.groupCode = Math.round(message.groupCode);
    }
    if (message.payload !== undefined) {
      obj.payload = base64FromBytes(message.payload);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<SendLongMsgInfo>, I>>(base?: I): SendLongMsgInfo {
    return SendLongMsgInfo.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SendLongMsgInfo>, I>>(object: I): SendLongMsgInfo {
    const message = createBaseSendLongMsgInfo();
    message.type = object.type ?? 0;
    message.peer = (object.peer !== undefined && object.peer !== null) ? PeerInfo.fromPartial(object.peer) : undefined;
    message.groupCode = object.groupCode ?? undefined;
    message.payload = object.payload ?? undefined;
    return message;
  },
};

function createBasePeerInfo(): PeerInfo {
  return { uid: undefined };
}

export const PeerInfo: MessageFns<PeerInfo> = {
  encode(message: PeerInfo, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.uid !== undefined) {
      writer.uint32(18).string(message.uid);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PeerInfo {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePeerInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.uid = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PeerInfo {
    return { uid: isSet(object.uid) ? globalThis.String(object.uid) : undefined };
  },

  toJSON(message: PeerInfo): unknown {
    const obj: any = {};
    if (message.uid !== undefined) {
      obj.uid = message.uid;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<PeerInfo>, I>>(base?: I): PeerInfo {
    return PeerInfo.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<PeerInfo>, I>>(object: I): PeerInfo {
    const message = createBasePeerInfo();
    message.uid = object.uid ?? undefined;
    return message;
  },
};

function createBaseSendLongMsgResp(): SendLongMsgResp {
  return { result: undefined, settings: undefined };
}

export const SendLongMsgResp: MessageFns<SendLongMsgResp> = {
  encode(message: SendLongMsgResp, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.result !== undefined) {
      SendLongMsgResult.encode(message.result, writer.uint32(18).fork()).join();
    }
    if (message.settings !== undefined) {
      LongMsgSettings.encode(message.settings, writer.uint32(122).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SendLongMsgResp {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSendLongMsgResp();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.result = SendLongMsgResult.decode(reader, reader.uint32());
          continue;
        }
        case 15: {
          if (tag !== 122) {
            break;
          }

          message.settings = LongMsgSettings.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SendLongMsgResp {
    return {
      result: isSet(object.result) ? SendLongMsgResult.fromJSON(object.result) : undefined,
      settings: isSet(object.settings) ? LongMsgSettings.fromJSON(object.settings) : undefined,
    };
  },

  toJSON(message: SendLongMsgResp): unknown {
    const obj: any = {};
    if (message.result !== undefined) {
      obj.result = SendLongMsgResult.toJSON(message.result);
    }
    if (message.settings !== undefined) {
      obj.settings = LongMsgSettings.toJSON(message.settings);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<SendLongMsgResp>, I>>(base?: I): SendLongMsgResp {
    return SendLongMsgResp.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SendLongMsgResp>, I>>(object: I): SendLongMsgResp {
    const message = createBaseSendLongMsgResp();
    message.result = (object.result !== undefined && object.result !== null)
      ? SendLongMsgResult.fromPartial(object.result)
      : undefined;
    message.settings = (object.settings !== undefined && object.settings !== null)
      ? LongMsgSettings.fromPartial(object.settings)
      : undefined;
    return message;
  },
};

function createBaseSendLongMsgResult(): SendLongMsgResult {
  return { resId: "" };
}

export const SendLongMsgResult: MessageFns<SendLongMsgResult> = {
  encode(message: SendLongMsgResult, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.resId !== "") {
      writer.uint32(26).string(message.resId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SendLongMsgResult {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSendLongMsgResult();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.resId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SendLongMsgResult {
    return { resId: isSet(object.resId) ? globalThis.String(object.resId) : "" };
  },

  toJSON(message: SendLongMsgResult): unknown {
    const obj: any = {};
    if (message.resId !== "") {
      obj.resId = message.resId;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<SendLongMsgResult>, I>>(base?: I): SendLongMsgResult {
    return SendLongMsgResult.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SendLongMsgResult>, I>>(object: I): SendLongMsgResult {
    const message = createBaseSendLongMsgResult();
    message.resId = object.resId ?? "";
    return message;
  },
};

function bytesFromBase64(b64: string): Uint8Array {
  if ((globalThis as any).Buffer) {
    return Uint8Array.from(globalThis.Buffer.from(b64, "base64"));
  } else {
    const bin = globalThis.atob(b64);
    const arr = new Uint8Array(bin.length);
    for (let i = 0; i < bin.length; ++i) {
      arr[i] = bin.charCodeAt(i);
    }
    return arr;
  }
}

function base64FromBytes(arr: Uint8Array): string {
  if ((globalThis as any).Buffer) {
    return globalThis.Buffer.from(arr).toString("base64");
  } else {
    const bin: string[] = [];
    arr.forEach((byte) => {
      bin.push(globalThis.String.fromCharCode(byte));
    });
    return globalThis.btoa(bin.join(""));
  }
}

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

type KeysOfUnion<T> = T extends T ? keyof T : never;
export type Exact<P, I extends P> = P extends Builtin ? P
  : P & { [K in keyof P]: Exact<P[K], I[K]> } & { [K in Exclude<keyof I, KeysOfUnion<P>>]: never };

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create<I extends Exact<DeepPartial<T>, I>>(base?: I): T;
  fromPartial<I extends Exact<DeepPartial<T>, I>>(object: I): T;
}
